{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/Valine.min.js","path":"js/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.css","path":"libs/font-awesome5/css/fa-brands.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.min.css","path":"libs/font-awesome5/css/fa-brands.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.css","path":"libs/font-awesome5/css/fa-solid.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.min.css","path":"libs/font-awesome5/css/fa-solid.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.css","path":"libs/font-awesome5/css/fontawesome.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.min.css","path":"libs/font-awesome5/css/fontawesome.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff2","path":"libs/font-awesome5/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff","path":"libs/font-awesome5/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff2","path":"libs/font-awesome5/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.eot","path":"libs/font-awesome5/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff","path":"libs/font-awesome5/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.ttf","path":"libs/font-awesome5/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.eot","path":"libs/font-awesome5/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.ttf","path":"libs/font-awesome5/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.jpg","path":"css/images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.svg","path":"libs/font-awesome5/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.svg","path":"libs/font-awesome5/webfonts/fa-brands-400.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1531408992000},{"_id":"themes/icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1531408992000},{"_id":"themes/icarus/README.md","hash":"acd2d5d12820b065345d68f88bfc3a739f8d8ae2","modified":1531408992000},{"_id":"themes/icarus/_config.yml","hash":"b847cc0e90fb8b685af6a8b1718d3f04c76f3c48","modified":1544683062225},{"_id":"themes/icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1531408992000},{"_id":"source/about/index.html","hash":"fecee74b1e167a53cc130f3220b4fe9620caa0e9","modified":1543889132151},{"_id":"source/about/index.md","hash":"814ac4c68b42a4ec2a72566ad316d434b73d0ade","modified":1543804035561},{"_id":"source/categories/index.md","hash":"fddef9937a21af2e81fe6bd4549e63fcc9c4a63c","modified":1538042427766},{"_id":"source/_posts/GITduozhanghu.md","hash":"67d9833f7845fc56026deff142cd14a8abd1bd18","modified":1545394719445},{"_id":"source/_posts/Generator.md","hash":"323f2a9e7ea9e652ecd55cd062e3bd5e12fba0dd","modified":1539165444772},{"_id":"source/_posts/HTTP状态码和AJAX状态值.md","hash":"e7aab96ebfd196c905bb27263948c1b8d8b8b9a5","modified":1544249637516},{"_id":"source/_posts/Promise.md","hash":"4651b75e860a61d2cbdfe91114442226fa67344b","modified":1543476190703},{"_id":"source/_posts/RISE.md","hash":"dddeb0ad2e675857cf84aa57df02cb4caa504e34","modified":1543541477569},{"_id":"source/_posts/async.md","hash":"ba2bd3b19488fc33739822f7e2d3e5165a869e74","modified":1543367850580},{"_id":"source/_posts/hexo-创建文章.md","hash":"c43699d5487f57fcff1a0e569c782cb467776770","modified":1545361556057},{"_id":"source/_posts/hexo常用指令.md","hash":"88cec51c92ff4c5da8c18c8ab6dffffc0640f95d","modified":1545361085715},{"_id":"source/_posts/jenkins部署个人博客.md","hash":"6daef4f2a00901df71a3b2a25a36656f08dba026","modified":1544264515686},{"_id":"source/_posts/js构造函数.md","hash":"165893a6828554ba2e8cf98bdcc4e9b0d95448cd","modified":1539076811831},{"_id":"source/_posts/监听浏览器刷新及关闭.md","hash":"08d2b8b2a2a9fc6fc6fd718a3f8e14d7eafa5632","modified":1545361061986},{"_id":"source/_posts/给Hexo博客添加访问统计.md","hash":"aefcb71e9a52343d451e1ead54dc9bde788acaa9","modified":1543540414492},{"_id":"source/_posts/递归尾调用优化.md","hash":"33d3c5535be67cf6dfa64c126c2c5c5ac120e963","modified":1543540443374},{"_id":"source/_posts/递归树结构解析.md","hash":"31b35c5726b32fca12eb736b0b932a9ac7e02036","modified":1544064755771},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"9393fd3dbc943f1544facb66af7fd8b7a5b9ddbb","modified":1531408992000},{"_id":"source/tags/index.md","hash":"e2ccf34d45ddbfc8ce1a41192350ff6d42239dd9","modified":1538042474759},{"_id":"themes/icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1531408992000},{"_id":"themes/icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1531408992000},{"_id":"themes/icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1531408992000},{"_id":"themes/icarus/languages/id.yml","hash":"e4961da507f66c8f7c37f85653a9437cb2056bf6","modified":1531408992000},{"_id":"themes/icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1531408992000},{"_id":"themes/icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1531408992000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1531408992000},{"_id":"themes/icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1531408992000},{"_id":"themes/icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1531408992000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1531408992000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1531408992000},{"_id":"themes/icarus/layout/archive.ejs","hash":"a369f50b7bb4a3fb30c95dccc813f0552172d827","modified":1531408992000},{"_id":"themes/icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1538102359397},{"_id":"themes/icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1531408992000},{"_id":"themes/icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1531408992000},{"_id":"themes/icarus/layout/layout.ejs","hash":"7a0c58feaff65c4523891de904be81ba45f22e6b","modified":1543891004306},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1531408992000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1531408992000},{"_id":"themes/icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1531408992000},{"_id":"themes/icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1531408992000},{"_id":"themes/icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1531408992000},{"_id":"themes/icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1531408992000},{"_id":"source/_posts/GITduozhanghu/git_1.jpg","hash":"1a4677b233f5d28c5ebddea71e9206d83f7cabd2","modified":1545373923889},{"_id":"source/_posts/HTTP状态码和AJAX状态值/http.jpg","hash":"e45575b0948d0318aea31c720b0def3ffc493a06","modified":1543889260477},{"_id":"source/_posts/RISE/banner.jpg","hash":"046ae6a9ddf3c7c60a04271c44e9df49813301d0","modified":1539077776797},{"_id":"source/_posts/hexo-创建文章/lujing2.jpg","hash":"a390f5b69d7f608004d42bc55182e503bb64f7ff","modified":1538129660626},{"_id":"source/_posts/hexo-创建文章/wenjian.jpg","hash":"1d46842690b5f85273dc39bfebd5157707b982a8","modified":1538130158856},{"_id":"source/_posts/jenkins部署个人博客/jdk-1.png","hash":"c4794d65d2221d0b0acb902bd8a3ee8ef3a943b2","modified":1544257023885},{"_id":"source/_posts/jenkins部署个人博客/jdk-2.png","hash":"41147b4369f5d51a048889ea3bf04e25d26972ef","modified":1544257134580},{"_id":"source/_posts/jenkins部署个人博客/jdk-3.png","hash":"d81767c7569127f424a281564d29ca36f227d66b","modified":1544257295890},{"_id":"source/_posts/jenkins部署个人博客/jdk.png","hash":"da437cacb97df8961417d0a27390cbaa3ec29023","modified":1544256618389},{"_id":"source/_posts/jenkins部署个人博客/jenkins-2.jpg","hash":"222c15fda1be771c533f5ef3d122fa618c1c67c4","modified":1544264204987},{"_id":"source/_posts/jenkins部署个人博客/jenkins-3.jpg","hash":"1ed088b051c6e36f2f94a85c67faf4b71919c8eb","modified":1544264384332},{"_id":"source/_posts/jenkins部署个人博客/jenkins-4.jpg","hash":"ee41e108b2a9989795f1e8be46ff3acfacc80992","modified":1544264427118},{"_id":"source/_posts/js构造函数/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1539076680366},{"_id":"source/_posts/给Hexo博客添加访问统计/bsz.jpg","hash":"bf72ba6bbc89d3979c9e83ebaf90a2f0673de6e2","modified":1539054558509},{"_id":"source/_posts/给Hexo博客添加访问统计/timg.jpg","hash":"48008426aebff3897fb41aa4319b0dc6637778ed","modified":1538036753161},{"_id":"source/_posts/递归树结构解析/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1539076680366},{"_id":"source/_posts/递归树结构解析/result.jpg","hash":"d3cc67d6e6db5ab158ddcd335be3b354f2b36a56","modified":1538986270957},{"_id":"themes/icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1531408992000},{"_id":"themes/icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1531408992000},{"_id":"themes/icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1531408992000},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"b4bd2e641af59e06becaa8f2dc97867f023b8dcf","modified":1531408992000},{"_id":"themes/icarus/layout/comment/counter.ejs","hash":"57c194d0fa268ce2f3e9c755b3154b8a0709f613","modified":1531408992000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1531408992000},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1531408992000},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1531408992000},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"c7998209b9a766eeba6976dd4bdffb1f87469358","modified":1531408992000},{"_id":"themes/icarus/layout/comment/index.ejs","hash":"0bce9ca0767b49d2a9fc026a6004a8526a20624b","modified":1531408992000},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"4f8b81ff5bb418ec11ce080d515f247bfe436014","modified":1531408992000},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"792e4f0e93b2bdc5abd85d447d804a5c608a9c5c","modified":1531408992000},{"_id":"themes/icarus/layout/comment/scripts.ejs","hash":"d45f652268671de96c86d8ca50b9deaf011274f0","modified":1531408992000},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"709bad05d9d9a2578110b845122982070a1d70f0","modified":1538300512585},{"_id":"themes/icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1531408992000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"af6381cad6117c940a44cff443e62c34ca0ca72e","modified":1543913036847},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"39be5e6601fd2c251f0a9da3cdec65c3e03f320b","modified":1538036253423},{"_id":"themes/icarus/layout/common/head.ejs","hash":"daf0b5a6201e09782500795f3db84713a92c791a","modified":1531408992000},{"_id":"themes/icarus/layout/common/header.ejs","hash":"d5ad64c3097752c4e19924d16bd9554264cd85c5","modified":1543913458015},{"_id":"themes/icarus/layout/common/loadingbar.ejs","hash":"36917f8d3e0cf981a6efa5593d46131176591e9b","modified":1543891945712},{"_id":"themes/icarus/layout/common/profile.ejs","hash":"a60d519c968b622e5bdbddd623af41f0d32a5241","modified":1538103252466},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1531408992000},{"_id":"themes/icarus/layout/common/sidebar.ejs","hash":"8cee4531fb0deca8f0951ef93f039028bc7f343c","modified":1531408992000},{"_id":"themes/icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1531408992000},{"_id":"themes/icarus/layout/common/timeline.ejs","hash":"48235931698f04ad0ff057a1693ce81e628f9e0a","modified":1531408992000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1531408992000},{"_id":"themes/icarus/layout/plugin/scripts.ejs","hash":"e22f99652a220d926103801a3cad55ea9c450e05","modified":1531408992000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1531408992000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1531408992000},{"_id":"themes/icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1531408992000},{"_id":"themes/icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1543917640348},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"bcf275e42efbc6677a0fd35f5501e7618ffe9e4c","modified":1531408992000},{"_id":"themes/icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1531408992000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1531408992000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1531408992000},{"_id":"themes/icarus/layout/share/default.ejs","hash":"bddd4425db187d893a5599d69810fa4159d0c45e","modified":1531408992000},{"_id":"themes/icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1531408992000},{"_id":"themes/icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1531408992000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1531408992000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1531408992000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1531408992000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"e7942ff12fe2220dd2667216886a71e4f6432bdc","modified":1538122406201},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1531408992000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1531408992000},{"_id":"themes/icarus/source/css/_extend.styl","hash":"539e02107f35e8b3bdb9bf160dc212a433a7b60e","modified":1531408992000},{"_id":"themes/icarus/source/css/_variables.styl","hash":"72cc7b96563d80bb924e615913095f07ea8339b9","modified":1538019030248},{"_id":"themes/icarus/source/css/style.styl","hash":"08161c66aa6babf2d00a996ad2ea41eecf749e47","modified":1543891627564},{"_id":"themes/icarus/source/js/Valine.min.js","hash":"15cb71314ed92194e1137305b87aa9e122494c72","modified":1538299082941},{"_id":"themes/icarus/source/js/insight.js","hash":"f507ab7b2236349719f1af2c918f2f5c22d410c2","modified":1531408992000},{"_id":"themes/icarus/source/js/main.js","hash":"c2e44fd9efefae0ba5918be9b9ea82e9cbcdf8d2","modified":1543912308110},{"_id":"source/_posts/hexo-创建文章/lujing.jpg","hash":"e08d55018e7afef50bd664085f701c7732933a01","modified":1538129531550},{"_id":"source/_posts/jenkins部署个人博客/jenkins-1.jpg","hash":"3e63429bb98dd989f6a6221a4afc0b73a453338f","modified":1544263969465},{"_id":"source/_posts/hexo-创建文章/banner.jpg","hash":"9299f035bf4bdb1c77ca7f74dad3919c473d6b1c","modified":1538127775207},{"_id":"source/_posts/hexo-创建文章/suoluetu.png","hash":"2f244d1faccdca8ed2661cecf7b0ca08799c2156","modified":1538127381617},{"_id":"source/_posts/js构造函数/slt.jpg","hash":"c8e9271a488c7eef94de87c6b90f9f17bdcdbf80","modified":1539076620628},{"_id":"themes/icarus/layout/common/post/category.ejs","hash":"9977603db05db02a55996e1ab3620d682a3c87b2","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/date.ejs","hash":"7817a75f3b8933ccf6366c1fdbce1e19912b0b35","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/tag.ejs","hash":"d3f5a2a17b1235135c7d1f2f9bc5878ef7687e8c","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/index.styl","hash":"5ea847a03ff704ab7f4752518367115ca3862890","modified":1538987384012},{"_id":"themes/icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/archive.styl","hash":"7417c254aae2b1b2132b3fb9f9efa4b32c09dd8d","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/article.styl","hash":"60d5a86798010e45d8f70f49b00af2beebb64067","modified":1538967322596},{"_id":"themes/icarus/source/css/_partial/comment.styl","hash":"1330bc399de3c5f41dd894cc33d0006be0309271","modified":1538300380251},{"_id":"themes/icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/header.styl","hash":"1db9d1ca6402a9ad2767d2c4fe26fed4c835b1d0","modified":1538193222252},{"_id":"themes/icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/loadingbar.styl","hash":"0cfdaef9094b70b1b5227f92981393d961c3de6f","modified":1543909426273},{"_id":"themes/icarus/source/css/_partial/profile.styl","hash":"4cbc22ad02d88d4e0abcbbc192a2dccee0980215","modified":1538104402740},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","hash":"7aa8566ed33bd005ffed2659e3172d4936ca62fb","modified":1538122999671},{"_id":"themes/icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1531408992000},{"_id":"themes/icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1531408992000},{"_id":"themes/icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1531408992000},{"_id":"themes/icarus/source/css/images/_logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1531408992000},{"_id":"themes/icarus/source/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1531408992000},{"_id":"themes/icarus/source/css/images/favicon.ico","hash":"d2c1d45f1d1dc4919269b4b9dc15a5570ee6ac8c","modified":1538967714951},{"_id":"themes/icarus/source/css/images/logo.png","hash":"8edea620d152599bf9d07730d74a3f16058179da","modified":1538018365721},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1531408992000},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1531408992000},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1531408992000},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.css","hash":"3dc468f3a5d6dcbdb977b17c2c021f751c5bf7c6","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.min.css","hash":"ae33d7d508d9fb4d8cc026f74007fae27017fc80","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.css","hash":"5c960e4efb31a88b1319dcf63d4806175e3cb8cd","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.min.css","hash":"ac3cc27cd41d44ed5d680541636604d0c397e5f6","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.css","hash":"b818fea784ea93c6cc393d545bfc5e1ec2045ff7","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.min.css","hash":"8518d72f88b376749244da2bdc96f261d9bd5645","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff2","hash":"0ec12ea1707f5bc812b627f41cccad2aff01e54b","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff","hash":"7b4a63abc8476f745f09775d7465f0a6c33daf85","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff2","hash":"1ba4dd60af529d1a72d0e57467c3bc0bbb728a4d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1531408992000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1531408992000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.eot","hash":"d92c68223732a10ceffe54eecbe4ef70073e6dea","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff","hash":"8b5cac7fbf1712c81d9cac19cda04e6a604eb9da","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.ttf","hash":"9b4bb228d5b132e69ff8b6b248262449879eff3e","modified":1531408992000},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.eot","hash":"69aa0b829fd8562d0fb72948ce49ef201ff0ee83","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.ttf","hash":"31dc9b748b8d2bf6c3edec919e763791e037bbff","modified":1531408992000},{"_id":"themes/icarus/source/css/images/avatar.jpg","hash":"1047ff989dd0033e273f8e6f96c5c182edf0c600","modified":1538036792613},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.svg","hash":"24a7c19c323e91705be51641e87da7d5dfea5d10","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.svg","hash":"b07d27980b351d78f322260386450dde60d298cc","modified":1531408992000},{"_id":"source/_posts/jenkins部署个人博客/jenkins.png","hash":"a60340bfec0806d9df1aca8bff9d1850b7c5f319","modified":1544254464248},{"_id":"public/content.json","hash":"d6b2a61145e9378ffc590e7b5ffe1bb5326f2ccb","modified":1545397147027},{"_id":"public/about/index.html","hash":"f8b6944e4a62a98dd0be00621e4d095d52f171a9","modified":1545397147034},{"_id":"public/tags/index.html","hash":"86cb1c7a6b2fbf70a3e3c29a65f8585f8ebf0d4e","modified":1545397147034},{"_id":"public/categories/index.html","hash":"19a4ada695fa4e318c7fa5c23b45dc9e8e88c93a","modified":1545397147034},{"_id":"public/2018/12/17/GITduozhanghu/index.html","hash":"72e8127261f4b06b76f389dc0e2c943a44731a71","modified":1545397147034},{"_id":"public/2018/12/12/监听浏览器刷新及关闭/index.html","hash":"53789959ea774c4e218e95dbc43908fffc2d3bd3","modified":1545397147034},{"_id":"public/2018/12/08/jenkins部署个人博客/index.html","hash":"031b20f52bfb9a593031b1d975626d41f63e629b","modified":1545397147034},{"_id":"public/2018/11/29/HTTP状态码和AJAX状态值/index.html","hash":"e97ab797d9e1fa341d6ca967b3b2241716d03825","modified":1545397147034},{"_id":"public/2018/10/10/async/index.html","hash":"1a2206054163942590fd57b55da4f4c76c8f7701","modified":1545397147034},{"_id":"public/2018/10/10/Generator/index.html","hash":"bee493dd1029b7a5c83787c06d0d88b685104c38","modified":1545397147034},{"_id":"public/2018/10/09/js构造函数/index.html","hash":"ac4ea693de022211d6f4609537cad1a16468cb2e","modified":1545397147035},{"_id":"public/2018/10/09/Promise/index.html","hash":"ef3dadd7aea30d371d44edff2f0f4799641dcf04","modified":1545397147035},{"_id":"public/2018/09/29/RISE/index.html","hash":"6ba13442b06843d5c47b42e71f4257a98b2f8c6c","modified":1545397147035},{"_id":"public/2018/04/08/递归尾调用优化/index.html","hash":"d63d7f450c96d7f936b4f46b5e91bbc2945c8646","modified":1545397147035},{"_id":"public/2018/04/08/递归树结构解析/index.html","hash":"4324deeda2a73734fce6ba84f3ed3643143a2923","modified":1545397147035},{"_id":"public/2018/03/20/给Hexo博客添加访问统计/index.html","hash":"413f1fc49d715dbf0a82cabbf7d2b4588eac4c8f","modified":1545397147035},{"_id":"public/2018/02/27/hexo-创建文章/index.html","hash":"cd3063f1ce067a43260680e90395924f1acb5054","modified":1545397147035},{"_id":"public/2018/02/05/hexo常用指令/index.html","hash":"901d9e59d48d812cae3e738bd4d6a323ef05c5de","modified":1545397147035},{"_id":"public/archives/index.html","hash":"dc4a71f895549763008e63d8af17d26e2b75a585","modified":1545397147035},{"_id":"public/archives/page/2/index.html","hash":"cc35c784ac8fd0e276df15c8ae0b9991f06a890b","modified":1545397147035},{"_id":"public/archives/2018/index.html","hash":"58b80d2644273bd029539d35fd72a434d2667ad8","modified":1545397147035},{"_id":"public/archives/2018/page/2/index.html","hash":"d50a47e762e1e8584aa1010c67a46fc316260d82","modified":1545397147035},{"_id":"public/archives/2018/02/index.html","hash":"55eabbccd5cee56c49d494215bbd69d3c83a9724","modified":1545397147036},{"_id":"public/archives/2018/03/index.html","hash":"5d1d27b0fd1dc3f38e84fca8211f9f1e294d8d69","modified":1545397147036},{"_id":"public/archives/2018/04/index.html","hash":"4b8a1edb42d9fd6283ec084260964a414afb0511","modified":1545397147036},{"_id":"public/archives/2018/09/index.html","hash":"a3b2dd5327a2b0f059176ccf4ebaad5af158127c","modified":1545397147037},{"_id":"public/archives/2018/10/index.html","hash":"adc72954740e620f5520ce95506d9581525af3a0","modified":1545397147037},{"_id":"public/archives/2018/11/index.html","hash":"32b3862751c780018763ac5b85eebe8d4125fedd","modified":1545397147037},{"_id":"public/archives/2018/12/index.html","hash":"a5b17d62fc03f1a54eabebae5a9d200535b770ca","modified":1545397147038},{"_id":"public/index.html","hash":"b4c595a5ab9b5ed216ceb2c2d03167c27691a7a6","modified":1545397147038},{"_id":"public/page/2/index.html","hash":"c8b4a75d57c616b23e6d7dba1b565ee9e5ac2421","modified":1545397147038},{"_id":"public/categories/随笔/index.html","hash":"c55ba6e25ce4850120c757c3117229618cfcbf5c","modified":1545397147038},{"_id":"public/categories/笔记/index.html","hash":"b97d7b814d558f8f95ba3b1a6e51ae9c12f37637","modified":1545397147038},{"_id":"public/categories/娱乐/index.html","hash":"ff07485be039d09eba8621d0d08692fc3d03067c","modified":1545397147038},{"_id":"public/categories/工具/index.html","hash":"be792ad907b319a16f62354c33c3cb65ab7a139d","modified":1545397147038},{"_id":"public/tags/git/index.html","hash":"feceb6dafd5f68d1d4029fd5a58e5f42c9b48475","modified":1545397147038},{"_id":"public/tags/js/index.html","hash":"6c6fd8df5a81e70ca2a5d6aabe79f9db1b60f59e","modified":1545397147038},{"_id":"public/tags/前端/index.html","hash":"21af5e726c1ec941dde1aa3b64e5b6be0734b71b","modified":1545397147038},{"_id":"public/tags/ES6/index.html","hash":"7516aac511ea38e75639ca9f54c1a25a81acb802","modified":1545397147039},{"_id":"public/tags/LOL/index.html","hash":"0af41c024af4e11bbda3dc94e35acf993b4524cb","modified":1545397147039},{"_id":"public/tags/hexo/index.html","hash":"0c01086fd9abd38008f830d53bddfe2e754f7da5","modified":1545397147039},{"_id":"public/tags/video/index.html","hash":"c9ee6f1c8987e2d31804c01125b2b8c24c7d1c26","modified":1545397147039},{"_id":"public/tags/markdown/index.html","hash":"c0f9ef0ecdffbb276b29cf15d626f97be85416b5","modified":1545397147039},{"_id":"public/tags/部署/index.html","hash":"b986028c4f7423c645acf5e531bc09264c7fb415","modified":1545397147039},{"_id":"public/tags/jenkins/index.html","hash":"ac157d9b75b919f22ccaf06a151b354e1ae21f8a","modified":1545397147039},{"_id":"public/tags/算法/index.html","hash":"85f3f44ff9ef45519d9ced2e94ec45820ed0f97b","modified":1545397147039},{"_id":"public/../assets/css/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1545397147045},{"_id":"public/css/images/logo.png","hash":"8edea620d152599bf9d07730d74a3f16058179da","modified":1545397147045},{"_id":"public/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1545397147045},{"_id":"public/css/images/favicon.ico","hash":"d2c1d45f1d1dc4919269b4b9dc15a5570ee6ac8c","modified":1545397147046},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1545397147046},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.woff2","hash":"0ec12ea1707f5bc812b627f41cccad2aff01e54b","modified":1545397147046},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.woff2","hash":"1ba4dd60af529d1a72d0e57467c3bc0bbb728a4d","modified":1545397147046},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1545397147046},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.woff","hash":"7b4a63abc8476f745f09775d7465f0a6c33daf85","modified":1545397147046},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1545397147046},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1545397147046},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1545397147047},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1545397147047},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1545397147047},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1545397147047},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1545397147047},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1545397147047},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1545397147047},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1545397147047},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1545397147048},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1545397147048},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1545397147048},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1545397147048},{"_id":"public/2018/12/17/GITduozhanghu/git_1.jpg","hash":"1a4677b233f5d28c5ebddea71e9206d83f7cabd2","modified":1545397147048},{"_id":"public/2018/11/29/HTTP状态码和AJAX状态值/http.jpg","hash":"e45575b0948d0318aea31c720b0def3ffc493a06","modified":1545397147048},{"_id":"public/2018/09/29/RISE/banner.jpg","hash":"046ae6a9ddf3c7c60a04271c44e9df49813301d0","modified":1545397147048},{"_id":"public/2018/10/09/js构造函数/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1545397147048},{"_id":"public/2018/03/20/给Hexo博客添加访问统计/bsz.jpg","hash":"bf72ba6bbc89d3979c9e83ebaf90a2f0673de6e2","modified":1545397147048},{"_id":"public/2018/03/20/给Hexo博客添加访问统计/timg.jpg","hash":"48008426aebff3897fb41aa4319b0dc6637778ed","modified":1545397147049},{"_id":"public/2018/04/08/递归树结构解析/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1545397147049},{"_id":"public/2018/04/08/递归树结构解析/result.jpg","hash":"d3cc67d6e6db5ab158ddcd335be3b354f2b36a56","modified":1545397147049},{"_id":"public/2018/02/27/hexo-创建文章/lujing2.jpg","hash":"a390f5b69d7f608004d42bc55182e503bb64f7ff","modified":1545397147049},{"_id":"public/2018/02/27/hexo-创建文章/wenjian.jpg","hash":"1d46842690b5f85273dc39bfebd5157707b982a8","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jdk-1.png","hash":"c4794d65d2221d0b0acb902bd8a3ee8ef3a943b2","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jdk-2.png","hash":"41147b4369f5d51a048889ea3bf04e25d26972ef","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jdk-3.png","hash":"d81767c7569127f424a281564d29ca36f227d66b","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jdk.png","hash":"da437cacb97df8961417d0a27390cbaa3ec29023","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jenkins-2.jpg","hash":"222c15fda1be771c533f5ef3d122fa618c1c67c4","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jenkins-3.jpg","hash":"1ed088b051c6e36f2f94a85c67faf4b71919c8eb","modified":1545397147049},{"_id":"public/2018/12/08/jenkins部署个人博客/jenkins-4.jpg","hash":"ee41e108b2a9989795f1e8be46ff3acfacc80992","modified":1545397147049},{"_id":"public/../assets/js/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1545397147578},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.eot","hash":"d92c68223732a10ceffe54eecbe4ef70073e6dea","modified":1545397147578},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.woff","hash":"8b5cac7fbf1712c81d9cac19cda04e6a604eb9da","modified":1545397147578},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.ttf","hash":"9b4bb228d5b132e69ff8b6b248262449879eff3e","modified":1545397147578},{"_id":"public/2018/02/27/hexo-创建文章/lujing.jpg","hash":"e08d55018e7afef50bd664085f701c7732933a01","modified":1545397147578},{"_id":"public/2018/12/08/jenkins部署个人博客/jenkins-1.jpg","hash":"3e63429bb98dd989f6a6221a4afc0b73a453338f","modified":1545397147578},{"_id":"public/js/insight.js","hash":"f507ab7b2236349719f1af2c918f2f5c22d410c2","modified":1545397147618},{"_id":"public/js/main.js","hash":"c2e44fd9efefae0ba5918be9b9ea82e9cbcdf8d2","modified":1545397147618},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1545397147618},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1545397147618},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1545397147618},{"_id":"public/libs/font-awesome5/css/fa-brands.css","hash":"3dc468f3a5d6dcbdb977b17c2c021f751c5bf7c6","modified":1545397147618},{"_id":"public/libs/font-awesome5/css/fa-brands.min.css","hash":"ae33d7d508d9fb4d8cc026f74007fae27017fc80","modified":1545397147618},{"_id":"public/libs/font-awesome5/css/fa-solid.min.css","hash":"ac3cc27cd41d44ed5d680541636604d0c397e5f6","modified":1545397147618},{"_id":"public/libs/font-awesome5/css/fa-solid.css","hash":"5c960e4efb31a88b1319dcf63d4806175e3cb8cd","modified":1545397147618},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1545397147618},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1545397147618},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1545397147618},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1545397147619},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1545397147619},{"_id":"public/css/style.css","hash":"dad4ca00120f98914697d05aca7d905e1efbadba","modified":1545397147619},{"_id":"public/js/Valine.min.js","hash":"8e71573bc334c2d74654a68bdfb421e68e2b45da","modified":1545397147619},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1545397147619},{"_id":"public/libs/font-awesome5/css/fontawesome.css","hash":"b818fea784ea93c6cc393d545bfc5e1ec2045ff7","modified":1545397147619},{"_id":"public/libs/font-awesome5/css/fontawesome.min.css","hash":"8518d72f88b376749244da2bdc96f261d9bd5645","modified":1545397147619},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1545397147619},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1545397147619},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1545397147620},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1545397147620},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1545397147620},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1545397147620},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1545397147620},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1545397147620},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545397147620},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.eot","hash":"69aa0b829fd8562d0fb72948ce49ef201ff0ee83","modified":1545397147620},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.ttf","hash":"31dc9b748b8d2bf6c3edec919e763791e037bbff","modified":1545397147620},{"_id":"public/2018/10/09/js构造函数/slt.jpg","hash":"c8e9271a488c7eef94de87c6b90f9f17bdcdbf80","modified":1545397147620},{"_id":"public/2018/02/27/hexo-创建文章/banner.jpg","hash":"9299f035bf4bdb1c77ca7f74dad3919c473d6b1c","modified":1545397147620},{"_id":"public/2018/02/27/hexo-创建文章/suoluetu.png","hash":"2f244d1faccdca8ed2661cecf7b0ca08799c2156","modified":1545397147620},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.svg","hash":"24a7c19c323e91705be51641e87da7d5dfea5d10","modified":1545397147642},{"_id":"public/css/images/avatar.jpg","hash":"1047ff989dd0033e273f8e6f96c5c182edf0c600","modified":1545397147671},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.svg","hash":"b07d27980b351d78f322260386450dde60d298cc","modified":1545397147671},{"_id":"public/2018/12/08/jenkins部署个人博客/jenkins.png","hash":"a60340bfec0806d9df1aca8bff9d1850b7c5f319","modified":1545397147800}],"Category":[{"name":"随笔","_id":"cjpy1k4rf000i30ujq3u53ogf"},{"name":"笔记","_id":"cjpy1k4ro000k30ujbigmwh5c"},{"name":"娱乐","_id":"cjpy1k4rv000q30ujt11sz97j"},{"name":"工具","_id":"cjpy1k4ry000u30ujbyob71e4"}],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html>\n<head>\n  <title></title>\n  <style type=\"text/css\">\n    .about {\n      box-sizing: border-box;\n      padding-top: 20px;\n    }\n    .about_head>.about_head_left {\n      display: inline-block;\n      width: 200px;\n      padding: 10px;\n    }\n    .about_head>.about_head_right {\n      float: right;\n      display: inline-block;\n      width: 100%;\n      padding: 10px;\n      padding-left: 200px;\n    }\n    .about_head>.about_head_left>.about_head_left_img {\n      background-color: #0ff;\n      height: 300px;\n      box-shadow: 12px 12px 0px 0px rgba(0,0,0,0.1);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"about\">\n    <div class=\"about_head\">\n      <div class=\"about_head_left\">\n        <div class=\"about_head_left_img\"></div>\n      </div>\n      <div class=\"about_head_right\"></div>\n    </div>\n  </div>\n</body>\n<script type=\"text/javascript\">\n  function haha(){\n    alert('asdsfasf');\n  }\n</script>\n</html>","source":"about/index.html","raw":"<!DOCTYPE html>\n<html>\n<head>\n  <title></title>\n  <style type=\"text/css\">\n    .about {\n      box-sizing: border-box;\n      padding-top: 20px;\n    }\n    .about_head>.about_head_left {\n      display: inline-block;\n      width: 200px;\n      padding: 10px;\n    }\n    .about_head>.about_head_right {\n      float: right;\n      display: inline-block;\n      width: 100%;\n      padding: 10px;\n      padding-left: 200px;\n    }\n    .about_head>.about_head_left>.about_head_left_img {\n      background-color: #0ff;\n      height: 300px;\n      box-shadow: 12px 12px 0px 0px rgba(0,0,0,0.1);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"about\">\n    <div class=\"about_head\">\n      <div class=\"about_head_left\">\n        <div class=\"about_head_left_img\"></div>\n      </div>\n      <div class=\"about_head_right\"></div>\n    </div>\n  </div>\n</body>\n<script type=\"text/javascript\">\n  function haha(){\n    alert('asdsfasf');\n  }\n</script>\n</html>","date":"2018-12-04T02:05:32.151Z","updated":"2018-12-04T02:05:32.151Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cjpy1k4pe000030ujgnjc8bmu","content":"<!DOCTYPE html>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n  <title></title>\n  <style type=\"text/css\">\n    .about {\n      box-sizing: border-box;\n      padding-top: 20px;\n    }\n    .about_head>.about_head_left {\n      display: inline-block;\n      width: 200px;\n      padding: 10px;\n    }\n    .about_head>.about_head_right {\n      float: right;\n      display: inline-block;\n      width: 100%;\n      padding: 10px;\n      padding-left: 200px;\n    }\n    .about_head>.about_head_left>.about_head_left_img {\n      background-color: #0ff;\n      height: 300px;\n      box-shadow: 12px 12px 0px 0px rgba(0,0,0,0.1);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"about\">\n    <div class=\"about_head\">\n      <div class=\"about_head_left\">\n        <div class=\"about_head_left_img\"></div>\n      </div>\n      <div class=\"about_head_right\"></div>\n    </div>\n  </div>\n</body>\n<script type=\"text/javascript\">\n  function haha(){\n    alert('asdsfasf');\n  }\n</script>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n  <title></title>\n  <style type=\"text/css\">\n    .about {\n      box-sizing: border-box;\n      padding-top: 20px;\n    }\n    .about_head>.about_head_left {\n      display: inline-block;\n      width: 200px;\n      padding: 10px;\n    }\n    .about_head>.about_head_right {\n      float: right;\n      display: inline-block;\n      width: 100%;\n      padding: 10px;\n      padding-left: 200px;\n    }\n    .about_head>.about_head_left>.about_head_left_img {\n      background-color: #0ff;\n      height: 300px;\n      box-shadow: 12px 12px 0px 0px rgba(0,0,0,0.1);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"about\">\n    <div class=\"about_head\">\n      <div class=\"about_head_left\">\n        <div class=\"about_head_left_img\"></div>\n      </div>\n      <div class=\"about_head_right\"></div>\n    </div>\n  </div>\n</body>\n<script type=\"text/javascript\">\n  function haha(){\n    alert('asdsfasf');\n  }\n</script>\n</html>"},{"title":"About","date":"2018-09-26T10:22:02.000Z","_content":"\n<html>\n<head>\n\t<title></title>\n\t<style type=\"text/css\">\n\t.aa {\n\t\t\tcolor: #0f0;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div style=\"color: #f00\">adfafafd</div>\n\t<div class=\"aa\">asdfasdfasfdafd</div>\n</body>\n</html>\n\n## 友情链接\n\nECMAScript 6 入门： [http://es6.ruanyifeng.com/](http://es6.ruanyifeng.com/)\n杨某的博客： [https://angusyang9.github.io/](https://angusyang9.github.io/)\n刘某某的博客： [https://provenr.github.io/](https://provenr.github.io/)\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2018-09-26 18:22:02\n---\n\n<html>\n<head>\n\t<title></title>\n\t<style type=\"text/css\">\n\t.aa {\n\t\t\tcolor: #0f0;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div style=\"color: #f00\">adfafafd</div>\n\t<div class=\"aa\">asdfasdfasfdafd</div>\n</body>\n</html>\n\n## 友情链接\n\nECMAScript 6 入门： [http://es6.ruanyifeng.com/](http://es6.ruanyifeng.com/)\n杨某的博客： [https://angusyang9.github.io/](https://angusyang9.github.io/)\n刘某某的博客： [https://provenr.github.io/](https://provenr.github.io/)\n","updated":"2018-12-03T02:27:15.561Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjpy1k4pj000230uja0483v4c","content":"<html><br><head><meta name=\"generator\" content=\"Hexo 3.8.0\"><br>    <title></title><br>    <style type=\"text/css\"><br>    .aa {<br>            color: #0f0;<br>        }<br>    </style><br></head><br><body><br>    <div style=\"color: #f00\">adfafafd</div><br>    <div class=\"aa\">asdfasdfasfdafd</div><br></body><br></html>\n\n<h2 id=\"友情链接\"><a href=\"#友情链接\" class=\"headerlink\" title=\"友情链接\"></a>友情链接</h2><p>ECMAScript 6 入门： <a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a><br>杨某的博客： <a href=\"https://angusyang9.github.io/\" target=\"_blank\" rel=\"noopener\">https://angusyang9.github.io/</a><br>刘某某的博客： <a href=\"https://provenr.github.io/\" target=\"_blank\" rel=\"noopener\">https://provenr.github.io/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<html><br><head><meta name=\"generator\" content=\"Hexo 3.8.0\"><br>    <title></title><br>    <style type=\"text/css\"><br>    .aa {<br>            color: #0f0;<br>        }<br>    </style><br></head><br><body><br>    <div style=\"color: #f00\">adfafafd</div><br>    <div class=\"aa\">asdfasdfasfdafd</div><br></body><br></html>\n\n<h2 id=\"友情链接\"><a href=\"#友情链接\" class=\"headerlink\" title=\"友情链接\"></a>友情链接</h2><p>ECMAScript 6 入门： <a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a><br>杨某的博客： <a href=\"https://angusyang9.github.io/\" target=\"_blank\" rel=\"noopener\">https://angusyang9.github.io/</a><br>刘某某的博客： <a href=\"https://provenr.github.io/\" target=\"_blank\" rel=\"noopener\">https://provenr.github.io/</a></p>\n"},{"title":"标签","date":"2018-09-27T06:31:12.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-09-27 14:31:12\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2018-09-27T10:01:14.759Z","path":"tags/index.html","comments":1,"_id":"cjpy1k4pl000430ujfyr1efe1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2018-09-27T06:23:33.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-09-27 14:23:33\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2018-09-27T10:00:27.766Z","path":"categories/index.html","comments":1,"_id":"cjpy1k4pn000630ujvvh75sdi","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"GIT配置多账户","date":"2018-12-17T01:41:00.000Z","comments":1,"toc":true,"banner":"/bolg/2018/12/17/GITduozhanghu/git_1.jpg","_content":"\n>如今git作为当下最火的版本控制工具，基本开发人员都会有多个git账户，如gitlab，github及码云等都是基于git。那么如何在同一台设备上管理多个git账户呢？一种是不做ssh的配置，此时每次push操作都要输入用户名密码，还有一种则是配置ssh-key，本文介绍如何在window系统下托管多个ssk-key来管理git账号。\n\n<!--more-->\n\n### 生成ssh私钥公钥\n\n执行如下命令\nsadf\nsadf\nasdf\nasdf\nasd\n``` js\nssh-keygen -t rsa -C email\n```\n如下图所示，根据你的email生成ssh并根据需要键入key名（最好是有含义的域名，如我的这个key用于github，则命名为id_res_github）\n\nqq\n\n{% asset_img git_1.jpg GITduozhanghu %}\n\nqqqq\n\n![文章banner](git_1.jpg)\n\n\naaaa\n\n\n### adsfasdf\n","source":"_posts/GITduozhanghu.md","raw":"---\ntitle: GIT配置多账户\ndate: 2018-12-17 09:41:00\ncomments: true\ntoc: true\nbanner: /bolg/2018/12/17/GITduozhanghu/git_1.jpg\ncategories: '随笔'\ntags:\n\t- git\n---\n\n>如今git作为当下最火的版本控制工具，基本开发人员都会有多个git账户，如gitlab，github及码云等都是基于git。那么如何在同一台设备上管理多个git账户呢？一种是不做ssh的配置，此时每次push操作都要输入用户名密码，还有一种则是配置ssh-key，本文介绍如何在window系统下托管多个ssk-key来管理git账号。\n\n<!--more-->\n\n### 生成ssh私钥公钥\n\n执行如下命令\nsadf\nsadf\nasdf\nasdf\nasd\n``` js\nssh-keygen -t rsa -C email\n```\n如下图所示，根据你的email生成ssh并根据需要键入key名（最好是有含义的域名，如我的这个key用于github，则命名为id_res_github）\n\nqq\n\n{% asset_img git_1.jpg GITduozhanghu %}\n\nqqqq\n\n![文章banner](git_1.jpg)\n\n\naaaa\n\n\n### adsfasdf\n","slug":"GITduozhanghu","published":1,"updated":"2018-12-21T12:18:39.445Z","layout":"post","photos":[],"link":"","_id":"cjpy1k4pf000130uj0w32y5gp","content":"<blockquote>\n<p>如今git作为当下最火的版本控制工具，基本开发人员都会有多个git账户，如gitlab，github及码云等都是基于git。那么如何在同一台设备上管理多个git账户呢？一种是不做ssh的配置，此时每次push操作都要输入用户名密码，还有一种则是配置ssh-key，本文介绍如何在window系统下托管多个ssk-key来管理git账号。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"生成ssh私钥公钥\"><a href=\"#生成ssh私钥公钥\" class=\"headerlink\" title=\"生成ssh私钥公钥\"></a>生成ssh私钥公钥</h3><p>执行如下命令<br>sadf<br>sadf<br>asdf<br>asdf<br>asd<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C email</span><br></pre></td></tr></table></figure></p>\n<p>如下图所示，根据你的email生成ssh并根据需要键入key名（最好是有含义的域名，如我的这个key用于github，则命名为id_res_github）</p>\n<p>qq</p>\n<img src=\"/blog/2018/12/17/GITduozhanghu/blog/2018/12/17/GITduozhanghu/git_1.jpg\" title=\"GITduozhanghu\">\n<p>qqqq</p>\n<p><img src=\"/blog/2018/12/17/GITduozhanghu/git_1.jpg\" alt=\"文章banner\"></p>\n<p>aaaa</p>\n<h3 id=\"adsfasdf\"><a href=\"#adsfasdf\" class=\"headerlink\" title=\"adsfasdf\"></a>adsfasdf</h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>如今git作为当下最火的版本控制工具，基本开发人员都会有多个git账户，如gitlab，github及码云等都是基于git。那么如何在同一台设备上管理多个git账户呢？一种是不做ssh的配置，此时每次push操作都要输入用户名密码，还有一种则是配置ssh-key，本文介绍如何在window系统下托管多个ssk-key来管理git账号。</p>\n</blockquote>","more":"<h3 id=\"生成ssh私钥公钥\"><a href=\"#生成ssh私钥公钥\" class=\"headerlink\" title=\"生成ssh私钥公钥\"></a>生成ssh私钥公钥</h3><p>执行如下命令<br>sadf<br>sadf<br>asdf<br>asdf<br>asd<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C email</span><br></pre></td></tr></table></figure></p>\n<p>如下图所示，根据你的email生成ssh并根据需要键入key名（最好是有含义的域名，如我的这个key用于github，则命名为id_res_github）</p>\n<p>qq</p>\n<img src=\"/blog/2018/12/17/GITduozhanghu/blog/2018/12/17/GITduozhanghu/git_1.jpg\" title=\"GITduozhanghu\">\n<p>qqqq</p>\n<p><img src=\"/blog/2018/12/17/GITduozhanghu/git_1.jpg\" alt=\"文章banner\"></p>\n<p>aaaa</p>\n<h3 id=\"adsfasdf\"><a href=\"#adsfasdf\" class=\"headerlink\" title=\"adsfasdf\"></a>adsfasdf</h3>"},{"title":"HTTP状态码和AJAX状态值hexo44","date":"2018-11-29T07:01:52.000Z","toc":true,"thumbnail":"/bolg/2018/11/29/HTTP状态码和AJAX状态值/http.jpg","_content":"\n>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。\n\n<!-- more -->\n\n## HTTP 超文本传输协议\n\n>HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。\n>&nbsp;\n>一个HTTP \"客户端\"是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。\n>一个HTTP \"服务器\"同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。\n>&nbsp;\n>HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。\n>HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。\n>&nbsp;  \n>HTTP1.0 定义了三种请求方法： `GET`, `POST` 和 `HEAD`方法。\n>HTTP1.1 新增了五种请求方法： `OPTIONS`, `PUT`, `DELETE`, `TRACE` 和 `CONNECT` 方法。\n\n---\n\n## HTTP 请求方式\n\n>|             请求方式            |                                                               请求中文说明                                                              |\n|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|\n| GET                             | 请求指定的页面信息，并返回实体主体。                                                                                                    |\n| HEAD                            | 类似于`get`请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                           |\n| POST                            | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。`POST`请求可能会导致新的资源的建立和/或已有资源的修改。 |\n| PUT                             | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                        |\n| DELETE                          | 请求服务器删除指定的页面。                                                                                                              |\n| CONNECT&nbsp;&nbsp;&nbsp;&nbsp; | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |\n| OPTIONS                         | 允许客户端查看服务器的性能。                                                                                                            |\n| TRACE                           | 回显服务器收到的请求，主要用于测试或诊断。                                                                                              |\n\n---\n\n## AJAX 状态值 与 HTTP状态码\n\n### AJAX状态值与状态码区别\n\n>AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用`ajax.readyState`获得。\n\n>AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用`ajax.status`所获得。\n\n这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。\n``` js\nif( ajax.readyState == 4 && ajax.status == 200 ) {\n\t// do success\n}\n```\n\n### AJAX状态值\n\n>在《Pragmatic Ajax A Web 2.0 Primer 》\n>&nbsp;\n>>0: (Uninitialized) the send( ) method has not yet been invoked. \n>>1: (Loading) the send( ) method has been invoked, request in progress. \n>>2: (Loaded) the send( ) method has completed, entire response received.\n>>3: (Interactive) the response is being parsed. \n>>4: (Completed) the response has been parsed, is ready for harvesting.\n>&nbsp;\n>>0 － （未初始化）还没有调用`send()`方法\n>>1 － （载入）已调用`send()`方法，正在发送请求\n>>2 － （载入完成）`send()`方法执行完成，已经接收到全部响应内容\n>>3 － （交互）正在解析响应内容\n>>4 － （完成）响应内容解析完成，可以在客户端调用了\n\n### HTTP 状态码\n\n>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。\nHTTP状态码的英文为HTTP Status Code。\n\n>下面是常见的HTTP状态码：\n>\n>| 码值 |                描述               |\n|------|-----------------------------------|\n|  200 | 请求成功                          |\n|  301 | 资源（网页等）被永久转移到其它URL |\n|  404 | 请求的资源（网页等）不存在        |\n|  500 | 内部服务器错误                    |\n\n#### HTTP状态码分类\n\n>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n>\n>| 分类 |                      描述                      |\n|------|------------------------------------------------|\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\n---\n\n#### HTTP状态码列表\n\n>HTTP状态码列表:\n>\n>|          码值         |             英文名称            |                                                                             中文描述                                                                             |\n|-----------------------|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            | 继续。客户端应继续其请求                                                                                                                                         |\n| 101                   | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议                                                                   |\n|                       |                                 |                                                                                                                                                                  |\n| 200                   | OK                              | 请求成功。一般用于GET与POST请求                                                                                                                                  |\n| 201                   | Created                         | 已创建。成功请求并创建了新的资源                                                                                                                                 |\n| 202                   | Accepted                        | 已接受。已经接受请求，但未处理完成                                                                                                                               |\n| 203                   | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本                                                                                             |\n| 204                   | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档                                                                         |\n| 205                   | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域                                                               |\n| 206                   | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                                                                                                                            |\n|                       |                                 |                                                                                                                                                                  |\n| 300                   | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择                                                           |\n| 301                   | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替                                   |\n| 302                   | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI                                                                                               |\n| 303                   | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看                                                                                                                   |\n| 304                   | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305                   | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                                                                                                                           |\n| 306                   | Unused                          | 已经被废弃的HTTP状态码                                                                                                                                           |\n| 307                   | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                                                                                                                         |\n|                       |                                 |                                                                                                                                                                  |\n| 400                   | Bad Request                     | 客户端请求的语法错误，服务器无法理解                                                                                                                             |\n| 401                   | Unauthorized                    | 请求要求用户的身份认证                                                                                                                                           |\n| 402                   | Payment Required                | 保留，将来使用                                                                                                                                                   |\n| 403                   | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求                                                                                                                   |\n| 404                   | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面                                                     |\n| 405                   | Method Not Allowed              | 客户端请求中的方法被禁止                                                                                                                                         |\n| 406                   | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                                                                                                                       |\n| 407                   | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权                                                                                                  |\n| 408                   | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                                                                                                                         |\n| 409                   | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突                                                                                            |\n| 410                   | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置                                 |\n| 411                   | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息                                                                                                           |\n| 412                   | Precondition Failed             | 客户端请求信息的先决条件错误                                                                                                                                     |\n| 413                   | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息    |\n| 414                   | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理                                                                                                                   |\n| 415                   | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                                                                                                                                 |\n| 416                   | Requested range not satisfiable | 客户端请求的范围无效                                                                                                                                             |\n| 417                   | Expectation Failed              | 服务器无法满足Expect的请求头信息                                                                                                                                 |\n|                       |                                 |                                                                                                                                                                  |\n| 500                   | Internal Server Error           | 服务器内部错误，无法完成请求                                                                                                                                     |\n| 501                   | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                                                                                                                             |\n| 502                   | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应                                                                                   |\n| 503                   | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中                                                              |\n| 504                   | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求                                                                                                               |\n| 505                   | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理                                                                                                                   |\n","source":"_posts/HTTP状态码和AJAX状态值.md","raw":"---\ntitle: HTTP状态码和AJAX状态值hexo44\ndate: 2018-11-29 15:01:52\ntoc: true\nthumbnail: /bolg/2018/11/29/HTTP状态码和AJAX状态值/http.jpg\ncategories: '笔记'\ntags: \n\t- js\n\t- 前端\n---\n\n>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。\n\n<!-- more -->\n\n## HTTP 超文本传输协议\n\n>HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。\n>&nbsp;\n>一个HTTP \"客户端\"是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。\n>一个HTTP \"服务器\"同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。\n>&nbsp;\n>HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。\n>HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。\n>&nbsp;  \n>HTTP1.0 定义了三种请求方法： `GET`, `POST` 和 `HEAD`方法。\n>HTTP1.1 新增了五种请求方法： `OPTIONS`, `PUT`, `DELETE`, `TRACE` 和 `CONNECT` 方法。\n\n---\n\n## HTTP 请求方式\n\n>|             请求方式            |                                                               请求中文说明                                                              |\n|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|\n| GET                             | 请求指定的页面信息，并返回实体主体。                                                                                                    |\n| HEAD                            | 类似于`get`请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                           |\n| POST                            | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。`POST`请求可能会导致新的资源的建立和/或已有资源的修改。 |\n| PUT                             | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                        |\n| DELETE                          | 请求服务器删除指定的页面。                                                                                                              |\n| CONNECT&nbsp;&nbsp;&nbsp;&nbsp; | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |\n| OPTIONS                         | 允许客户端查看服务器的性能。                                                                                                            |\n| TRACE                           | 回显服务器收到的请求，主要用于测试或诊断。                                                                                              |\n\n---\n\n## AJAX 状态值 与 HTTP状态码\n\n### AJAX状态值与状态码区别\n\n>AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用`ajax.readyState`获得。\n\n>AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用`ajax.status`所获得。\n\n这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。\n``` js\nif( ajax.readyState == 4 && ajax.status == 200 ) {\n\t// do success\n}\n```\n\n### AJAX状态值\n\n>在《Pragmatic Ajax A Web 2.0 Primer 》\n>&nbsp;\n>>0: (Uninitialized) the send( ) method has not yet been invoked. \n>>1: (Loading) the send( ) method has been invoked, request in progress. \n>>2: (Loaded) the send( ) method has completed, entire response received.\n>>3: (Interactive) the response is being parsed. \n>>4: (Completed) the response has been parsed, is ready for harvesting.\n>&nbsp;\n>>0 － （未初始化）还没有调用`send()`方法\n>>1 － （载入）已调用`send()`方法，正在发送请求\n>>2 － （载入完成）`send()`方法执行完成，已经接收到全部响应内容\n>>3 － （交互）正在解析响应内容\n>>4 － （完成）响应内容解析完成，可以在客户端调用了\n\n### HTTP 状态码\n\n>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。\nHTTP状态码的英文为HTTP Status Code。\n\n>下面是常见的HTTP状态码：\n>\n>| 码值 |                描述               |\n|------|-----------------------------------|\n|  200 | 请求成功                          |\n|  301 | 资源（网页等）被永久转移到其它URL |\n|  404 | 请求的资源（网页等）不存在        |\n|  500 | 内部服务器错误                    |\n\n#### HTTP状态码分类\n\n>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n>\n>| 分类 |                      描述                      |\n|------|------------------------------------------------|\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\n---\n\n#### HTTP状态码列表\n\n>HTTP状态码列表:\n>\n>|          码值         |             英文名称            |                                                                             中文描述                                                                             |\n|-----------------------|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            | 继续。客户端应继续其请求                                                                                                                                         |\n| 101                   | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议                                                                   |\n|                       |                                 |                                                                                                                                                                  |\n| 200                   | OK                              | 请求成功。一般用于GET与POST请求                                                                                                                                  |\n| 201                   | Created                         | 已创建。成功请求并创建了新的资源                                                                                                                                 |\n| 202                   | Accepted                        | 已接受。已经接受请求，但未处理完成                                                                                                                               |\n| 203                   | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本                                                                                             |\n| 204                   | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档                                                                         |\n| 205                   | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域                                                               |\n| 206                   | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                                                                                                                            |\n|                       |                                 |                                                                                                                                                                  |\n| 300                   | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择                                                           |\n| 301                   | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替                                   |\n| 302                   | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI                                                                                               |\n| 303                   | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看                                                                                                                   |\n| 304                   | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305                   | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                                                                                                                           |\n| 306                   | Unused                          | 已经被废弃的HTTP状态码                                                                                                                                           |\n| 307                   | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                                                                                                                         |\n|                       |                                 |                                                                                                                                                                  |\n| 400                   | Bad Request                     | 客户端请求的语法错误，服务器无法理解                                                                                                                             |\n| 401                   | Unauthorized                    | 请求要求用户的身份认证                                                                                                                                           |\n| 402                   | Payment Required                | 保留，将来使用                                                                                                                                                   |\n| 403                   | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求                                                                                                                   |\n| 404                   | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面                                                     |\n| 405                   | Method Not Allowed              | 客户端请求中的方法被禁止                                                                                                                                         |\n| 406                   | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                                                                                                                       |\n| 407                   | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权                                                                                                  |\n| 408                   | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                                                                                                                         |\n| 409                   | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突                                                                                            |\n| 410                   | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置                                 |\n| 411                   | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息                                                                                                           |\n| 412                   | Precondition Failed             | 客户端请求信息的先决条件错误                                                                                                                                     |\n| 413                   | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息    |\n| 414                   | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理                                                                                                                   |\n| 415                   | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                                                                                                                                 |\n| 416                   | Requested range not satisfiable | 客户端请求的范围无效                                                                                                                                             |\n| 417                   | Expectation Failed              | 服务器无法满足Expect的请求头信息                                                                                                                                 |\n|                       |                                 |                                                                                                                                                                  |\n| 500                   | Internal Server Error           | 服务器内部错误，无法完成请求                                                                                                                                     |\n| 501                   | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                                                                                                                             |\n| 502                   | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应                                                                                   |\n| 503                   | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中                                                              |\n| 504                   | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求                                                                                                               |\n| 505                   | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理                                                                                                                   |\n","slug":"HTTP状态码和AJAX状态值","published":1,"updated":"2018-12-08T06:13:57.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pk000330ujn6ugv6ls","content":"<blockquote>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"HTTP-超文本传输协议\"><a href=\"#HTTP-超文本传输协议\" class=\"headerlink\" title=\"HTTP 超文本传输协议\"></a>HTTP 超文本传输协议</h2><blockquote>\n<p>HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。<br>&nbsp;<br>一个HTTP “客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。<br>一个HTTP “服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。<br>&nbsp;<br>HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。<br>HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。<br>&nbsp;<br>HTTP1.0 定义了三种请求方法： <code>GET</code>, <code>POST</code> 和 <code>HEAD</code>方法。<br>HTTP1.1 新增了五种请求方法： <code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code> 方法。</p>\n</blockquote>\n<hr>\n<h2 id=\"HTTP-请求方式\"><a href=\"#HTTP-请求方式\" class=\"headerlink\" title=\"HTTP 请求方式\"></a>HTTP 请求方式</h2><blockquote>\n<table>\n<thead>\n<tr>\n<th>请求方式</th>\n<th>请求中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>类似于<code>get</code>请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code>请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>CONNECT&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<hr>\n<h2 id=\"AJAX-状态值-与-HTTP状态码\"><a href=\"#AJAX-状态值-与-HTTP状态码\" class=\"headerlink\" title=\"AJAX 状态值 与 HTTP状态码\"></a>AJAX 状态值 与 HTTP状态码</h2><h3 id=\"AJAX状态值与状态码区别\"><a href=\"#AJAX状态值与状态码区别\" class=\"headerlink\" title=\"AJAX状态值与状态码区别\"></a>AJAX状态值与状态码区别</h3><blockquote>\n<p>AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用<code>ajax.readyState</code>获得。</p>\n</blockquote>\n<blockquote>\n<p>AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用<code>ajax.status</code>所获得。</p>\n</blockquote>\n<p>这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( ajax.readyState == <span class=\"number\">4</span> &amp;&amp; ajax.status == <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do success</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AJAX状态值\"><a href=\"#AJAX状态值\" class=\"headerlink\" title=\"AJAX状态值\"></a>AJAX状态值</h3><blockquote>\n<p>在《Pragmatic Ajax A Web 2.0 Primer 》<br>&nbsp;</p>\n<blockquote>\n<p>0: (Uninitialized) the send( ) method has not yet been invoked.<br>1: (Loading) the send( ) method has been invoked, request in progress.<br>2: (Loaded) the send( ) method has completed, entire response received.<br>3: (Interactive) the response is being parsed.<br>4: (Completed) the response has been parsed, is ready for harvesting.<br>&nbsp;<br>0 － （未初始化）还没有调用<code>send()</code>方法<br>1 － （载入）已调用<code>send()</code>方法，正在发送请求<br>2 － （载入完成）<code>send()</code>方法执行完成，已经接收到全部响应内容<br>3 － （交互）正在解析响应内容<br>4 － （完成）响应内容解析完成，可以在客户端调用了</p>\n</blockquote>\n</blockquote>\n<h3 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h3><blockquote>\n<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>HTTP状态码的英文为HTTP Status Code。</p>\n</blockquote>\n<blockquote>\n<p>下面是常见的HTTP状态码：</p>\n<table>\n<thead>\n<tr>\n<th>码值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>301</td>\n<td>资源（网页等）被永久转移到其它URL</td>\n</tr>\n<tr>\n<td>404</td>\n<td>请求的资源（网页等）不存在</td>\n</tr>\n<tr>\n<td>500</td>\n<td>内部服务器错误</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h4 id=\"HTTP状态码分类\"><a href=\"#HTTP状态码分类\" class=\"headerlink\" title=\"HTTP状态码分类\"></a>HTTP状态码分类</h4><blockquote>\n<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1**</td>\n<td>信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td>2**</td>\n<td>成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td>3**</td>\n<td>重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td>4**</td>\n<td>客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td>5**</td>\n<td>服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<hr>\n<h4 id=\"HTTP状态码列表\"><a href=\"#HTTP状态码列表\" class=\"headerlink\" title=\"HTTP状态码列表\"></a>HTTP状态码列表</h4><blockquote>\n<p>HTTP状态码列表:</p>\n<table>\n<thead>\n<tr>\n<th>码值</th>\n<th>英文名称</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td>Continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td>继续。客户端应继续其请求</td>\n</tr>\n<tr>\n<td>101</td>\n<td>Switching Protocols</td>\n<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>请求成功。一般用于GET与POST请求</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>已创建。成功请求并创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>已接受。已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td>203</td>\n<td>Non-Authoritative Information</td>\n<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No Content</td>\n<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>\n</tr>\n<tr>\n<td>205</td>\n<td>Reset Content</td>\n<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>\n</tr>\n<tr>\n<td>206</td>\n<td>Partial Content</td>\n<td>部分内容。服务器成功处理了部分GET请求</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>300</td>\n<td>Multiple Choices</td>\n<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>\n</tr>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>查看其它地址。与301类似。使用GET和POST请求查看</td>\n</tr>\n<tr>\n<td>304</td>\n<td>Not Modified</td>\n<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>\n</tr>\n<tr>\n<td>305</td>\n<td>Use Proxy</td>\n<td>使用代理。所请求的资源必须通过代理访问</td>\n</tr>\n<tr>\n<td>306</td>\n<td>Unused</td>\n<td>已经被废弃的HTTP状态码</td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>临时重定向。与302类似。使用GET请求重定向</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>400</td>\n<td>Bad Request</td>\n<td>客户端请求的语法错误，服务器无法理解</td>\n</tr>\n<tr>\n<td>401</td>\n<td>Unauthorized</td>\n<td>请求要求用户的身份认证</td>\n</tr>\n<tr>\n<td>402</td>\n<td>Payment Required</td>\n<td>保留，将来使用</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>客户端请求中的方法被禁止</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>服务器无法根据客户端请求的内容特性完成请求</td>\n</tr>\n<tr>\n<td>407</td>\n<td>Proxy Authentication Required</td>\n<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Time-out</td>\n<td>服务器等待客户端发送的请求时间过长，超时</td>\n</tr>\n<tr>\n<td>409</td>\n<td>Conflict</td>\n<td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>\n</tr>\n<tr>\n<td>410</td>\n<td>Gone</td>\n<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>\n</tr>\n<tr>\n<td>411</td>\n<td>Length Required</td>\n<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>\n</tr>\n<tr>\n<td>412</td>\n<td>Precondition Failed</td>\n<td>客户端请求信息的先决条件错误</td>\n</tr>\n<tr>\n<td>413</td>\n<td>Request Entity Too Large</td>\n<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>\n</tr>\n<tr>\n<td>414</td>\n<td>Request-URI Too Large</td>\n<td>请求的URI过长（URI通常为网址），服务器无法处理</td>\n</tr>\n<tr>\n<td>415</td>\n<td>Unsupported Media Type</td>\n<td>服务器无法处理请求附带的媒体格式</td>\n</tr>\n<tr>\n<td>416</td>\n<td>Requested range not satisfiable</td>\n<td>客户端请求的范围无效</td>\n</tr>\n<tr>\n<td>417</td>\n<td>Expectation Failed</td>\n<td>服务器无法满足Expect的请求头信息</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器内部错误，无法完成请求</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>服务器不支持请求的功能，无法完成请求</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Time-out</td>\n<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version not supported</td>\n<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p>\n</blockquote>","more":"<h2 id=\"HTTP-超文本传输协议\"><a href=\"#HTTP-超文本传输协议\" class=\"headerlink\" title=\"HTTP 超文本传输协议\"></a>HTTP 超文本传输协议</h2><blockquote>\n<p>HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。<br>&nbsp;<br>一个HTTP “客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。<br>一个HTTP “服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。<br>&nbsp;<br>HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。<br>HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。<br>&nbsp;<br>HTTP1.0 定义了三种请求方法： <code>GET</code>, <code>POST</code> 和 <code>HEAD</code>方法。<br>HTTP1.1 新增了五种请求方法： <code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code> 方法。</p>\n</blockquote>\n<hr>\n<h2 id=\"HTTP-请求方式\"><a href=\"#HTTP-请求方式\" class=\"headerlink\" title=\"HTTP 请求方式\"></a>HTTP 请求方式</h2><blockquote>\n<table>\n<thead>\n<tr>\n<th>请求方式</th>\n<th>请求中文说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>类似于<code>get</code>请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code>请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>CONNECT&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<hr>\n<h2 id=\"AJAX-状态值-与-HTTP状态码\"><a href=\"#AJAX-状态值-与-HTTP状态码\" class=\"headerlink\" title=\"AJAX 状态值 与 HTTP状态码\"></a>AJAX 状态值 与 HTTP状态码</h2><h3 id=\"AJAX状态值与状态码区别\"><a href=\"#AJAX状态值与状态码区别\" class=\"headerlink\" title=\"AJAX状态值与状态码区别\"></a>AJAX状态值与状态码区别</h3><blockquote>\n<p>AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用<code>ajax.readyState</code>获得。</p>\n</blockquote>\n<blockquote>\n<p>AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用<code>ajax.status</code>所获得。</p>\n</blockquote>\n<p>这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( ajax.readyState == <span class=\"number\">4</span> &amp;&amp; ajax.status == <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do success</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AJAX状态值\"><a href=\"#AJAX状态值\" class=\"headerlink\" title=\"AJAX状态值\"></a>AJAX状态值</h3><blockquote>\n<p>在《Pragmatic Ajax A Web 2.0 Primer 》<br>&nbsp;</p>\n<blockquote>\n<p>0: (Uninitialized) the send( ) method has not yet been invoked.<br>1: (Loading) the send( ) method has been invoked, request in progress.<br>2: (Loaded) the send( ) method has completed, entire response received.<br>3: (Interactive) the response is being parsed.<br>4: (Completed) the response has been parsed, is ready for harvesting.<br>&nbsp;<br>0 － （未初始化）还没有调用<code>send()</code>方法<br>1 － （载入）已调用<code>send()</code>方法，正在发送请求<br>2 － （载入完成）<code>send()</code>方法执行完成，已经接收到全部响应内容<br>3 － （交互）正在解析响应内容<br>4 － （完成）响应内容解析完成，可以在客户端调用了</p>\n</blockquote>\n</blockquote>\n<h3 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h3><blockquote>\n<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>HTTP状态码的英文为HTTP Status Code。</p>\n</blockquote>\n<blockquote>\n<p>下面是常见的HTTP状态码：</p>\n<table>\n<thead>\n<tr>\n<th>码值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>301</td>\n<td>资源（网页等）被永久转移到其它URL</td>\n</tr>\n<tr>\n<td>404</td>\n<td>请求的资源（网页等）不存在</td>\n</tr>\n<tr>\n<td>500</td>\n<td>内部服务器错误</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h4 id=\"HTTP状态码分类\"><a href=\"#HTTP状态码分类\" class=\"headerlink\" title=\"HTTP状态码分类\"></a>HTTP状态码分类</h4><blockquote>\n<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1**</td>\n<td>信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td>2**</td>\n<td>成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td>3**</td>\n<td>重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td>4**</td>\n<td>客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td>5**</td>\n<td>服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<hr>\n<h4 id=\"HTTP状态码列表\"><a href=\"#HTTP状态码列表\" class=\"headerlink\" title=\"HTTP状态码列表\"></a>HTTP状态码列表</h4><blockquote>\n<p>HTTP状态码列表:</p>\n<table>\n<thead>\n<tr>\n<th>码值</th>\n<th>英文名称</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td>Continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td>继续。客户端应继续其请求</td>\n</tr>\n<tr>\n<td>101</td>\n<td>Switching Protocols</td>\n<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>请求成功。一般用于GET与POST请求</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>已创建。成功请求并创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>已接受。已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td>203</td>\n<td>Non-Authoritative Information</td>\n<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No Content</td>\n<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>\n</tr>\n<tr>\n<td>205</td>\n<td>Reset Content</td>\n<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>\n</tr>\n<tr>\n<td>206</td>\n<td>Partial Content</td>\n<td>部分内容。服务器成功处理了部分GET请求</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>300</td>\n<td>Multiple Choices</td>\n<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>\n</tr>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>查看其它地址。与301类似。使用GET和POST请求查看</td>\n</tr>\n<tr>\n<td>304</td>\n<td>Not Modified</td>\n<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>\n</tr>\n<tr>\n<td>305</td>\n<td>Use Proxy</td>\n<td>使用代理。所请求的资源必须通过代理访问</td>\n</tr>\n<tr>\n<td>306</td>\n<td>Unused</td>\n<td>已经被废弃的HTTP状态码</td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>临时重定向。与302类似。使用GET请求重定向</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>400</td>\n<td>Bad Request</td>\n<td>客户端请求的语法错误，服务器无法理解</td>\n</tr>\n<tr>\n<td>401</td>\n<td>Unauthorized</td>\n<td>请求要求用户的身份认证</td>\n</tr>\n<tr>\n<td>402</td>\n<td>Payment Required</td>\n<td>保留，将来使用</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>客户端请求中的方法被禁止</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>服务器无法根据客户端请求的内容特性完成请求</td>\n</tr>\n<tr>\n<td>407</td>\n<td>Proxy Authentication Required</td>\n<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Time-out</td>\n<td>服务器等待客户端发送的请求时间过长，超时</td>\n</tr>\n<tr>\n<td>409</td>\n<td>Conflict</td>\n<td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>\n</tr>\n<tr>\n<td>410</td>\n<td>Gone</td>\n<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>\n</tr>\n<tr>\n<td>411</td>\n<td>Length Required</td>\n<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>\n</tr>\n<tr>\n<td>412</td>\n<td>Precondition Failed</td>\n<td>客户端请求信息的先决条件错误</td>\n</tr>\n<tr>\n<td>413</td>\n<td>Request Entity Too Large</td>\n<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>\n</tr>\n<tr>\n<td>414</td>\n<td>Request-URI Too Large</td>\n<td>请求的URI过长（URI通常为网址），服务器无法处理</td>\n</tr>\n<tr>\n<td>415</td>\n<td>Unsupported Media Type</td>\n<td>服务器无法处理请求附带的媒体格式</td>\n</tr>\n<tr>\n<td>416</td>\n<td>Requested range not satisfiable</td>\n<td>客户端请求的范围无效</td>\n</tr>\n<tr>\n<td>417</td>\n<td>Expectation Failed</td>\n<td>服务器无法满足Expect的请求头信息</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器内部错误，无法完成请求</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>服务器不支持请求的功能，无法完成请求</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Time-out</td>\n<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version not supported</td>\n<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>\n</tr>\n</tbody>\n</table>\n</blockquote>"},{"title":"ES6 Generator","date":"2018-10-10T08:00:37.000Z","toc":true,"banner":"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg","_content":"\n>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\n<!-- more -->\n\n### 基本概念\n\n>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，`function`关键字与函数名之间有一个星号；二是，函数体内部使用`yield`表达式，定义不同的内部状态（`yield`在英语里的意思就是“产出”）。 \n\n``` js\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n```\n\n上面代码定义了一个 `Generator` 函数`helloWorldGenerator`，它内部有两个`yield`表达式（`hello`和`world`），即该函数有三个状态：`hello`，`world` 和 `return` 语句（结束执行）。\n\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。**不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象**。\n\n下一步，必须调用遍历器对象的`next`方法，使得指针移向下一个状态。也就是说，每次调用`next`方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个`yield`表达式（或`return`语句）为止。换言之，`Generator` 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。\n\n``` js\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n```\n\n**总结一下，调用 `Generator` 函数，返回一个遍历器对象，代表 `Generator` 函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。**\n\n>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。\n由于 Generator 函数仍然是普通函数，所以一般的写法是星号紧跟在function关键字后面。\n\n---\n\n### yield 表达式\n\n>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的`next`方法的运行逻辑如下。\n\n（1）遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。\n\n（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。\n\n（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。\n\n（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。\n\n需要**注意**的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（`Lazy Evaluation`）的语法功能。\n另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\n\n---\n\n### next 方法\n\n>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n``` js\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n```\n\n上面代码先定义了一个可以无限运行的 `Generator` 函数`f`，如果`next`方法没有参数，每次运行到`yield`表达式，变量`reset`的值总是`undefined`。当`next`方法带一个参数`true`时，变量`reset`就被重置为这个参数（即`true`），因此i会等于-1，下一轮循环就会从-1开始递增。\n\n>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n\n---\n\n### Generator.prototype.throw() \n\n>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n\n``` js\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n```\n\n上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 `Generator` 函数体内的`catch`语句捕获。`i`第二次抛出错误，由于 `Generator` 函数内部的`catch`语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 `Generator` 函数体，被函数体外的`catch`语句捕获。\n\n`throw`方法可以接受一个参数，该参数会被`catch`语句接收，建议抛出`Error`对象的实例。\n\n---\n\n### Generator.prototype.return()\n\n>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。\n\n``` js\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n```\n\n如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。\n\n``` js\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers();\ng.next()         // { value: 1, done: false }\ng.next()         // { value: 2, done: false }\ng.return(7)      // { value: 4, done: false }\ng.next()         // { value: 5, done: false }\ng.next()         // { value: 7, done: true }\n```\n\n上面代码中，调用`return`方法后，就开始执行`finally`代码块，然后等到`finally`代码块执行完，再执行`return`方法。\n\n---\n\n### yield* 表达式\n\n>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。\n此时就需要用到`yield*`表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。\n\n``` js\nfunction* bar() {\n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  yield 'a';\n  yield 'b';\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n```","source":"_posts/Generator.md","raw":"---\ntitle: ES6 Generator\ndate: 2018-10-10 16:00:37\ntoc: true\nbanner: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg\ncategories: '笔记'\ntags:\n\t- js\n\t- ES6\n\t- 前端\n\n---\n\n>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\n<!-- more -->\n\n### 基本概念\n\n>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，`function`关键字与函数名之间有一个星号；二是，函数体内部使用`yield`表达式，定义不同的内部状态（`yield`在英语里的意思就是“产出”）。 \n\n``` js\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n```\n\n上面代码定义了一个 `Generator` 函数`helloWorldGenerator`，它内部有两个`yield`表达式（`hello`和`world`），即该函数有三个状态：`hello`，`world` 和 `return` 语句（结束执行）。\n\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。**不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象**。\n\n下一步，必须调用遍历器对象的`next`方法，使得指针移向下一个状态。也就是说，每次调用`next`方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个`yield`表达式（或`return`语句）为止。换言之，`Generator` 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。\n\n``` js\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n```\n\n**总结一下，调用 `Generator` 函数，返回一个遍历器对象，代表 `Generator` 函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。**\n\n>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。\n由于 Generator 函数仍然是普通函数，所以一般的写法是星号紧跟在function关键字后面。\n\n---\n\n### yield 表达式\n\n>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的`next`方法的运行逻辑如下。\n\n（1）遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。\n\n（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。\n\n（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。\n\n（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。\n\n需要**注意**的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（`Lazy Evaluation`）的语法功能。\n另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\n\n---\n\n### next 方法\n\n>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n``` js\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n```\n\n上面代码先定义了一个可以无限运行的 `Generator` 函数`f`，如果`next`方法没有参数，每次运行到`yield`表达式，变量`reset`的值总是`undefined`。当`next`方法带一个参数`true`时，变量`reset`就被重置为这个参数（即`true`），因此i会等于-1，下一轮循环就会从-1开始递增。\n\n>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n\n---\n\n### Generator.prototype.throw() \n\n>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n\n``` js\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n```\n\n上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 `Generator` 函数体内的`catch`语句捕获。`i`第二次抛出错误，由于 `Generator` 函数内部的`catch`语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 `Generator` 函数体，被函数体外的`catch`语句捕获。\n\n`throw`方法可以接受一个参数，该参数会被`catch`语句接收，建议抛出`Error`对象的实例。\n\n---\n\n### Generator.prototype.return()\n\n>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。\n\n``` js\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n```\n\n如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。\n\n``` js\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers();\ng.next()         // { value: 1, done: false }\ng.next()         // { value: 2, done: false }\ng.return(7)      // { value: 4, done: false }\ng.next()         // { value: 5, done: false }\ng.next()         // { value: 7, done: true }\n```\n\n上面代码中，调用`return`方法后，就开始执行`finally`代码块，然后等到`finally`代码块执行完，再执行`return`方法。\n\n---\n\n### yield* 表达式\n\n>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。\n此时就需要用到`yield*`表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。\n\n``` js\nfunction* bar() {\n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  yield 'a';\n  yield 'b';\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n```","slug":"Generator","published":1,"updated":"2018-10-10T09:57:24.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pm000530uj1p201td8","content":"<blockquote>\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><blockquote>\n<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。 </p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'ending'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>\n<p>上面代码定义了一个 <code>Generator</code> 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：<code>hello</code>，<code>world</code> 和 <code>return</code> 语句（结束执行）。</p>\n<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。<strong>不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</strong>。</p>\n<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，<code>Generator</code> 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'hello', done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'world', done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'ending', done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结一下，调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</strong></p>\n<blockquote>\n<p>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。<br>由于 Generator 函数仍然是普通函数，所以一般的写法是星号紧跟在function关键字后面。</p>\n</blockquote>\n<hr>\n<h3 id=\"yield-表达式\"><a href=\"#yield-表达式\" class=\"headerlink\" title=\"yield 表达式\"></a>yield 表达式</h3><blockquote>\n<p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>\n</blockquote>\n<p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p>\n<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>\n<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p>\n<p>需要<strong>注意</strong>的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（<code>Lazy Evaluation</code>）的语法功能。<br>另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p>\n<hr>\n<h3 id=\"next-方法\"><a href=\"#next-方法\" class=\"headerlink\" title=\"next 方法\"></a>next 方法</h3><blockquote>\n<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reset) &#123; i = <span class=\"number\">-1</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next(<span class=\"literal\">true</span>) <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码先定义了一个可以无限运行的 <code>Generator</code> 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此i会等于-1，下一轮循环就会从-1开始递增。</p>\n<blockquote>\n<p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>\n</blockquote>\n<hr>\n<h3 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h3><blockquote>\n<p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'内部捕获'</span>, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = g();</span><br><span class=\"line\">i.next();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  i.throw(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  i.throw(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'外部捕获'</span>, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 内部捕获 a</span></span><br><span class=\"line\"><span class=\"comment\">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 <code>Generator</code> 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 <code>Generator</code> 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 <code>Generator</code> 函数体，被函数体外的<code>catch</code>语句捕获。</p>\n<p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</p>\n<hr>\n<h3 id=\"Generator-prototype-return\"><a href=\"#Generator-prototype-return\" class=\"headerlink\" title=\"Generator.prototype.return()\"></a>Generator.prototype.return()</h3><blockquote>\n<p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next()        <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.return(<span class=\"string\">'foo'</span>) <span class=\"comment\">// &#123; value: \"foo\", done: true &#125;</span></span><br><span class=\"line\">g.next()        <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果 Generator 函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">numbers</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = numbers();</span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 2, done: false &#125;</span></span><br><span class=\"line\">g.return(<span class=\"number\">7</span>)      <span class=\"comment\">// &#123; value: 4, done: false &#125;</span></span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 5, done: false &#125;</span></span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，调用<code>return</code>方法后，就开始执行<code>finally</code>代码块，然后等到<code>finally</code>代码块执行完，再执行<code>return</code>方法。</p>\n<hr>\n<h3 id=\"yield-表达式-1\"><a href=\"#yield-表达式-1\" class=\"headerlink\" title=\"yield* 表达式\"></a>yield* 表达式</h3><blockquote>\n<p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。<br>此时就需要用到<code>yield*</code>表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'x'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* foo();</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'y'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'x'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'b'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'y'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'x'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> foo()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'y'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> bar())&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"x\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"a\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"b\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"y\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n</blockquote>","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><blockquote>\n<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。 </p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'ending'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>\n<p>上面代码定义了一个 <code>Generator</code> 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：<code>hello</code>，<code>world</code> 和 <code>return</code> 语句（结束执行）。</p>\n<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。<strong>不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</strong>。</p>\n<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，<code>Generator</code> 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'hello', done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'world', done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: 'ending', done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结一下，调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</strong></p>\n<blockquote>\n<p>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。<br>由于 Generator 函数仍然是普通函数，所以一般的写法是星号紧跟在function关键字后面。</p>\n</blockquote>\n<hr>\n<h3 id=\"yield-表达式\"><a href=\"#yield-表达式\" class=\"headerlink\" title=\"yield 表达式\"></a>yield 表达式</h3><blockquote>\n<p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>\n</blockquote>\n<p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p>\n<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>\n<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p>\n<p>需要<strong>注意</strong>的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（<code>Lazy Evaluation</code>）的语法功能。<br>另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p>\n<hr>\n<h3 id=\"next-方法\"><a href=\"#next-方法\" class=\"headerlink\" title=\"next 方法\"></a>next 方法</h3><blockquote>\n<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reset) &#123; i = <span class=\"number\">-1</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next(<span class=\"literal\">true</span>) <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码先定义了一个可以无限运行的 <code>Generator</code> 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此i会等于-1，下一轮循环就会从-1开始递增。</p>\n<blockquote>\n<p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>\n</blockquote>\n<hr>\n<h3 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h3><blockquote>\n<p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'内部捕获'</span>, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = g();</span><br><span class=\"line\">i.next();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  i.throw(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">  i.throw(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'外部捕获'</span>, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 内部捕获 a</span></span><br><span class=\"line\"><span class=\"comment\">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 <code>Generator</code> 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 <code>Generator</code> 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 <code>Generator</code> 函数体，被函数体外的<code>catch</code>语句捕获。</p>\n<p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</p>\n<hr>\n<h3 id=\"Generator-prototype-return\"><a href=\"#Generator-prototype-return\" class=\"headerlink\" title=\"Generator.prototype.return()\"></a>Generator.prototype.return()</h3><blockquote>\n<p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next()        <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.return(<span class=\"string\">'foo'</span>) <span class=\"comment\">// &#123; value: \"foo\", done: true &#125;</span></span><br><span class=\"line\">g.next()        <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果 Generator 函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">numbers</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = numbers();</span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 2, done: false &#125;</span></span><br><span class=\"line\">g.return(<span class=\"number\">7</span>)      <span class=\"comment\">// &#123; value: 4, done: false &#125;</span></span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 5, done: false &#125;</span></span><br><span class=\"line\">g.next()         <span class=\"comment\">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，调用<code>return</code>方法后，就开始执行<code>finally</code>代码块，然后等到<code>finally</code>代码块执行完，再执行<code>return</code>方法。</p>\n<hr>\n<h3 id=\"yield-表达式-1\"><a href=\"#yield-表达式-1\" class=\"headerlink\" title=\"yield* 表达式\"></a>yield* 表达式</h3><blockquote>\n<p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。<br>此时就需要用到<code>yield*</code>表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'x'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* foo();</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'y'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'x'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'a'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'b'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'y'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'x'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> foo()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'y'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> bar())&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"x\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"a\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"b\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"y\"</span></span><br></pre></td></tr></table></figure>"},{"title":"ES6 Promise","date":"2018-10-09T07:13:04.000Z","toc":true,"banner":"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg","_content":"\n>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n\n<!-- more -->\n\n### Promise 的含义\n\n>所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。`Promise` 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\nPromise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 `resolved`（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的`resolved`统一只指`fulfilled`状态，不包含`rejected`状态。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n`Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 [`Stream`](https://nodejs.org/api/stream.html) 模式是比部署 `Promise` 更好的选择。\n\n---\n\n### 基本用法\n\n>ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n下面代码创造了一个`Promise`实例。\n\n``` js\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n`resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n>`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n``` js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n`then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。\n\n下面是一个`Promise`对象的简单例子。\n\n``` js\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n```\n\n上面代码中，`timeout`方法返回一个`Promise`实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，`Promise`实例的状态变为`resolved`，就会触发`then`方法绑定的回调函数。\n\n`Promise` 新建后就会立即执行。\n\n``` js\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// resolved\n```\n上面代码中，`Promise` 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。\n\n下面是异步加载图片的例子。\n\n``` js\nfunction loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url));\n    };\n\n    image.src = url;\n  });\n}\n```\n\n上面代码中，使用`Promise`包装了一个图片加载的异步操作。如果加载成功，就调用`resolve`方法，否则就调用`reject`方法。\n\n下面是一个用`Promise`对象实现的 `Ajax` 操作的例子。\n\n``` js\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n---\n\n#### Promise.prototype.then()\n\n>`Promise` 实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 `Promise` 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。\n\n`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n``` js\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n上面的代码使用`then`方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。\n\n``` js\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"resolved: \", comments);\n}, function funcB(err){\n  console.log(\"rejected: \", err);\n});\n```\n\n上面代码中，第一个`then`方法指定的回调函数，返回的是另一个`Promise`对象。这时，第二个`then`方法指定的回调函数，就会等待这个新的`Promise`对象状态发生变化。如果变为`resolved`，就调用`funcA`，如果状态变为`rejected`，就调用`funcB`。\n\n如果采用箭头函数，上面的代码可以写得更简洁。\n\n``` js\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"resolved: \", comments),\n  err => console.log(\"rejected: \", err)\n);\n```\n\n---\n\n#### Promise.prototype.catch()\n\n>`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。\n\n``` js\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n上面代码中，`getJSON`方法返回一个 `Promise` 对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，`then`方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n`Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。\n\n``` js\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n```\n\n上面代码中，一共有三个 `Promise` 对象：一个由`getJSON`产生，两个由`then`产生。它们之中任何一个抛出的错误，都会被最后一个`catch`捕获。\n\n一般来说，不要在`then`方法里面定义 `Reject` 状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。\n\n``` js\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也更接近同步的写法`（try/catch）`。因此，建议总是使用`catch`方法，而不使用`then`方法的第二个参数。\n\n---\n\n#### Promise.prototype.finally()\n\n>`finally`方法用于指定不管 `Promise` 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\n``` js\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n上面代码中，不管`promise`最后的状态，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。\n\n---\n\n#### Promise.all() \n\n>`Promise.all`方法用于将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，`Promise.all`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是 `Promise` 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。（`Promise.all`方法的参数可以不是数组，但必须具有 `Iterator` 接口，且返回的每个成员都是 `Promise` 实例。）\n\n`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。\n\n（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。\n\n（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。\n\n下面是一个具体的例子。\n\n``` js\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n上面代码中，`promises`是包含 6 个 `Promise` 实例的数组，只有这 6 个实例的状态都变成`fulfilled`，或者其中有一个变为`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n---\n\n#### Promise.race()\n\n>`Promise.race`方法同样是将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 `Promise` 实例的返回值，就传递给`p`的回调函数。\n\n`Promise.race`方法的参数与`Promise.all`方法一样，如果不是 `Promise` 实例，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 `Promise` 的状态变为`reject`，否则变为`resolve`。\n\n``` js\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n\n上面代码中，如果 5 秒之内`fetch`方法无法返回结果，变量`p`的状态就会变为`rejected`，从而触发`catch`方法指定的回调函数。\n\n---\n\n#### Promise.resolve()\n\n>有时需要将现有对象转为 `Promise` 对象，`Promise.resolve`方法就起到这个作用。\n\n``` js\nconst jsPromise = Promise.resolve($.ajax('/whatever.json'));\n```\n\n上面代码将 jQuery 生成的`deferred`对象，转为一个新的 `Promise` 对象。\n\n`Promise.resolve`等价于下面的写法。\n\n``` js\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n#### Promise.reject()\n\n>`Promise.reject(reason)`方法也会返回一个新的 `Promise` 实例，该实例的状态为`rejected`。\n\n``` js\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n上面代码生成一个 `Promise` 对象的实例p，状态为`rejected`，回调函数会立即执行。\n\n**注意**，`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。这一点与`Promise.resolve`方法不一致。\n\n``` js\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n```\n\n上面代码中，`Promise.reject`方法的参数是一个`thenable`对象，执行以后，后面`catch`方法的参数不是`reject`抛出的“出错了”这个字符串，而是`thenable`对象。\n\n#### Promise.try()\n\n>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。\n\n>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\n>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。\n\n``` js\nPromise.try(database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n```\n","source":"_posts/Promise.md","raw":"---\ntitle: ES6 Promise\ndate: 2018-10-09 15:13:04\ntoc: true\nbanner: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg\ncategories: '笔记'\ntags:\n\t- js\n\t- ES6\n\t- 前端\n---\n\n>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n\n<!-- more -->\n\n### Promise 的含义\n\n>所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。`Promise` 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\nPromise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 `resolved`（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的`resolved`统一只指`fulfilled`状态，不包含`rejected`状态。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n`Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 [`Stream`](https://nodejs.org/api/stream.html) 模式是比部署 `Promise` 更好的选择。\n\n---\n\n### 基本用法\n\n>ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n下面代码创造了一个`Promise`实例。\n\n``` js\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n`resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n>`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n``` js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n`then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。\n\n下面是一个`Promise`对象的简单例子。\n\n``` js\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n```\n\n上面代码中，`timeout`方法返回一个`Promise`实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，`Promise`实例的状态变为`resolved`，就会触发`then`方法绑定的回调函数。\n\n`Promise` 新建后就会立即执行。\n\n``` js\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// resolved\n```\n上面代码中，`Promise` 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。\n\n下面是异步加载图片的例子。\n\n``` js\nfunction loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url));\n    };\n\n    image.src = url;\n  });\n}\n```\n\n上面代码中，使用`Promise`包装了一个图片加载的异步操作。如果加载成功，就调用`resolve`方法，否则就调用`reject`方法。\n\n下面是一个用`Promise`对象实现的 `Ajax` 操作的例子。\n\n``` js\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n---\n\n#### Promise.prototype.then()\n\n>`Promise` 实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 `Promise` 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。\n\n`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n``` js\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n上面的代码使用`then`方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。\n\n``` js\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"resolved: \", comments);\n}, function funcB(err){\n  console.log(\"rejected: \", err);\n});\n```\n\n上面代码中，第一个`then`方法指定的回调函数，返回的是另一个`Promise`对象。这时，第二个`then`方法指定的回调函数，就会等待这个新的`Promise`对象状态发生变化。如果变为`resolved`，就调用`funcA`，如果状态变为`rejected`，就调用`funcB`。\n\n如果采用箭头函数，上面的代码可以写得更简洁。\n\n``` js\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"resolved: \", comments),\n  err => console.log(\"rejected: \", err)\n);\n```\n\n---\n\n#### Promise.prototype.catch()\n\n>`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。\n\n``` js\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n上面代码中，`getJSON`方法返回一个 `Promise` 对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，`then`方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n`Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。\n\n``` js\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n```\n\n上面代码中，一共有三个 `Promise` 对象：一个由`getJSON`产生，两个由`then`产生。它们之中任何一个抛出的错误，都会被最后一个`catch`捕获。\n\n一般来说，不要在`then`方法里面定义 `Reject` 状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。\n\n``` js\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也更接近同步的写法`（try/catch）`。因此，建议总是使用`catch`方法，而不使用`then`方法的第二个参数。\n\n---\n\n#### Promise.prototype.finally()\n\n>`finally`方法用于指定不管 `Promise` 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\n``` js\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n上面代码中，不管`promise`最后的状态，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。\n\n---\n\n#### Promise.all() \n\n>`Promise.all`方法用于将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，`Promise.all`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是 `Promise` 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。（`Promise.all`方法的参数可以不是数组，但必须具有 `Iterator` 接口，且返回的每个成员都是 `Promise` 实例。）\n\n`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。\n\n（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。\n\n（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。\n\n下面是一个具体的例子。\n\n``` js\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n上面代码中，`promises`是包含 6 个 `Promise` 实例的数组，只有这 6 个实例的状态都变成`fulfilled`，或者其中有一个变为`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n---\n\n#### Promise.race()\n\n>`Promise.race`方法同样是将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 `Promise` 实例的返回值，就传递给`p`的回调函数。\n\n`Promise.race`方法的参数与`Promise.all`方法一样，如果不是 `Promise` 实例，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 `Promise` 的状态变为`reject`，否则变为`resolve`。\n\n``` js\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n\n上面代码中，如果 5 秒之内`fetch`方法无法返回结果，变量`p`的状态就会变为`rejected`，从而触发`catch`方法指定的回调函数。\n\n---\n\n#### Promise.resolve()\n\n>有时需要将现有对象转为 `Promise` 对象，`Promise.resolve`方法就起到这个作用。\n\n``` js\nconst jsPromise = Promise.resolve($.ajax('/whatever.json'));\n```\n\n上面代码将 jQuery 生成的`deferred`对象，转为一个新的 `Promise` 对象。\n\n`Promise.resolve`等价于下面的写法。\n\n``` js\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n#### Promise.reject()\n\n>`Promise.reject(reason)`方法也会返回一个新的 `Promise` 实例，该实例的状态为`rejected`。\n\n``` js\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n上面代码生成一个 `Promise` 对象的实例p，状态为`rejected`，回调函数会立即执行。\n\n**注意**，`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。这一点与`Promise.resolve`方法不一致。\n\n``` js\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n```\n\n上面代码中，`Promise.reject`方法的参数是一个`thenable`对象，执行以后，后面`catch`方法的参数不是`reject`抛出的“出错了”这个字符串，而是`thenable`对象。\n\n#### Promise.try()\n\n>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。\n\n>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\n>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。\n\n``` js\nPromise.try(database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n```\n","slug":"Promise","published":1,"updated":"2018-11-29T07:23:10.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pn000730uji4xkn7c4","content":"<blockquote>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Promise-的含义\"><a href=\"#Promise-的含义\" class=\"headerlink\" title=\"Promise 的含义\"></a>Promise 的含义</h3><blockquote>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n</blockquote>\n<p>Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 <a href=\"https://nodejs.org/api/stream.html\" target=\"_blank\" rel=\"noopener\"><code>Stream</code></a> 模式是比部署 <code>Promise</code> 更好的选择。</p>\n<hr>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><blockquote>\n<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n</blockquote>\n<p>下面代码创造了一个<code>Promise</code>实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<blockquote>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>\n<p>下面是一个<code>Promise</code>对象的简单例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms, <span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">timeout(<span class=\"number\">100</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>\n<p><code>Promise</code> 新建后就会立即执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise</span></span><br><span class=\"line\"><span class=\"comment\">// Hi!</span></span><br><span class=\"line\"><span class=\"comment\">// resolved</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<p>下面是异步加载图片的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImageAsync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(image);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Could not load image at '</span> + url));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>\n<p>下面是一个用<code>Promise</code>对象实现的 <code>Ajax</code> 操作的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    client.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">    client.onreadystatechange = handler;</span><br><span class=\"line\">    client.responseType = <span class=\"string\">\"json\"</span>;</span><br><span class=\"line\">    client.setRequestHeader(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">    client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Contents: '</span> + json);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'出错了'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h4><blockquote>\n<p><code>Promise</code> 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用<code>funcA</code>，如果状态变为<code>rejected</code>，就调用<code>funcB</code>。</p>\n<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(</span><br><span class=\"line\">  post =&gt; getJSON(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  comments =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments),</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h4><blockquote>\n<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>getJSON</code>方法返回一个 <code>Promise</code> 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>\n<p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/post/1.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，一共有三个 <code>Promise</code> 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p>\n<p>一般来说，不要在<code>then</code>方法里面定义 <code>Reject</code> 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法<code>（try/catch）</code>。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p>\n<hr>\n<h4 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h4><blockquote>\n<p><code>finally</code>方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><blockquote>\n<p><code>Promise.all</code>方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 <code>Promise</code> 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 <code>Iterator</code> 接口，且返回的每个成员都是 <code>Promise</code> 实例。）</p>\n<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>\n<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>\n<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>\n<p>下面是一个具体的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成一个Promise对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(<span class=\"string\">'/post/'</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>promises</code>是包含 6 个 <code>Promise</code> 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<hr>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><blockquote>\n<p><code>Promise.race</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。</p>\n<p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 <code>Promise</code> 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">  fetch(<span class=\"string\">'/resource-that-may-take-a-while'</span>),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request timeout'</span>)), <span class=\"number\">5000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">.catch(<span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><blockquote>\n<p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve</code>方法就起到这个作用。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> jsPromise = <span class=\"built_in\">Promise</span>.resolve($.ajax(<span class=\"string\">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>\n<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 <code>Promise</code> 对象。</p>\n<p><code>Promise.resolve</code>等价于下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(<span class=\"string\">'foo'</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><blockquote>\n<p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n<p>上面代码生成一个 <code>Promise</code> 对象的实例p，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><strong>注意</strong>，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thenable = &#123;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(thenable)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e === thenable)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p>\n<h4 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h4><blockquote>\n<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。</p>\n</blockquote>\n<blockquote>\n<p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p>\n</blockquote>\n<blockquote>\n<p>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.try(database.users.get(&#123;<span class=\"attr\">id</span>: userId&#125;))</span><br><span class=\"line\">  .then(...)</span><br><span class=\"line\">  .catch(...)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>\n</blockquote>","more":"<h3 id=\"Promise-的含义\"><a href=\"#Promise-的含义\" class=\"headerlink\" title=\"Promise 的含义\"></a>Promise 的含义</h3><blockquote>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n</blockquote>\n<p>Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 <a href=\"https://nodejs.org/api/stream.html\" target=\"_blank\" rel=\"noopener\"><code>Stream</code></a> 模式是比部署 <code>Promise</code> 更好的选择。</p>\n<hr>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><blockquote>\n<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n</blockquote>\n<p>下面代码创造了一个<code>Promise</code>实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<blockquote>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>\n<p>下面是一个<code>Promise</code>对象的简单例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms, <span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">timeout(<span class=\"number\">100</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>\n<p><code>Promise</code> 新建后就会立即执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise</span></span><br><span class=\"line\"><span class=\"comment\">// Hi!</span></span><br><span class=\"line\"><span class=\"comment\">// resolved</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<p>下面是异步加载图片的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImageAsync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(image);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Could not load image at '</span> + url));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>\n<p>下面是一个用<code>Promise</code>对象实现的 <code>Ajax</code> 操作的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    client.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">    client.onreadystatechange = handler;</span><br><span class=\"line\">    client.responseType = <span class=\"string\">\"json\"</span>;</span><br><span class=\"line\">    client.setRequestHeader(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">    client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Contents: '</span> + json);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'出错了'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h4><blockquote>\n<p><code>Promise</code> 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用<code>funcA</code>，如果状态变为<code>rejected</code>，就调用<code>funcB</code>。</p>\n<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(</span><br><span class=\"line\">  post =&gt; getJSON(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  comments =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments),</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h4><blockquote>\n<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>getJSON</code>方法返回一个 <code>Promise</code> 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>\n<p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/post/1.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，一共有三个 <code>Promise</code> 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p>\n<p>一般来说，不要在<code>then</code>方法里面定义 <code>Reject</code> 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法<code>（try/catch）</code>。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p>\n<hr>\n<h4 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h4><blockquote>\n<p><code>finally</code>方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><blockquote>\n<p><code>Promise.all</code>方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 <code>Promise</code> 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 <code>Iterator</code> 接口，且返回的每个成员都是 <code>Promise</code> 实例。）</p>\n<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>\n<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>\n<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>\n<p>下面是一个具体的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成一个Promise对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(<span class=\"string\">'/post/'</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>promises</code>是包含 6 个 <code>Promise</code> 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<hr>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><blockquote>\n<p><code>Promise.race</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。</p>\n<p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 <code>Promise</code> 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">  fetch(<span class=\"string\">'/resource-that-may-take-a-while'</span>),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request timeout'</span>)), <span class=\"number\">5000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">.catch(<span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><blockquote>\n<p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve</code>方法就起到这个作用。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> jsPromise = <span class=\"built_in\">Promise</span>.resolve($.ajax(<span class=\"string\">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>\n<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 <code>Promise</code> 对象。</p>\n<p><code>Promise.resolve</code>等价于下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(<span class=\"string\">'foo'</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><blockquote>\n<p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n<p>上面代码生成一个 <code>Promise</code> 对象的实例p，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><strong>注意</strong>，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thenable = &#123;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(thenable)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e === thenable)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p>\n<h4 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h4><blockquote>\n<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。</p>\n</blockquote>\n<blockquote>\n<p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p>\n</blockquote>\n<blockquote>\n<p>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.try(database.users.get(&#123;<span class=\"attr\">id</span>: userId&#125;))</span><br><span class=\"line\">  .then(...)</span><br><span class=\"line\">  .catch(...)</span><br></pre></td></tr></table></figure>"},{"title":"RISE - 巅峰造极境","date":"2018-09-29T02:49:14.000Z","top":false,"banner":"/bolg/2018/09/29/RISE/banner.jpg","thumbnail":"https://gss3.bdstatic.com/84oSdTum2Q5BphGlnYG/timg?wapp&quality=80&size=b150_150&subsize=20480&cut_x=0&cut_w=0&cut_y=0&cut_h=0&sec=1369815402&srctrace&di=92d43c740baeb2f0a45cb3afc9cfa30d&wh_rate=null&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fpic%2Fitem%2F377adab44aed2e73af4253468b01a18b87d6fa35.jpg","_content":"\n2018 英雄联盟全球总决赛主题曲\n<!--more-->\n\n**2018 英雄联盟全球总决赛主题曲**\n\n<!-- <iframe \n\tstyle=\"width: 100%; height: 28vw;\"\n\tautoPlay=\"false\"\n\tsrc=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n\tframeborder=0 allowfullscreen>\n</iframe> -->\n\n<video width=\"100%\" controls preload>\n    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\">\n</video>\n","source":"_posts/RISE.md","raw":"---\ntitle: RISE - 巅峰造极境\ndate: 2018-09-29 10:49:14\ncategories: 娱乐\ntop: false\ntags: \n\t- LOL\n\t- video\nbanner: /bolg/2018/09/29/RISE/banner.jpg\nthumbnail: https://gss3.bdstatic.com/84oSdTum2Q5BphGlnYG/timg?wapp&quality=80&size=b150_150&subsize=20480&cut_x=0&cut_w=0&cut_y=0&cut_h=0&sec=1369815402&srctrace&di=92d43c740baeb2f0a45cb3afc9cfa30d&wh_rate=null&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fpic%2Fitem%2F377adab44aed2e73af4253468b01a18b87d6fa35.jpg\n---\n\n2018 英雄联盟全球总决赛主题曲\n<!--more-->\n\n**2018 英雄联盟全球总决赛主题曲**\n\n<!-- <iframe \n\tstyle=\"width: 100%; height: 28vw;\"\n\tautoPlay=\"false\"\n\tsrc=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n\tframeborder=0 allowfullscreen>\n</iframe> -->\n\n<video width=\"100%\" controls preload>\n    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\">\n</video>\n","slug":"RISE","published":1,"updated":"2018-11-30T01:31:17.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4po000830ujzinapmm8","content":"<p>2018 英雄联盟全球总决赛主题曲<br><a id=\"more\"></a></p>\n<p><strong>2018 英雄联盟全球总决赛主题曲</strong></p>\n<!-- <iframe \n    style=\"width: 100%; height: 28vw;\"\n    autoPlay=\"false\"\n    src=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n    frameborder=0 allowfullscreen>\n</iframe> -->\n<video width=\"100%\" controls preload=\"\"><br>    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\"><br></video>\n","site":{"data":{}},"excerpt":"<p>2018 英雄联盟全球总决赛主题曲<br></p>","more":"<p></p>\n<p><strong>2018 英雄联盟全球总决赛主题曲</strong></p>\n<!-- <iframe \n    style=\"width: 100%; height: 28vw;\"\n    autoPlay=\"false\"\n    src=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n    frameborder=0 allowfullscreen>\n</iframe> -->\n<video width=\"100%\" controls preload=\"\"><br>    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\"><br></video>"},{"title":"ES6 async","date":"2018-10-10T09:18:18.000Z","toc":true,"banner":"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg","_content":"\n>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\n<!-- more -->\n\n### 含义\n\n>async 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n现在有一个 Generator 函数，依次读取两个文件。\n\n``` js\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n```\n\n``` js\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n```\n\n写成`async`函数，就是下面这样。\n\n``` js\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，`async`函数就是将 Generator 函数的星号（\\*）替换成`async`，将`yield`替换成`await`，仅此而已。\n\n`async`函数对 Generator 函数的改进，体现在以下四点。\n\n1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n\n2）更好的语义。\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n3）更广的适用性。\n\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n4）返回值是 Promise。\n\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n---\n\n### 基本用法\n\n>`async`函数返回一个 `Promise` 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n``` js\nasync function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n```\n\n上面代码是一个获取股票报价的函数，函数前面的`async`关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个`Promise`对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\n``` js\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n上面代码指定 50 毫秒以后，输出hello world。\n\n由于`async`函数返回的是 `Promise` 对象，可以作为`await`命令的参数。所以，上面的例子也可以写成下面的形式。\n\n``` js\nasync function timeout(ms) {\n  await new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n---\n\n### 返回 Promise 对象\n\n>async函数返回一个 Promise 对象。\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\n\n``` js\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n上面代码中，函数f内部`return`命令返回的值，会被then方法回调函数接收到。\n\n`async`函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n\n```\n\n---\n\n### Promise 对象的状态变化\n\n>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n下面是一个例子。\n\n``` js\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n```\n\n上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行`then`方法里面的`console.log`。\n\n---\n\n### await 命令\n\n正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。\n\n``` js\nasync function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n```\n\n上面代码中，`await`命令的参数是数值123，这时等同于`return` 123。\n\n`await`命令后面的 `Promise` 对象如果变为`reject`状态，则`reject`的参数会被`catch`方法的回调函数接收到。\n\n``` js\nasync function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n```\n\n注意，上面代码中，`await`语句前面没有`return`，但是`reject`方法的参数依然传入了`catch`方法的回调函数。这里如果在`await`前面加上`return`，效果是一样的。\n\n只要一个`await`语句后面的 `Promise` 变为`reject`，那么整个`async`函数都会中断执行。\n\n``` js\nasync function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n```\n\n上面代码中，第二个`await`语句是不会执行的，因为第一个`await`语句状态变成了`reject`。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个`await`放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个`await`都会执行。\n\n``` js\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n```\n\n另一种方法是`await`后面的 `Promise` 对象再跟一个`catch`方法，处理前面可能出现的错误。\n\n``` js\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n\n```\n\n---\n\n### 错误处理\n\n如果`await`后面的异步操作出错，那么等同于`async`函数返回的 `Promise` 对象被`reject`。\n\n``` js\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n```\n\n上面代码中，`async`函数`f`执行后，`await`后面的 `Promise` 对象会抛出一个错误对象，导致`catch`方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制。\n\n防止出错的方法，也是将其放在`try...catch`代码块之中。\n\n``` js\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n```\n\n如果有多个`await`命令，可以统一放在`try...catch`结构中。\n\n``` js\nasync function main() {\n  try {\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n```\n\n下面的例子使用`try...catch`结构，实现多次重复尝试。\n\n``` js\nconst superagent = require('superagent');\nconst NUM_RETRIES = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < NUM_RETRIES; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n```\n\n上面代码中，如果`await`操作成功，就会使用`break`语句退出循环；如果失败，会被`catch`语句捕捉，然后进入下一轮循环。\n\n---\n\n### 使用注意点\n\n第一点，前面已经说过，`await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。\n\n``` js\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n```\n\n第二点，多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n``` js\nlet foo = await getFoo();\nlet bar = await getBar();\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n上面两种写法，`getFoo`和`getBar`都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n``` js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码会报错，因为`await`用在普通函数之中了。但是，如果将`forEach`方法的参数改成`async`函数，也有问题。\n\n``` js\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码可能不会正常工作，原因是这时三个`db.post`操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用`for`循环。\n\n\n``` js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n```\n\n如果确实希望多个请求并发执行，可以使用`Promise.all`方法。当三个请求都会`resolved`时，下面两种写法效果相同。\n\n``` js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\n目前，esm模块加载器支持顶层`await`，即`await`命令可以不放在 `async` 函数里面，直接使用。\n\n``` js\n// async 函数的写法\nconst start = async () => {\n  const res = await fetch('google.com');\n  return res.text();\n};\n\nstart().then(console.log);\n\n// 顶层 await 的写法\nconst res = await fetch('google.com');\nconsole.log(await res.text());\n```\n\n上面代码中，第二种写法的脚本必须使用`esm`加载器，才会生效。","source":"_posts/async.md","raw":"---\ntitle: ES6 async\ndate: 2018-10-10 17:18:18\ntoc: true\nbanner: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg\ncategories: '笔记'\ntags:\n\t- js\n\t- ES6\n\t- 前端\n---\n\n>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\n<!-- more -->\n\n### 含义\n\n>async 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n现在有一个 Generator 函数，依次读取两个文件。\n\n``` js\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n```\n\n``` js\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n```\n\n写成`async`函数，就是下面这样。\n\n``` js\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，`async`函数就是将 Generator 函数的星号（\\*）替换成`async`，将`yield`替换成`await`，仅此而已。\n\n`async`函数对 Generator 函数的改进，体现在以下四点。\n\n1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n\n2）更好的语义。\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n3）更广的适用性。\n\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n4）返回值是 Promise。\n\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n---\n\n### 基本用法\n\n>`async`函数返回一个 `Promise` 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n``` js\nasync function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n```\n\n上面代码是一个获取股票报价的函数，函数前面的`async`关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个`Promise`对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\n``` js\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n上面代码指定 50 毫秒以后，输出hello world。\n\n由于`async`函数返回的是 `Promise` 对象，可以作为`await`命令的参数。所以，上面的例子也可以写成下面的形式。\n\n``` js\nasync function timeout(ms) {\n  await new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n---\n\n### 返回 Promise 对象\n\n>async函数返回一个 Promise 对象。\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\n\n``` js\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n上面代码中，函数f内部`return`命令返回的值，会被then方法回调函数接收到。\n\n`async`函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n\n```\n\n---\n\n### Promise 对象的状态变化\n\n>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n下面是一个例子。\n\n``` js\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n```\n\n上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行`then`方法里面的`console.log`。\n\n---\n\n### await 命令\n\n正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。\n\n``` js\nasync function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n```\n\n上面代码中，`await`命令的参数是数值123，这时等同于`return` 123。\n\n`await`命令后面的 `Promise` 对象如果变为`reject`状态，则`reject`的参数会被`catch`方法的回调函数接收到。\n\n``` js\nasync function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n```\n\n注意，上面代码中，`await`语句前面没有`return`，但是`reject`方法的参数依然传入了`catch`方法的回调函数。这里如果在`await`前面加上`return`，效果是一样的。\n\n只要一个`await`语句后面的 `Promise` 变为`reject`，那么整个`async`函数都会中断执行。\n\n``` js\nasync function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n```\n\n上面代码中，第二个`await`语句是不会执行的，因为第一个`await`语句状态变成了`reject`。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个`await`放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个`await`都会执行。\n\n``` js\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n```\n\n另一种方法是`await`后面的 `Promise` 对象再跟一个`catch`方法，处理前面可能出现的错误。\n\n``` js\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n\n```\n\n---\n\n### 错误处理\n\n如果`await`后面的异步操作出错，那么等同于`async`函数返回的 `Promise` 对象被`reject`。\n\n``` js\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n```\n\n上面代码中，`async`函数`f`执行后，`await`后面的 `Promise` 对象会抛出一个错误对象，导致`catch`方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制。\n\n防止出错的方法，也是将其放在`try...catch`代码块之中。\n\n``` js\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n```\n\n如果有多个`await`命令，可以统一放在`try...catch`结构中。\n\n``` js\nasync function main() {\n  try {\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n```\n\n下面的例子使用`try...catch`结构，实现多次重复尝试。\n\n``` js\nconst superagent = require('superagent');\nconst NUM_RETRIES = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < NUM_RETRIES; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n```\n\n上面代码中，如果`await`操作成功，就会使用`break`语句退出循环；如果失败，会被`catch`语句捕捉，然后进入下一轮循环。\n\n---\n\n### 使用注意点\n\n第一点，前面已经说过，`await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。\n\n``` js\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n```\n\n第二点，多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n``` js\nlet foo = await getFoo();\nlet bar = await getBar();\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n上面两种写法，`getFoo`和`getBar`都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n``` js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码会报错，因为`await`用在普通函数之中了。但是，如果将`forEach`方法的参数改成`async`函数，也有问题。\n\n``` js\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码可能不会正常工作，原因是这时三个`db.post`操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用`for`循环。\n\n\n``` js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n```\n\n如果确实希望多个请求并发执行，可以使用`Promise.all`方法。当三个请求都会`resolved`时，下面两种写法效果相同。\n\n``` js\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\n目前，esm模块加载器支持顶层`await`，即`await`命令可以不放在 `async` 函数里面，直接使用。\n\n``` js\n// async 函数的写法\nconst start = async () => {\n  const res = await fetch('google.com');\n  return res.text();\n};\n\nstart().then(console.log);\n\n// 顶层 await 的写法\nconst res = await fetch('google.com');\nconsole.log(await res.text());\n```\n\n上面代码中，第二种写法的脚本必须使用`esm`加载器，才会生效。","slug":"async","published":1,"updated":"2018-11-28T01:17:30.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pq000930ujt91coaiz","content":"<blockquote>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><blockquote>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n</blockquote>\n<p>现在有一个 Generator 函数，依次读取两个文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>写成<code>async</code>函数，就是下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（*）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p>1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>\n<p>2）更好的语义。</p>\n<p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>\n<p>3）更广的适用性。</p>\n<p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>\n<p>4）返回值是 Promise。</p>\n<p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>\n<blockquote>\n<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n</blockquote>\n<hr>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><blockquote>\n<p><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStockPriceByName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> symbol = <span class=\"keyword\">await</span> getStockSymbol(name);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stockPrice = <span class=\"keyword\">await</span> getStockPrice(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(<span class=\"string\">'goog'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码指定 50 毫秒以后，输出hello world。</p>\n<p>由于<code>async</code>函数返回的是 <code>Promise</code> 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"返回-Promise-对象\"><a href=\"#返回-Promise-对象\" class=\"headerlink\" title=\"返回 Promise 对象\"></a>返回 Promise 对象</h3><blockquote>\n<p>async函数返回一个 Promise 对象。<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// \"hello world\"</span></span><br><span class=\"line\">上面代码中，函数f内部<span class=\"string\">`return`</span>命令返回的值，会被then方法回调函数接收到。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`async`</span>函数内部抛出错误，会导致返回的 <span class=\"built_in\">Promise</span> 对象变为reject状态。抛出的错误对象会被<span class=\"keyword\">catch</span>方法回调函数接收到。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  v =&gt; <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  e =&gt; <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"Promise-对象的状态变化\"><a href=\"#Promise-对象的状态变化\" class=\"headerlink\" title=\"Promise 对象的状态变化\"></a>Promise 对象的状态变化</h3><blockquote>\n<p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>\n</blockquote>\n<p>下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">'https://tc39.github.io/ecma262/'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// \"ECMAScript 2017 Language Specification\"</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<hr>\n<h3 id=\"await-命令\"><a href=\"#await-命令\" class=\"headerlink\" title=\"await 命令\"></a>await 命令</h3><p>正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等同于</span></span><br><span class=\"line\">  <span class=\"comment\">// return 123;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>await</code>命令的参数是数值123，这时等同于<code>return</code> 123。</p>\n<p><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p>只要一个<code>await</code>语句后面的 <code>Promise</code> 变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n<p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// Error：出错了</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 <code>Promise</code> 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span>(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val1 = <span class=\"keyword\">await</span> firstStep();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val2 = <span class=\"keyword\">await</span> secondStep(val1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val3 = <span class=\"keyword\">await</span> thirdStep(val1, val2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Final: '</span>, val3);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> NUM_RETRIES = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> superagent.get(<span class=\"string\">'http://google.com/this-throws-an-error'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(err) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<hr>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise()</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br><span class=\"line\">上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123; <span class=\"comment\">//这里不需要 async</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可能得到错误结果</span></span><br><span class=\"line\">  docs.forEach(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前，esm模块加载器支持顶层<code>await</code>，即<code>await</code>命令可以不放在 <code>async</code> 函数里面，直接使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async 函数的写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'google.com'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.text();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">start().then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顶层 await 的写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'google.com'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> res.text());</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二种写法的脚本必须使用<code>esm</code>加载器，才会生效。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n</blockquote>","more":"<h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><blockquote>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n</blockquote>\n<p>现在有一个 Generator 函数，依次读取两个文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>写成<code>async</code>函数，就是下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（*）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p>1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>\n<p>2）更好的语义。</p>\n<p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>\n<p>3）更广的适用性。</p>\n<p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>\n<p>4）返回值是 Promise。</p>\n<p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>\n<blockquote>\n<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n</blockquote>\n<hr>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><blockquote>\n<p><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStockPriceByName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> symbol = <span class=\"keyword\">await</span> getStockSymbol(name);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stockPrice = <span class=\"keyword\">await</span> getStockPrice(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(<span class=\"string\">'goog'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码指定 50 毫秒以后，输出hello world。</p>\n<p>由于<code>async</code>函数返回的是 <code>Promise</code> 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"返回-Promise-对象\"><a href=\"#返回-Promise-对象\" class=\"headerlink\" title=\"返回 Promise 对象\"></a>返回 Promise 对象</h3><blockquote>\n<p>async函数返回一个 Promise 对象。<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// \"hello world\"</span></span><br><span class=\"line\">上面代码中，函数f内部<span class=\"string\">`return`</span>命令返回的值，会被then方法回调函数接收到。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`async`</span>函数内部抛出错误，会导致返回的 <span class=\"built_in\">Promise</span> 对象变为reject状态。抛出的错误对象会被<span class=\"keyword\">catch</span>方法回调函数接收到。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  v =&gt; <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  e =&gt; <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"Promise-对象的状态变化\"><a href=\"#Promise-对象的状态变化\" class=\"headerlink\" title=\"Promise 对象的状态变化\"></a>Promise 对象的状态变化</h3><blockquote>\n<p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>\n</blockquote>\n<p>下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">'https://tc39.github.io/ecma262/'</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// \"ECMAScript 2017 Language Specification\"</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<hr>\n<h3 id=\"await-命令\"><a href=\"#await-命令\" class=\"headerlink\" title=\"await 命令\"></a>await 命令</h3><p>正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等同于</span></span><br><span class=\"line\">  <span class=\"comment\">// return 123;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>await</code>命令的参数是数值123，这时等同于<code>return</code> 123。</p>\n<p><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p>只要一个<code>await</code>语句后面的 <code>Promise</code> 变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n<p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// Error：出错了</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 <code>Promise</code> 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span>(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val1 = <span class=\"keyword\">await</span> firstStep();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val2 = <span class=\"keyword\">await</span> secondStep(val1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val3 = <span class=\"keyword\">await</span> thirdStep(val1, val2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Final: '</span>, val3);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">'superagent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> NUM_RETRIES = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> superagent.get(<span class=\"string\">'http://google.com/this-throws-an-error'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(err) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<hr>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> somethingThatReturnsAPromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> somethingThatReturnsAPromise()</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br><span class=\"line\">上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123; <span class=\"comment\">//这里不需要 async</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可能得到错误结果</span></span><br><span class=\"line\">  docs.forEach(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前，esm模块加载器支持顶层<code>await</code>，即<code>await</code>命令可以不放在 <code>async</code> 函数里面，直接使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async 函数的写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'google.com'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.text();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">start().then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顶层 await 的写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'google.com'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> res.text());</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二种写法的脚本必须使用<code>esm</code>加载器，才会生效。</p>"},{"title":"hexo 创建文章 & 文章缩略图及banner & MarkDown","date":"2018-02-27T06:29:09.000Z","comments":1,"toc":true,"thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538137142415&di=6ea66fbfbb708b7280625217af646afb&imgtype=0&src=http%3A%2F%2Fi1.hdslb.com%2Fvideo%2F08%2F086510262d86a381a52a3651174dbd4d.jpg","<!-- banner":"/bolg/2018/09/27/hexo-创建文章/banner.jpg -->","_content":"\nhexo 文章的创建及markdown语法\n<!--more-->\n\n## hexo 创建文章\n命令行输入：\n``` bash\n$ hexo new \"new article\"\n```\n\n之后在source/_posts目录下面，多了一个new-article.md的文件。\n打开后：\n``` bash\n---\ntitle: new article\ndate: 2018-09-28 20:10:33\ntags:\n---\n\n```\n文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。\n**新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。**\n\n\n***\n\n### 属性\n\t文章可以拥有如下属性：\n\n|  Setting   |        Description        |    Default     |\n|------------|---------------------------|----------------|\n| layout     | layout                    | post或page     |\n| title      | 文章标题                  | 文件名         |\n| date       | 创建日期                  | 文件的创建日期 |\n| updated    | 修改日期                  | 文件的修改日期 |\n| comments   | 是否开启评论              | true           |\n| tags       | 标签                      | NULL           |\n| categories | 分类                      | NULL           |\n| permalink  | url中的名字               | 文件名         |\n| thumbnail  | 文章缩略图                | NULL           |\n| banner     | 文章缩略图&文章首部banner | NULL           |\n\n***\n\n### 分类和标签\n\n\t分类只有一个，但标签可以有多个且有两种写法如下：\n\n``` bash\n---\n...\ncategories: \"工具\"\ntags:\n    - hexo\n    - markdown\n    - 前端\n# 或者\n# tags: [hexo, markdown, 前端]\n---\n```\n***\n\n## 文章缩略图和banner\n**注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考**\n当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；\n当只设置 thumbnail 时， 文章只有缩略图，无banner\n当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；\n\n\t设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n![文件目录](hexo-创建文章/wenjian.jpg)\n\t或者修改配置文件\\_config.yml\n``` bash\npost_asset_folder: true # 创建时生成静态资源文件夹\n```\n此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner\n\n### 文章缩略图设置：\n![文章缩略图](hexo-创建文章/suoluetu.png)\n``` bash\n---\n...\nthumbnail: https://...        # 此处为图片地址\n---\n```\n\n***\n\n### 文章banner设置：\n![文章banner](hexo-创建文章/banner.jpg)\n``` bash\n---\n...\nbanner: https://...           # 此处为图片地址\n---\n```\n***注： 若引用本地图片时，需要加上路径前缀，如下图：***\n![路径](hexo-创建文章/lujing.jpg)\n![目录](hexo-创建文章/lujing2.jpg)\n\t\n\t则引用路径为：\n``` bash\nbanner: /bolg/2018/09/27/hexo-创建文章/banner.jpg\n```\n\n***\n\n## MarkDown 语法\n\n### 斜体和粗体\n``` bash\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n```\n\n\t效果\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n\n***\n\n### 分级标题\n``` bash\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n<!-- \t效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n\n***\n\n### 超链接\n``` bash\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://kevinpu.github.io/\n[2]:http://www.jianshu.com/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n```\n\t\n\t效果\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://zhangjichengcc.github.io/bolg/\n[2]:https://zhangjichengcc.github.io/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n\n\n***\n\n### 列表\n#### 无序列表：\n``` bash\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n```\n\n\t效果\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n\n#### 有序列表\n``` bash\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n```\n\n\t效果\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n\n***\n\n### 插入图片\n``` bash\n![文字说明](/images/...)\n```\n\n***\n\n### 表格\n``` bash\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n```\n\n\t效果\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n\n***\n\n### code\n``` bash\n``` bash\n...code 主体\n```\n\n\t效果\n``` bash\n...code 主体\n```\n\n### 引用\n``` bash\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用\n```\n\t效果\n\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用","source":"_posts/hexo-创建文章.md","raw":"---\ntitle: hexo 创建文章 & 文章缩略图及banner & MarkDown\ndate: 2018-02-27 14:29:09\ncomments: true\ntoc: true\ncategories: \"工具\"\ntags: [hexo, markdown, 前端]\n\nthumbnail: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538137142415&di=6ea66fbfbb708b7280625217af646afb&imgtype=0&src=http%3A%2F%2Fi1.hdslb.com%2Fvideo%2F08%2F086510262d86a381a52a3651174dbd4d.jpg\n<!-- banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg -->\n\n---\n\nhexo 文章的创建及markdown语法\n<!--more-->\n\n## hexo 创建文章\n命令行输入：\n``` bash\n$ hexo new \"new article\"\n```\n\n之后在source/_posts目录下面，多了一个new-article.md的文件。\n打开后：\n``` bash\n---\ntitle: new article\ndate: 2018-09-28 20:10:33\ntags:\n---\n\n```\n文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。\n**新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。**\n\n\n***\n\n### 属性\n\t文章可以拥有如下属性：\n\n|  Setting   |        Description        |    Default     |\n|------------|---------------------------|----------------|\n| layout     | layout                    | post或page     |\n| title      | 文章标题                  | 文件名         |\n| date       | 创建日期                  | 文件的创建日期 |\n| updated    | 修改日期                  | 文件的修改日期 |\n| comments   | 是否开启评论              | true           |\n| tags       | 标签                      | NULL           |\n| categories | 分类                      | NULL           |\n| permalink  | url中的名字               | 文件名         |\n| thumbnail  | 文章缩略图                | NULL           |\n| banner     | 文章缩略图&文章首部banner | NULL           |\n\n***\n\n### 分类和标签\n\n\t分类只有一个，但标签可以有多个且有两种写法如下：\n\n``` bash\n---\n...\ncategories: \"工具\"\ntags:\n    - hexo\n    - markdown\n    - 前端\n# 或者\n# tags: [hexo, markdown, 前端]\n---\n```\n***\n\n## 文章缩略图和banner\n**注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考**\n当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；\n当只设置 thumbnail 时， 文章只有缩略图，无banner\n当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；\n\n\t设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n![文件目录](hexo-创建文章/wenjian.jpg)\n\t或者修改配置文件\\_config.yml\n``` bash\npost_asset_folder: true # 创建时生成静态资源文件夹\n```\n此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner\n\n### 文章缩略图设置：\n![文章缩略图](hexo-创建文章/suoluetu.png)\n``` bash\n---\n...\nthumbnail: https://...        # 此处为图片地址\n---\n```\n\n***\n\n### 文章banner设置：\n![文章banner](hexo-创建文章/banner.jpg)\n``` bash\n---\n...\nbanner: https://...           # 此处为图片地址\n---\n```\n***注： 若引用本地图片时，需要加上路径前缀，如下图：***\n![路径](hexo-创建文章/lujing.jpg)\n![目录](hexo-创建文章/lujing2.jpg)\n\t\n\t则引用路径为：\n``` bash\nbanner: /bolg/2018/09/27/hexo-创建文章/banner.jpg\n```\n\n***\n\n## MarkDown 语法\n\n### 斜体和粗体\n``` bash\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n```\n\n\t效果\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n\n***\n\n### 分级标题\n``` bash\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n<!-- \t效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n\n***\n\n### 超链接\n``` bash\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://kevinpu.github.io/\n[2]:http://www.jianshu.com/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n```\n\t\n\t效果\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://zhangjichengcc.github.io/bolg/\n[2]:https://zhangjichengcc.github.io/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n\n\n***\n\n### 列表\n#### 无序列表：\n``` bash\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n```\n\n\t效果\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n\n#### 有序列表\n``` bash\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n```\n\n\t效果\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n\n***\n\n### 插入图片\n``` bash\n![文字说明](/images/...)\n```\n\n***\n\n### 表格\n``` bash\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n```\n\n\t效果\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n\n***\n\n### code\n``` bash\n``` bash\n...code 主体\n```\n\n\t效果\n``` bash\n...code 主体\n```\n\n### 引用\n``` bash\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用\n```\n\t效果\n\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用","slug":"hexo-创建文章","published":1,"updated":"2018-12-21T03:05:56.057Z","layout":"post","photos":[],"link":"","_id":"cjpy1k4pr000a30ujpswrp2tc","content":"<p>hexo 文章的创建及markdown语法<br><a id=\"more\"></a></p>\n<h2 id=\"hexo-创建文章\"><a href=\"#hexo-创建文章\" class=\"headerlink\" title=\"hexo 创建文章\"></a>hexo 创建文章</h2><p>命令行输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"new article\"</span></span><br></pre></td></tr></table></figure></p>\n<p>之后在source/_posts目录下面，多了一个new-article.md的文件。<br>打开后：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: new article</span><br><span class=\"line\">date: 2018-09-28 20:10:33</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。<br><strong>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。</strong></p>\n<hr>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><pre><code>文章可以拥有如下属性：\n</code></pre><table>\n<thead>\n<tr>\n<th>Setting</th>\n<th>Description</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>layout</td>\n<td>post或page</td>\n</tr>\n<tr>\n<td>title</td>\n<td>文章标题</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>date</td>\n<td>创建日期</td>\n<td>文件的创建日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>修改日期</td>\n<td>文件的修改日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>是否开启评论</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>url中的名字</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>thumbnail</td>\n<td>文章缩略图</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>banner</td>\n<td>文章缩略图&amp;文章首部banner</td>\n<td>NULL</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h3><pre><code>分类只有一个，但标签可以有多个且有两种写法如下：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">categories: <span class=\"string\">\"工具\"</span></span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">    - markdown</span><br><span class=\"line\">    - 前端</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"comment\"># tags: [hexo, markdown, 前端]</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"文章缩略图和banner\"><a href=\"#文章缩略图和banner\" class=\"headerlink\" title=\"文章缩略图和banner\"></a>文章缩略图和banner</h2><p><strong>注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考</strong><br>当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；<br>当只设置 thumbnail 时， 文章只有缩略图，无banner<br>当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；</p>\n<pre><code>设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n</code></pre><p><img src=\"/blog/2018/02/27/hexo-创建文章/wenjian.jpg\" alt=\"文件目录\"><br>    或者修改配置文件_config.yml<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: <span class=\"literal\">true</span> <span class=\"comment\"># 创建时生成静态资源文件夹</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner</p>\n<h3 id=\"文章缩略图设置：\"><a href=\"#文章缩略图设置：\" class=\"headerlink\" title=\"文章缩略图设置：\"></a>文章缩略图设置：</h3><p><img src=\"/blog/2018/02/27/hexo-创建文章/suoluetu.png\" alt=\"文章缩略图\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">thumbnail: https://...        <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"文章banner设置：\"><a href=\"#文章banner设置：\" class=\"headerlink\" title=\"文章banner设置：\"></a>文章banner设置：</h3><p><img src=\"/blog/2018/02/27/hexo-创建文章/banner.jpg\" alt=\"文章banner\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">banner: https://...           <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>注： 若引用本地图片时，需要加上路径前缀，如下图：</em></strong><br><img src=\"/blog/2018/02/27/hexo-创建文章/lujing.jpg\" alt=\"路径\"><br><img src=\"/blog/2018/02/27/hexo-创建文章/lujing2.jpg\" alt=\"目录\"></p>\n<pre><code>则引用路径为：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"MarkDown-语法\"><a href=\"#MarkDown-语法\" class=\"headerlink\" title=\"MarkDown 语法\"></a>MarkDown 语法</h2><h3 id=\"斜体和粗体\"><a href=\"#斜体和粗体\" class=\"headerlink\" title=\"斜体和粗体\"></a>斜体和粗体</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*这是斜体* 或 _这也是斜体_ </span><br><span class=\"line\">**这是粗体**</span><br><span class=\"line\">***这是加粗斜体***</span><br><span class=\"line\">~~这是删除线~~</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del></p>\n<hr>\n<h3 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一级标题</span></span><br><span class=\"line\"><span class=\"comment\">## 二级标题</span></span><br><span class=\"line\"><span class=\"comment\">### 三级标题</span></span><br><span class=\"line\"><span class=\"comment\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"comment\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"comment\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<!--     效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n<hr>\n<h3 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)</span><br><span class=\"line\">参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]</span><br><span class=\"line\">[1]:https://kevinpu.github.io/</span><br><span class=\"line\">[2]:http://www.jianshu.com/</span><br><span class=\"line\">自动链接：我的博客地址&lt;https://zhangjichengcc.github.io/bolg/&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>行内形式：<a href=\"https://zhangjichengcc.github.io/bolg/\">我的博客</a><br>参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]<br>[1]:<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a><br>[2]:<a href=\"https://zhangjichengcc.github.io/\">https://zhangjichengcc.github.io/</a><br>自动链接：我的博客地址<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a></p>\n<hr>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"无序列表：\"><a href=\"#无序列表：\" class=\"headerlink\" title=\"无序列表：\"></a>无序列表：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 无序列表项1</span><br><span class=\"line\">+ 无序列表项2</span><br><span class=\"line\">- 无序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><ul>\n<li>无序列表项1</li>\n</ul>\n<ul>\n<li>无序列表项2</li>\n</ul>\n<ul>\n<li>无序列表项3</li>\n</ul>\n<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.有序列表项1</span><br><span class=\"line\">2.有序列表项2</span><br><span class=\"line\">3.有序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p>\n<hr>\n<h3 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![文字说明](/images/...)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 表头1|表头2|表头3|表头4</span><br><span class=\"line\">|-| :- | :-: | -: |</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th style=\"text-align:left\">表头2</th>\n<th style=\"text-align:center\">表头3</th>\n<th style=\"text-align:right\">表头4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">``` bash</span><br><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">&gt;&gt;不！我才是引用</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><blockquote>\n<p>这是引用<br>这是引用<br>这是引用</p>\n<blockquote>\n<p>不！我才是引用</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>hexo 文章的创建及markdown语法<br></p>","more":"<p></p>\n<h2 id=\"hexo-创建文章\"><a href=\"#hexo-创建文章\" class=\"headerlink\" title=\"hexo 创建文章\"></a>hexo 创建文章</h2><p>命令行输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"new article\"</span></span><br></pre></td></tr></table></figure></p>\n<p>之后在source/_posts目录下面，多了一个new-article.md的文件。<br>打开后：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: new article</span><br><span class=\"line\">date: 2018-09-28 20:10:33</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。<br><strong>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。</strong></p>\n<hr>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><pre><code>文章可以拥有如下属性：\n</code></pre><table>\n<thead>\n<tr>\n<th>Setting</th>\n<th>Description</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>layout</td>\n<td>post或page</td>\n</tr>\n<tr>\n<td>title</td>\n<td>文章标题</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>date</td>\n<td>创建日期</td>\n<td>文件的创建日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>修改日期</td>\n<td>文件的修改日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>是否开启评论</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>url中的名字</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>thumbnail</td>\n<td>文章缩略图</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>banner</td>\n<td>文章缩略图&amp;文章首部banner</td>\n<td>NULL</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h3><pre><code>分类只有一个，但标签可以有多个且有两种写法如下：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">categories: <span class=\"string\">\"工具\"</span></span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">    - markdown</span><br><span class=\"line\">    - 前端</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"comment\"># tags: [hexo, markdown, 前端]</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"文章缩略图和banner\"><a href=\"#文章缩略图和banner\" class=\"headerlink\" title=\"文章缩略图和banner\"></a>文章缩略图和banner</h2><p><strong>注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考</strong><br>当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；<br>当只设置 thumbnail 时， 文章只有缩略图，无banner<br>当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；</p>\n<pre><code>设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n</code></pre><p><img src=\"/blog/2018/02/27/hexo-创建文章/wenjian.jpg\" alt=\"文件目录\"><br>    或者修改配置文件_config.yml<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: <span class=\"literal\">true</span> <span class=\"comment\"># 创建时生成静态资源文件夹</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner</p>\n<h3 id=\"文章缩略图设置：\"><a href=\"#文章缩略图设置：\" class=\"headerlink\" title=\"文章缩略图设置：\"></a>文章缩略图设置：</h3><p><img src=\"/blog/2018/02/27/hexo-创建文章/suoluetu.png\" alt=\"文章缩略图\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">thumbnail: https://...        <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"文章banner设置：\"><a href=\"#文章banner设置：\" class=\"headerlink\" title=\"文章banner设置：\"></a>文章banner设置：</h3><p><img src=\"/blog/2018/02/27/hexo-创建文章/banner.jpg\" alt=\"文章banner\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">banner: https://...           <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>注： 若引用本地图片时，需要加上路径前缀，如下图：</em></strong><br><img src=\"/blog/2018/02/27/hexo-创建文章/lujing.jpg\" alt=\"路径\"><br><img src=\"/blog/2018/02/27/hexo-创建文章/lujing2.jpg\" alt=\"目录\"></p>\n<pre><code>则引用路径为：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"MarkDown-语法\"><a href=\"#MarkDown-语法\" class=\"headerlink\" title=\"MarkDown 语法\"></a>MarkDown 语法</h2><h3 id=\"斜体和粗体\"><a href=\"#斜体和粗体\" class=\"headerlink\" title=\"斜体和粗体\"></a>斜体和粗体</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*这是斜体* 或 _这也是斜体_ </span><br><span class=\"line\">**这是粗体**</span><br><span class=\"line\">***这是加粗斜体***</span><br><span class=\"line\">~~这是删除线~~</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del></p>\n<hr>\n<h3 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一级标题</span></span><br><span class=\"line\"><span class=\"comment\">## 二级标题</span></span><br><span class=\"line\"><span class=\"comment\">### 三级标题</span></span><br><span class=\"line\"><span class=\"comment\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"comment\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"comment\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<!--     效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n<hr>\n<h3 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)</span><br><span class=\"line\">参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]</span><br><span class=\"line\">[1]:https://kevinpu.github.io/</span><br><span class=\"line\">[2]:http://www.jianshu.com/</span><br><span class=\"line\">自动链接：我的博客地址&lt;https://zhangjichengcc.github.io/bolg/&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>行内形式：<a href=\"https://zhangjichengcc.github.io/bolg/\">我的博客</a><br>参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]<br>[1]:<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a><br>[2]:<a href=\"https://zhangjichengcc.github.io/\">https://zhangjichengcc.github.io/</a><br>自动链接：我的博客地址<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a></p>\n<hr>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"无序列表：\"><a href=\"#无序列表：\" class=\"headerlink\" title=\"无序列表：\"></a>无序列表：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 无序列表项1</span><br><span class=\"line\">+ 无序列表项2</span><br><span class=\"line\">- 无序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><ul>\n<li>无序列表项1</li>\n</ul>\n<ul>\n<li>无序列表项2</li>\n</ul>\n<ul>\n<li>无序列表项3</li>\n</ul>\n<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.有序列表项1</span><br><span class=\"line\">2.有序列表项2</span><br><span class=\"line\">3.有序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p>\n<hr>\n<h3 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![文字说明](/images/...)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 表头1|表头2|表头3|表头4</span><br><span class=\"line\">|-| :- | :-: | -: |</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th style=\"text-align:left\">表头2</th>\n<th style=\"text-align:center\">表头3</th>\n<th style=\"text-align:right\">表头4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">``` bash</span><br><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">&gt;&gt;不！我才是引用</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><blockquote>\n<p>这是引用<br>这是引用<br>这是引用</p>\n<blockquote>\n<p>不！我才是引用</p>\n</blockquote>\n</blockquote>"},{"title":"hexo常用指令","date":"2018-02-05T06:29:09.000Z","comments":1,"toc":true,"tag":["hexo"],"banner":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538053636652&di=0db3bc68fbdb79830a01281e006c9200&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3996696336%2C4120219149%26fm%3D214%26gp%3D0.jpg","description":"生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。","_content":"\nWelcome to [Hexo](https://hexo.io/)! \n<!--more-->\n\n## 开始使用 Install\n\n``` bash\n$ npm install hexo -g     # 安装  \n$ npm update hexo -g      # 升级  \n$ hexo init             # 初始化 \n```\n\n## 快速开始 Quick Start\n\n### 启动本地服务（查看效果）\n\n``` bash\n$ hexo server / $ hexo s\n```\n#### 服务器设置\n``` bash\n$ hexo server                        #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n$ hexo server -s                     #静态模式\n$ hexo server -p 5000                #更改端口\n$ hexo server -i 192.168.1.1         #自定义 IP\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate / $ hexo g           #使用 Hexo 生成静态文件快速而且简单\n$ hexo generate --watch              #监视文件变动\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 文章发布\nhexo 支持在github等平台上一键发布\n注意： 经测试，该配置生效的条件为：\n1. github 项目名要为你自己的github名 如：yourname.github.io \n2. github \\_config.yml 文件的github配置如下\n``` bash\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://yourname.github.io                   # url地址\nroot: /                                           # 根目录          \npermalink: :year/:month/:day/:title/              # 链接组合\npermalink_defaults:\n·\n·\n·\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy: # 配置发布\n  type: git\n  repository: git@github.com:yourname/yourname.github.io.git # 配置为ssh地址，https会失败\n  branch: master\n```\n\n``` bash\n$ hexo deploy / $ hexo d\n```\n\n### 清空缓存及静态文件\n\n``` bash\n$ hexo clean\n```\n\n### 完成后部署\n\n``` bash\n$ hexo generate --deploy / hexo g --d\n$ hexo deploy --generate / hexo d --g\n```\n\n\n### 创建模板\n|   参数   |            描述            |\n|----------|----------------------------|\n| layout   | 布局                       |\n| data     | 创建时间                   |\n| title    | 标题                       |\n\n\n| layout：参数 |     描述     |     存储路径    |             说明            |\n|--------------|--------------|-----------------|-----------------------------|\n| post         | 文章（默认） | source/\\_posts   | 可以直接发布                |\n| draft        | 草稿         | source          | 在source下新建一个文件夹    |\n| page         | 页面         | source/\\_drafts | 新建文件将保存到 \\_drafts中 |\n\n\n``` bash\n$ hexo new [layout] <title>\n```\n#### 创建文章\n``` bash\n$ hexo new <title>\n$ hexo new \"postName\" #新建文章\n```\n#### 创建页面\n``` bash\n$ hexo new page <pageName>\n$ hexo new page \"pageName\" #新建页面\n```\n### 创建/发布草稿\n\n#### 创建草稿\n*会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。*\n\n``` bash\n$ hexo new draft \"new draft\"\n```\n\n*如果你希望强行预览草稿，更改配置文件 (_config.yml)：*\n\n``` bash\nrender_drafts: true\n```\n*或者，如下方式启动 server：*\n``` bash\n$ hexo server --drafts\n```\n\n#### 发布草稿\n\n``` bash\n$ hexo pushlish [layout] <title>\n$ hexo publish / $ hexo p\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### 指令组合执行 &\n\n通常开发测试要依次执行 hexo clean => hexo generate => hexo server, 我们可以通过指令组合执行来完成\n\n``` bash\nhexo clean & hexo g & hexo s\n```\n\n\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hexo常用指令.md","raw":"---\ntitle: hexo常用指令\ndate: 2018-02-05 14:29:09\ncomments: true\ntoc: true\ncategories: \"工具\"\ntag:\n\t- hexo\nbanner: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538053636652&di=0db3bc68fbdb79830a01281e006c9200&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3996696336%2C4120219149%26fm%3D214%26gp%3D0.jpg\ntags:\n    - hexo\ndescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。\n---\n\nWelcome to [Hexo](https://hexo.io/)! \n<!--more-->\n\n## 开始使用 Install\n\n``` bash\n$ npm install hexo -g     # 安装  \n$ npm update hexo -g      # 升级  \n$ hexo init             # 初始化 \n```\n\n## 快速开始 Quick Start\n\n### 启动本地服务（查看效果）\n\n``` bash\n$ hexo server / $ hexo s\n```\n#### 服务器设置\n``` bash\n$ hexo server                        #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n$ hexo server -s                     #静态模式\n$ hexo server -p 5000                #更改端口\n$ hexo server -i 192.168.1.1         #自定义 IP\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate / $ hexo g           #使用 Hexo 生成静态文件快速而且简单\n$ hexo generate --watch              #监视文件变动\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 文章发布\nhexo 支持在github等平台上一键发布\n注意： 经测试，该配置生效的条件为：\n1. github 项目名要为你自己的github名 如：yourname.github.io \n2. github \\_config.yml 文件的github配置如下\n``` bash\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://yourname.github.io                   # url地址\nroot: /                                           # 根目录          \npermalink: :year/:month/:day/:title/              # 链接组合\npermalink_defaults:\n·\n·\n·\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy: # 配置发布\n  type: git\n  repository: git@github.com:yourname/yourname.github.io.git # 配置为ssh地址，https会失败\n  branch: master\n```\n\n``` bash\n$ hexo deploy / $ hexo d\n```\n\n### 清空缓存及静态文件\n\n``` bash\n$ hexo clean\n```\n\n### 完成后部署\n\n``` bash\n$ hexo generate --deploy / hexo g --d\n$ hexo deploy --generate / hexo d --g\n```\n\n\n### 创建模板\n|   参数   |            描述            |\n|----------|----------------------------|\n| layout   | 布局                       |\n| data     | 创建时间                   |\n| title    | 标题                       |\n\n\n| layout：参数 |     描述     |     存储路径    |             说明            |\n|--------------|--------------|-----------------|-----------------------------|\n| post         | 文章（默认） | source/\\_posts   | 可以直接发布                |\n| draft        | 草稿         | source          | 在source下新建一个文件夹    |\n| page         | 页面         | source/\\_drafts | 新建文件将保存到 \\_drafts中 |\n\n\n``` bash\n$ hexo new [layout] <title>\n```\n#### 创建文章\n``` bash\n$ hexo new <title>\n$ hexo new \"postName\" #新建文章\n```\n#### 创建页面\n``` bash\n$ hexo new page <pageName>\n$ hexo new page \"pageName\" #新建页面\n```\n### 创建/发布草稿\n\n#### 创建草稿\n*会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。*\n\n``` bash\n$ hexo new draft \"new draft\"\n```\n\n*如果你希望强行预览草稿，更改配置文件 (_config.yml)：*\n\n``` bash\nrender_drafts: true\n```\n*或者，如下方式启动 server：*\n``` bash\n$ hexo server --drafts\n```\n\n#### 发布草稿\n\n``` bash\n$ hexo pushlish [layout] <title>\n$ hexo publish / $ hexo p\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### 指令组合执行 &\n\n通常开发测试要依次执行 hexo clean => hexo generate => hexo server, 我们可以通过指令组合执行来完成\n\n``` bash\nhexo clean & hexo g & hexo s\n```\n\n\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hexo常用指令","published":1,"updated":"2018-12-21T02:58:05.715Z","layout":"post","photos":[],"link":"","_id":"cjpy1k4pt000b30ujywyfayt8","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>!<br><a id=\"more\"></a></p>\n<h2 id=\"开始使用-Install\"><a href=\"#开始使用-Install\" class=\"headerlink\" title=\"开始使用 Install\"></a>开始使用 Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo -g     <span class=\"comment\"># 安装  </span></span><br><span class=\"line\">$ npm update hexo -g      <span class=\"comment\"># 升级  </span></span><br><span class=\"line\">$ hexo init             <span class=\"comment\"># 初始化</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"快速开始-Quick-Start\"><a href=\"#快速开始-Quick-Start\" class=\"headerlink\" title=\"快速开始 Quick Start\"></a>快速开始 Quick Start</h2><h3 id=\"启动本地服务（查看效果）\"><a href=\"#启动本地服务（查看效果）\" class=\"headerlink\" title=\"启动本地服务（查看效果）\"></a>启动本地服务（查看效果）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server / $ hexo s</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务器设置\"><a href=\"#服务器设置\" class=\"headerlink\" title=\"服务器设置\"></a>服务器设置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server                        <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">$ hexo server -s                     <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">$ hexo server -p 5000                <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">$ hexo server -i 192.168.1.1         <span class=\"comment\">#自定义 IP</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate / $ hexo g           <span class=\"comment\">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class=\"line\">$ hexo generate --watch              <span class=\"comment\">#监视文件变动</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"文章发布\"><a href=\"#文章发布\" class=\"headerlink\" title=\"文章发布\"></a>文章发布</h3><p>hexo 支持在github等平台上一键发布<br>注意： 经测试，该配置生效的条件为：</p>\n<ol>\n<li>github 项目名要为你自己的github名 如：yourname.github.io </li>\n<li>github _config.yml 文件的github配置如下<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class=\"line\">url: https://yourname.github.io                   <span class=\"comment\"># url地址</span></span><br><span class=\"line\">root: /                                           <span class=\"comment\"># 根目录          </span></span><br><span class=\"line\">permalink: :year/:month/:day/:title/              <span class=\"comment\"># 链接组合</span></span><br><span class=\"line\">permalink_defaults:</span><br><span class=\"line\">·</span><br><span class=\"line\">·</span><br><span class=\"line\">·</span><br><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy: <span class=\"comment\"># 配置发布</span></span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: git@github.com:yourname/yourname.github.io.git <span class=\"comment\"># 配置为ssh地址，https会失败</span></span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy / $ hexo d</span><br></pre></td></tr></table></figure>\n<h3 id=\"清空缓存及静态文件\"><a href=\"#清空缓存及静态文件\" class=\"headerlink\" title=\"清空缓存及静态文件\"></a>清空缓存及静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate --deploy / hexo g --d</span><br><span class=\"line\">$ hexo deploy --generate / hexo d --g</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建模板\"><a href=\"#创建模板\" class=\"headerlink\" title=\"创建模板\"></a>创建模板</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>data</td>\n<td>创建时间</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>layout：参数</th>\n<th>描述</th>\n<th>存储路径</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>post</td>\n<td>文章（默认）</td>\n<td>source/_posts</td>\n<td>可以直接发布</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>草稿</td>\n<td>source</td>\n<td>在source下新建一个文件夹</td>\n</tr>\n<tr>\n<td>page</td>\n<td>页面</td>\n<td>source/_drafts</td>\n<td>新建文件将保存到 _drafts中</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &lt;title&gt;</span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建页面\"><a href=\"#创建页面\" class=\"headerlink\" title=\"创建页面\"></a>创建页面</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &lt;pageName&gt;</span><br><span class=\"line\">$ hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-发布草稿\"><a href=\"#创建-发布草稿\" class=\"headerlink\" title=\"创建/发布草稿\"></a>创建/发布草稿</h3><h4 id=\"创建草稿\"><a href=\"#创建草稿\" class=\"headerlink\" title=\"创建草稿\"></a>创建草稿</h4><p><em>会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new draft <span class=\"string\">\"new draft\"</span></span><br></pre></td></tr></table></figure>\n<p><em>如果你希望强行预览草稿，更改配置文件 (_config.yml)：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render_drafts: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><em>或者，如下方式启动 server：</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server --drafts</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"发布草稿\"></a>发布草稿</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo pushlish [layout] &lt;title&gt;</span><br><span class=\"line\">$ hexo publish / $ hexo p</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"指令组合执行-amp\"><a href=\"#指令组合执行-amp\" class=\"headerlink\" title=\"指令组合执行 &amp;\"></a>指令组合执行 &amp;</h3><p>通常开发测试要依次执行 hexo clean =&gt; hexo generate =&gt; hexo server, 我们可以通过指令组合执行来完成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>!<br></p>","more":"<p></p>\n<h2 id=\"开始使用-Install\"><a href=\"#开始使用-Install\" class=\"headerlink\" title=\"开始使用 Install\"></a>开始使用 Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo -g     <span class=\"comment\"># 安装  </span></span><br><span class=\"line\">$ npm update hexo -g      <span class=\"comment\"># 升级  </span></span><br><span class=\"line\">$ hexo init             <span class=\"comment\"># 初始化</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"快速开始-Quick-Start\"><a href=\"#快速开始-Quick-Start\" class=\"headerlink\" title=\"快速开始 Quick Start\"></a>快速开始 Quick Start</h2><h3 id=\"启动本地服务（查看效果）\"><a href=\"#启动本地服务（查看效果）\" class=\"headerlink\" title=\"启动本地服务（查看效果）\"></a>启动本地服务（查看效果）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server / $ hexo s</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务器设置\"><a href=\"#服务器设置\" class=\"headerlink\" title=\"服务器设置\"></a>服务器设置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server                        <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">$ hexo server -s                     <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">$ hexo server -p 5000                <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">$ hexo server -i 192.168.1.1         <span class=\"comment\">#自定义 IP</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate / $ hexo g           <span class=\"comment\">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class=\"line\">$ hexo generate --watch              <span class=\"comment\">#监视文件变动</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"文章发布\"><a href=\"#文章发布\" class=\"headerlink\" title=\"文章发布\"></a>文章发布</h3><p>hexo 支持在github等平台上一键发布<br>注意： 经测试，该配置生效的条件为：</p>\n<ol>\n<li>github 项目名要为你自己的github名 如：yourname.github.io </li>\n<li>github _config.yml 文件的github配置如下<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class=\"line\">url: https://yourname.github.io                   <span class=\"comment\"># url地址</span></span><br><span class=\"line\">root: /                                           <span class=\"comment\"># 根目录          </span></span><br><span class=\"line\">permalink: :year/:month/:day/:title/              <span class=\"comment\"># 链接组合</span></span><br><span class=\"line\">permalink_defaults:</span><br><span class=\"line\">·</span><br><span class=\"line\">·</span><br><span class=\"line\">·</span><br><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy: <span class=\"comment\"># 配置发布</span></span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: git@github.com:yourname/yourname.github.io.git <span class=\"comment\"># 配置为ssh地址，https会失败</span></span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy / $ hexo d</span><br></pre></td></tr></table></figure>\n<h3 id=\"清空缓存及静态文件\"><a href=\"#清空缓存及静态文件\" class=\"headerlink\" title=\"清空缓存及静态文件\"></a>清空缓存及静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate --deploy / hexo g --d</span><br><span class=\"line\">$ hexo deploy --generate / hexo d --g</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建模板\"><a href=\"#创建模板\" class=\"headerlink\" title=\"创建模板\"></a>创建模板</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>data</td>\n<td>创建时间</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>layout：参数</th>\n<th>描述</th>\n<th>存储路径</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>post</td>\n<td>文章（默认）</td>\n<td>source/_posts</td>\n<td>可以直接发布</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>草稿</td>\n<td>source</td>\n<td>在source下新建一个文件夹</td>\n</tr>\n<tr>\n<td>page</td>\n<td>页面</td>\n<td>source/_drafts</td>\n<td>新建文件将保存到 _drafts中</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &lt;title&gt;</span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建页面\"><a href=\"#创建页面\" class=\"headerlink\" title=\"创建页面\"></a>创建页面</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &lt;pageName&gt;</span><br><span class=\"line\">$ hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-发布草稿\"><a href=\"#创建-发布草稿\" class=\"headerlink\" title=\"创建/发布草稿\"></a>创建/发布草稿</h3><h4 id=\"创建草稿\"><a href=\"#创建草稿\" class=\"headerlink\" title=\"创建草稿\"></a>创建草稿</h4><p><em>会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new draft <span class=\"string\">\"new draft\"</span></span><br></pre></td></tr></table></figure>\n<p><em>如果你希望强行预览草稿，更改配置文件 (_config.yml)：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render_drafts: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><em>或者，如下方式启动 server：</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server --drafts</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"发布草稿\"></a>发布草稿</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo pushlish [layout] &lt;title&gt;</span><br><span class=\"line\">$ hexo publish / $ hexo p</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"指令组合执行-amp\"><a href=\"#指令组合执行-amp\" class=\"headerlink\" title=\"指令组合执行 &amp;\"></a>指令组合执行 &amp;</h3><p>通常开发测试要依次执行 hexo clean =&gt; hexo generate =&gt; hexo server, 我们可以通过指令组合执行来完成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"jenkins+github+hexo 部署个人博客","date":"2018-12-08T07:26:12.000Z","toc":true,"banner":"/bolg/2018/12/08/jenkins部署个人博客/jenkins.png","_content":"\n>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\n\n<!-- more -->\n\n###部署方式\n\njenkins的构建方式常用分为三种。\n\n**jenkins触发式构建：**push代码或者合并代码到项目的master或者其他分支，jenkins就部署代码到对应服务器。\n\n**jenkins参数化构建：**push代码或者合并代码到项目的master或者其他分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。\n\n**jenkins定时构建：**多用于APP、自动化用例等自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就定时从配置项目地址拉取最新的代码打包。\n\n\n### 安装java环境\n\n#### 下载JDK\n首先我们需要下载java开发工具包JDK，下载地址：\n[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)，\n下载对应版本：\n![](jenkins部署个人博客/jdk.png)\n下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。\n\n#### 配置环境变量\n1.安装完成后，右击\"我的电脑\"，点击\"属性\"，选择\"高级系统设置\"；\n![](jenkins部署个人博客/jdk-1.png)\n2.选择\"高级\"选项卡，点击\"环境变量\"；\n![](jenkins部署个人博客/jdk-2.png)\n3.添加环境变量\n![](jenkins部署个人博客/jdk-3.png)\n在\"系统变量\"中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击\"编辑\"，不存在则点击\"新建\"。\n\n变量设置参数如下：\n\n|  变量名   |                                   变量值                                   |\n|-----------|----------------------------------------------------------------------------|\n| JAVA_HOME | C:\\Program Files (x86)\\Java\\jdk1.8.0_91        // 要根据自己的实际路径配置 |\n| CLASSPATH | .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;                        |\n| Path      | %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;                                       |\n\n#### 测试JDK是否安装成功\n\n进入cmd，键入命令: java -version、java、javac 几个命令进行验证\n\n### jenkins安装\n\n### jenkins配置\n安装完成后，访问 http://你的服务器ip:8080/ 即可\n\n安装好 Jenkins 后，第一次访问会让你输入密码，页面上会提示具体是哪个文件，用 vim 打开即可查看，比如 CentOS 默认是：/var/lib/jenkins/secrets/initialAdminPassword。\n　　进入后，可以创建新的用户，以后就可以使用这个用户访问 Jenkins 了。\n　　新建账号后，会提示安装插件，一般直接按推荐安装，如果有报错，最好点击重试，多试几次一般都会安装成功，如果实在装不上那就先跳过吧\n\n#### 新建任务，输入任务名，选择自由风格即可：\n新建任务，输入任务名，选择自由风格即可：\n![](jenkins部署个人博客/jenkins-1.jpg)\n选择github项目，项目url填写自己博客页面的url\n","source":"_posts/jenkins部署个人博客.md","raw":"---\ntitle: jenkins+github+hexo 部署个人博客\ndate: 2018-12-08 15:26:12\ntoc: true\ncategories: '随笔'\nbanner: /bolg/2018/12/08/jenkins部署个人博客/jenkins.png\ntags:\n\t- js\n\t- 前端\n\t- 部署\n\t- jenkins\n---\n\n>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\n\n<!-- more -->\n\n###部署方式\n\njenkins的构建方式常用分为三种。\n\n**jenkins触发式构建：**push代码或者合并代码到项目的master或者其他分支，jenkins就部署代码到对应服务器。\n\n**jenkins参数化构建：**push代码或者合并代码到项目的master或者其他分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。\n\n**jenkins定时构建：**多用于APP、自动化用例等自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就定时从配置项目地址拉取最新的代码打包。\n\n\n### 安装java环境\n\n#### 下载JDK\n首先我们需要下载java开发工具包JDK，下载地址：\n[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)，\n下载对应版本：\n![](jenkins部署个人博客/jdk.png)\n下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。\n\n#### 配置环境变量\n1.安装完成后，右击\"我的电脑\"，点击\"属性\"，选择\"高级系统设置\"；\n![](jenkins部署个人博客/jdk-1.png)\n2.选择\"高级\"选项卡，点击\"环境变量\"；\n![](jenkins部署个人博客/jdk-2.png)\n3.添加环境变量\n![](jenkins部署个人博客/jdk-3.png)\n在\"系统变量\"中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击\"编辑\"，不存在则点击\"新建\"。\n\n变量设置参数如下：\n\n|  变量名   |                                   变量值                                   |\n|-----------|----------------------------------------------------------------------------|\n| JAVA_HOME | C:\\Program Files (x86)\\Java\\jdk1.8.0_91        // 要根据自己的实际路径配置 |\n| CLASSPATH | .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;                        |\n| Path      | %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;                                       |\n\n#### 测试JDK是否安装成功\n\n进入cmd，键入命令: java -version、java、javac 几个命令进行验证\n\n### jenkins安装\n\n### jenkins配置\n安装完成后，访问 http://你的服务器ip:8080/ 即可\n\n安装好 Jenkins 后，第一次访问会让你输入密码，页面上会提示具体是哪个文件，用 vim 打开即可查看，比如 CentOS 默认是：/var/lib/jenkins/secrets/initialAdminPassword。\n　　进入后，可以创建新的用户，以后就可以使用这个用户访问 Jenkins 了。\n　　新建账号后，会提示安装插件，一般直接按推荐安装，如果有报错，最好点击重试，多试几次一般都会安装成功，如果实在装不上那就先跳过吧\n\n#### 新建任务，输入任务名，选择自由风格即可：\n新建任务，输入任务名，选择自由风格即可：\n![](jenkins部署个人博客/jenkins-1.jpg)\n选择github项目，项目url填写自己博客页面的url\n","slug":"jenkins部署个人博客","published":1,"updated":"2018-12-08T10:21:55.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pu000c30ujzaz5zfoc","content":"<blockquote>\n<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>###部署方式</p>\n<p>jenkins的构建方式常用分为三种。</p>\n<p><strong>jenkins触发式构建：</strong>push代码或者合并代码到项目的master或者其他分支，jenkins就部署代码到对应服务器。</p>\n<p><strong>jenkins参数化构建：</strong>push代码或者合并代码到项目的master或者其他分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。</p>\n<p><strong>jenkins定时构建：</strong>多用于APP、自动化用例等自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就定时从配置项目地址拉取最新的代码打包。</p>\n<h3 id=\"安装java环境\"><a href=\"#安装java环境\" class=\"headerlink\" title=\"安装java环境\"></a>安装java环境</h3><h4 id=\"下载JDK\"><a href=\"#下载JDK\" class=\"headerlink\" title=\"下载JDK\"></a>下载JDK</h4><p>首先我们需要下载java开发工具包JDK，下载地址：<br><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>，<br>下载对应版本：<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk.png\" alt=\"\"><br>下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。</p>\n<h4 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h4><p>1.安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk-1.png\" alt=\"\"><br>2.选择”高级”选项卡，点击”环境变量”；<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk-2.png\" alt=\"\"><br>3.添加环境变量<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk-3.png\" alt=\"\"><br>在”系统变量”中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。</p>\n<p>变量设置参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>变量值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JAVA_HOME</td>\n<td>C:\\Program Files (x86)\\Java\\jdk1.8.0_91        // 要根据自己的实际路径配置</td>\n</tr>\n<tr>\n<td>CLASSPATH</td>\n<td>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;</td>\n</tr>\n<tr>\n<td>Path</td>\n<td>%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"测试JDK是否安装成功\"><a href=\"#测试JDK是否安装成功\" class=\"headerlink\" title=\"测试JDK是否安装成功\"></a>测试JDK是否安装成功</h4><p>进入cmd，键入命令: java -version、java、javac 几个命令进行验证</p>\n<h3 id=\"jenkins安装\"><a href=\"#jenkins安装\" class=\"headerlink\" title=\"jenkins安装\"></a>jenkins安装</h3><h3 id=\"jenkins配置\"><a href=\"#jenkins配置\" class=\"headerlink\" title=\"jenkins配置\"></a>jenkins配置</h3><p>安装完成后，访问 http://你的服务器ip:8080/ 即可</p>\n<p>安装好 Jenkins 后，第一次访问会让你输入密码，页面上会提示具体是哪个文件，用 vim 打开即可查看，比如 CentOS 默认是：/var/lib/jenkins/secrets/initialAdminPassword。<br>　　进入后，可以创建新的用户，以后就可以使用这个用户访问 Jenkins 了。<br>　　新建账号后，会提示安装插件，一般直接按推荐安装，如果有报错，最好点击重试，多试几次一般都会安装成功，如果实在装不上那就先跳过吧</p>\n<h4 id=\"新建任务，输入任务名，选择自由风格即可：\"><a href=\"#新建任务，输入任务名，选择自由风格即可：\" class=\"headerlink\" title=\"新建任务，输入任务名，选择自由风格即可：\"></a>新建任务，输入任务名，选择自由风格即可：</h4><p>新建任务，输入任务名，选择自由风格即可：<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jenkins-1.jpg\" alt=\"\"><br>选择github项目，项目url填写自己博客页面的url</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n</blockquote>","more":"<p>###部署方式</p>\n<p>jenkins的构建方式常用分为三种。</p>\n<p><strong>jenkins触发式构建：</strong>push代码或者合并代码到项目的master或者其他分支，jenkins就部署代码到对应服务器。</p>\n<p><strong>jenkins参数化构建：</strong>push代码或者合并代码到项目的master或者其他分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。</p>\n<p><strong>jenkins定时构建：</strong>多用于APP、自动化用例等自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就定时从配置项目地址拉取最新的代码打包。</p>\n<h3 id=\"安装java环境\"><a href=\"#安装java环境\" class=\"headerlink\" title=\"安装java环境\"></a>安装java环境</h3><h4 id=\"下载JDK\"><a href=\"#下载JDK\" class=\"headerlink\" title=\"下载JDK\"></a>下载JDK</h4><p>首先我们需要下载java开发工具包JDK，下载地址：<br><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>，<br>下载对应版本：<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk.png\" alt=\"\"><br>下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。</p>\n<h4 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h4><p>1.安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk-1.png\" alt=\"\"><br>2.选择”高级”选项卡，点击”环境变量”；<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk-2.png\" alt=\"\"><br>3.添加环境变量<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jdk-3.png\" alt=\"\"><br>在”系统变量”中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。</p>\n<p>变量设置参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>变量值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JAVA_HOME</td>\n<td>C:\\Program Files (x86)\\Java\\jdk1.8.0_91        // 要根据自己的实际路径配置</td>\n</tr>\n<tr>\n<td>CLASSPATH</td>\n<td>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;</td>\n</tr>\n<tr>\n<td>Path</td>\n<td>%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"测试JDK是否安装成功\"><a href=\"#测试JDK是否安装成功\" class=\"headerlink\" title=\"测试JDK是否安装成功\"></a>测试JDK是否安装成功</h4><p>进入cmd，键入命令: java -version、java、javac 几个命令进行验证</p>\n<h3 id=\"jenkins安装\"><a href=\"#jenkins安装\" class=\"headerlink\" title=\"jenkins安装\"></a>jenkins安装</h3><h3 id=\"jenkins配置\"><a href=\"#jenkins配置\" class=\"headerlink\" title=\"jenkins配置\"></a>jenkins配置</h3><p>安装完成后，访问 http://你的服务器ip:8080/ 即可</p>\n<p>安装好 Jenkins 后，第一次访问会让你输入密码，页面上会提示具体是哪个文件，用 vim 打开即可查看，比如 CentOS 默认是：/var/lib/jenkins/secrets/initialAdminPassword。<br>　　进入后，可以创建新的用户，以后就可以使用这个用户访问 Jenkins 了。<br>　　新建账号后，会提示安装插件，一般直接按推荐安装，如果有报错，最好点击重试，多试几次一般都会安装成功，如果实在装不上那就先跳过吧</p>\n<h4 id=\"新建任务，输入任务名，选择自由风格即可：\"><a href=\"#新建任务，输入任务名，选择自由风格即可：\" class=\"headerlink\" title=\"新建任务，输入任务名，选择自由风格即可：\"></a>新建任务，输入任务名，选择自由风格即可：</h4><p>新建任务，输入任务名，选择自由风格即可：<br><img src=\"/blog/2018/12/08/jenkins部署个人博客/jenkins-1.jpg\" alt=\"\"><br>选择github项目，项目url填写自己博客页面的url</p>"},{"title":"js构造函数","date":"2018-10-09T08:53:48.000Z","toc":true,"banner":"/bolg/2018/10/09/js构造函数/banner.jpg","_content":"\n\n前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法[js构造函数][1]，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~\n\n<!-- more -->\n\n### 原型\n首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文\n\n``` js\nfunction Persion(name){\n  this.name = name;                         // 属性\n  this.setName = function(nameName){        // 实例方法\n    this.name = newName;\n  }\n}\nPersion.prototype.sex = 'man';              // 向 Persion 原型中追加属性（原型方法）\n\nvar persion = new Persion('zhang');         // 此时我们实例化一个persion对象，看一下name和sex有什么区别\n```\n\n通过 prototype 添加的属性将出现在实例对象的原型链中，\n\n>每个对象都会有一个内置 __proto__ 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）\n\n我们再来看下面的例子\n\n>**注意**：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。\n\n``` js\nfunction Animal(n) {                      // 声明一个构造函数\n  this.name = n;             \t\t\t\t\t    // 实例属性\n  this.arr = [];                          // 实例属性（引用类型）\n  this.say = function(){                  // 实例方法\n    return 'hello world';\n  }\n}\n  Animal.prototype.sing = function() {    // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];               // 追加原型属性（引用类型）\n```\n\n接下来我们看一下实例属性/方法 和 原型属性/方法的区别\n\n>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。\n\n\n``` js\nvar cat = new Animal('cat');               // 实例化cat对象\nvar dog = new Animal('dog');\t             // 实例化狗子对象\n\ncat.say === dog.say                        // false 不同的实例拥有不同的实例属性/方法\ncat.sing === dog.sing                      // true 不同的实例共享相同的原型属性/方法\n\ncat.arr.push('zz');                        // 向cat实例对象的arr中追加元素；（私有）\ncat.pArr.push('xx');                       // 向cat原型对象的pArr中追加元素；（共享）\nconsole.log(dog.arr);                      // 打印出 []，因为cat只改变了其私有的arr\nconsole.log(dog.pArr);                             // 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr\n```\n\n当然，原型属性为基本数据类型，则不会被共享\n在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：\n1、将属性封装在构造函数中\n2、将方法定义在原型对象上\n\n### ES5继承方式\n\n首先，我们定义一个Animal父类\n\n``` js\nfunction Animal(n) {          \t\t\t\t\t\n  this.name = n;                            // 实例属性\n  this.arr = [];                            // 实例属性（引用类型）\n  this.say = function(){                    // 实例方法\n    return 'hello world';\n  }\n}\nAnimal.prototype.sing = function() {        // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];                 // 追加原型属性（引用类型）\n```\n\n#### 原型链继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;\n}\nCat.prototype = new Animal();                // 父类的实例作为子类的原型对象\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；\n```\n\n优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；\n缺点: 子类实例共享了父类构造函数的引用数据类型属性。\n\n#### 借用构造函数\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);             // 核心，把父类的实例方法属性指向子类\n}\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                  // undefind 无法继承父类的原型属性及方法；\n```\n\n优点: \n1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；\n2、 创建子类实例，可以向父类构造函数传参数；\n缺点: 子类实例不能继承父类的构造属性和方法；\n\n#### 组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);              // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = new Parent()                  // 核心, 父类的实例作为子类的原型对象\nCat.prototype.constructor = Cat;              // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                       // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                   // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；\n3、不共享父类的构造方法及属性；\n缺点: 调用了2次父类的构造方法\n\n#### 寄生组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                       // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = Parent.prototype;                      // 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）\nCat.prototype.constructor = Cat;                       // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                            // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\ntom.pArr.push('publish');                              // 修改继承于父类原型属性值 pArr;\nconsole.log(black.pArr);                               // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，\n// 至此简直是完美呀~~~ 然鹅！\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                      // 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、子类的实例不共享父类的构造方法及属性；\n3、只调用了1次父类的构造方法；\n缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；\n\n#### 寄生组合继承（简直完美）\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                        // 核心，把父类的实例方法属性指向子类；\n}\nvar F = function(){};                                   // 核心，利用空对象作为中介；\nF.prototype = Parent.prototype;                         // 核心，将父类的原型赋值给空对象F；\nCat.prototype = new F();                                // 核心，将F的实例赋值给子类；\nCat.prototype.constructor = Cat;                        // 修复子类Cat的构造器指向，防止原型链的混乱；\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                 // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                             // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；\ntom.pArr.push('publish');                               // 修改继承于父类原型属性值 pArr；\nconsole.log(black.pArr);                                // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                       // undefind  父类实例化的对象不拥有子类的原型属性/方法；\n```\n\n优点: 完美实现继承；\n缺点:实现相对复杂\n\n\n#### 附YUI库实现继承\n\n``` js\nfunction extend(Child, Parent) {\n  var F = function(){};\n  F.prototype = Parent.prototype;\n  hild.prototype = new F();\n  Child.prototype.constructor = Child;\n  Child.uber = Parent.prototype;                          \n}\n// 使用\nextend(Cat,Animal);\n```\n\n>`Child.uber = Parent.prototype;` 的意思是为子对象设一个uber属性，这个属性直接指向父对象的`prototype`属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n\n### ES6继承方式\n\n``` js\nclass Animal{                             // 父类\n  constructor(name){                      // 构造函数\n    this.name=name;\n  }\n  eat(){                                  // 实例方法\n    return 'hello world';\n  }\n}\nclass Cat extends Animal{                 // 子类\n  constructor(name){\n    super(name);                          // 调用实现父类的构造函数\n    this.pName = name;            \n  }\n  sing(){\n \t return '吹呀吹呀，我的骄傲放纵~~';\n  }\n}\n```\n\n[1]: https://segmentfault.com/a/1190000015343232\n","source":"_posts/js构造函数.md","raw":"---\ntitle: 'js构造函数'\ndate: 2018-10-09 16:53:48\ncategories: '笔记'\ntoc: true\nbanner: /bolg/2018/10/09/js构造函数/banner.jpg\ntags:\n\t- js\n---\n\n\n前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法[js构造函数][1]，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~\n\n<!-- more -->\n\n### 原型\n首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文\n\n``` js\nfunction Persion(name){\n  this.name = name;                         // 属性\n  this.setName = function(nameName){        // 实例方法\n    this.name = newName;\n  }\n}\nPersion.prototype.sex = 'man';              // 向 Persion 原型中追加属性（原型方法）\n\nvar persion = new Persion('zhang');         // 此时我们实例化一个persion对象，看一下name和sex有什么区别\n```\n\n通过 prototype 添加的属性将出现在实例对象的原型链中，\n\n>每个对象都会有一个内置 __proto__ 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）\n\n我们再来看下面的例子\n\n>**注意**：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。\n\n``` js\nfunction Animal(n) {                      // 声明一个构造函数\n  this.name = n;             \t\t\t\t\t    // 实例属性\n  this.arr = [];                          // 实例属性（引用类型）\n  this.say = function(){                  // 实例方法\n    return 'hello world';\n  }\n}\n  Animal.prototype.sing = function() {    // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];               // 追加原型属性（引用类型）\n```\n\n接下来我们看一下实例属性/方法 和 原型属性/方法的区别\n\n>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。\n\n\n``` js\nvar cat = new Animal('cat');               // 实例化cat对象\nvar dog = new Animal('dog');\t             // 实例化狗子对象\n\ncat.say === dog.say                        // false 不同的实例拥有不同的实例属性/方法\ncat.sing === dog.sing                      // true 不同的实例共享相同的原型属性/方法\n\ncat.arr.push('zz');                        // 向cat实例对象的arr中追加元素；（私有）\ncat.pArr.push('xx');                       // 向cat原型对象的pArr中追加元素；（共享）\nconsole.log(dog.arr);                      // 打印出 []，因为cat只改变了其私有的arr\nconsole.log(dog.pArr);                             // 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr\n```\n\n当然，原型属性为基本数据类型，则不会被共享\n在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：\n1、将属性封装在构造函数中\n2、将方法定义在原型对象上\n\n### ES5继承方式\n\n首先，我们定义一个Animal父类\n\n``` js\nfunction Animal(n) {          \t\t\t\t\t\n  this.name = n;                            // 实例属性\n  this.arr = [];                            // 实例属性（引用类型）\n  this.say = function(){                    // 实例方法\n    return 'hello world';\n  }\n}\nAnimal.prototype.sing = function() {        // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];                 // 追加原型属性（引用类型）\n```\n\n#### 原型链继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;\n}\nCat.prototype = new Animal();                // 父类的实例作为子类的原型对象\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；\n```\n\n优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；\n缺点: 子类实例共享了父类构造函数的引用数据类型属性。\n\n#### 借用构造函数\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);             // 核心，把父类的实例方法属性指向子类\n}\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                  // undefind 无法继承父类的原型属性及方法；\n```\n\n优点: \n1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；\n2、 创建子类实例，可以向父类构造函数传参数；\n缺点: 子类实例不能继承父类的构造属性和方法；\n\n#### 组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);              // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = new Parent()                  // 核心, 父类的实例作为子类的原型对象\nCat.prototype.constructor = Cat;              // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                       // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                   // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；\n3、不共享父类的构造方法及属性；\n缺点: 调用了2次父类的构造方法\n\n#### 寄生组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                       // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = Parent.prototype;                      // 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）\nCat.prototype.constructor = Cat;                       // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                            // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\ntom.pArr.push('publish');                              // 修改继承于父类原型属性值 pArr;\nconsole.log(black.pArr);                               // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，\n// 至此简直是完美呀~~~ 然鹅！\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                      // 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、子类的实例不共享父类的构造方法及属性；\n3、只调用了1次父类的构造方法；\n缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；\n\n#### 寄生组合继承（简直完美）\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                        // 核心，把父类的实例方法属性指向子类；\n}\nvar F = function(){};                                   // 核心，利用空对象作为中介；\nF.prototype = Parent.prototype;                         // 核心，将父类的原型赋值给空对象F；\nCat.prototype = new F();                                // 核心，将F的实例赋值给子类；\nCat.prototype.constructor = Cat;                        // 修复子类Cat的构造器指向，防止原型链的混乱；\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                 // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                             // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；\ntom.pArr.push('publish');                               // 修改继承于父类原型属性值 pArr；\nconsole.log(black.pArr);                                // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                       // undefind  父类实例化的对象不拥有子类的原型属性/方法；\n```\n\n优点: 完美实现继承；\n缺点:实现相对复杂\n\n\n#### 附YUI库实现继承\n\n``` js\nfunction extend(Child, Parent) {\n  var F = function(){};\n  F.prototype = Parent.prototype;\n  hild.prototype = new F();\n  Child.prototype.constructor = Child;\n  Child.uber = Parent.prototype;                          \n}\n// 使用\nextend(Cat,Animal);\n```\n\n>`Child.uber = Parent.prototype;` 的意思是为子对象设一个uber属性，这个属性直接指向父对象的`prototype`属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n\n### ES6继承方式\n\n``` js\nclass Animal{                             // 父类\n  constructor(name){                      // 构造函数\n    this.name=name;\n  }\n  eat(){                                  // 实例方法\n    return 'hello world';\n  }\n}\nclass Cat extends Animal{                 // 子类\n  constructor(name){\n    super(name);                          // 调用实现父类的构造函数\n    this.pName = name;            \n  }\n  sing(){\n \t return '吹呀吹呀，我的骄傲放纵~~';\n  }\n}\n```\n\n[1]: https://segmentfault.com/a/1190000015343232\n","slug":"js构造函数","published":1,"updated":"2018-10-09T09:20:11.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pv000d30ujalqhsmfp","content":"<p>前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法<a href=\"https://segmentfault.com/a/1190000015343232\" target=\"_blank\" rel=\"noopener\">js构造函数</a>，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~</p>\n<a id=\"more\"></a>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Persion</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;                         <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nameName</span>)</span>&#123;        <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = newName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Persion.prototype.sex = <span class=\"string\">'man'</span>;              <span class=\"comment\">// 向 Persion 原型中追加属性（原型方法）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> persion = <span class=\"keyword\">new</span> Persion(<span class=\"string\">'zhang'</span>);         <span class=\"comment\">// 此时我们实例化一个persion对象，看一下name和sex有什么区别</span></span><br></pre></td></tr></table></figure>\n<p>通过 prototype 添加的属性将出现在实例对象的原型链中，</p>\n<blockquote>\n<p>每个对象都会有一个内置 <strong>proto</strong> 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）</p>\n</blockquote>\n<p>我们再来看下面的例子</p>\n<blockquote>\n<p><strong>注意</strong>：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;                      <span class=\"comment\">// 声明一个构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;             \t\t\t\t\t    <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                          <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];               <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们看一下实例属性/方法 和 原型属性/方法的区别</p>\n<blockquote>\n<p>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);               <span class=\"comment\">// 实例化cat对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);\t             <span class=\"comment\">// 实例化狗子对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.say === dog.say                        <span class=\"comment\">// false 不同的实例拥有不同的实例属性/方法</span></span><br><span class=\"line\">cat.sing === dog.sing                      <span class=\"comment\">// true 不同的实例共享相同的原型属性/方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.arr.push(<span class=\"string\">'zz'</span>);                        <span class=\"comment\">// 向cat实例对象的arr中追加元素；（私有）</span></span><br><span class=\"line\">cat.pArr.push(<span class=\"string\">'xx'</span>);                       <span class=\"comment\">// 向cat原型对象的pArr中追加元素；（共享）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.arr);                      <span class=\"comment\">// 打印出 []，因为cat只改变了其私有的arr</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.pArr);                             <span class=\"comment\">// 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr</span></span><br></pre></td></tr></table></figure>\n<p>当然，原型属性为基本数据类型，则不会被共享<br>在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：<br>1、将属性封装在构造函数中<br>2、将方法定义在原型对象上</p>\n<h3 id=\"ES5继承方式\"><a href=\"#ES5继承方式\" class=\"headerlink\" title=\"ES5继承方式\"></a>ES5继承方式</h3><p>首先，我们定义一个Animal父类</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;          \t\t\t\t\t</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;                            <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                            <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                    <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;        <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];                 <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();                <span class=\"comment\">// 父类的实例作为子类的原型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；<br>缺点: 子类实例共享了父类构造函数的引用数据类型属性。</p>\n<h4 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);             <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                  <span class=\"comment\">// undefind 无法继承父类的原型属性及方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；<br>2、 创建子类实例，可以向父类构造函数传参数；<br>缺点: 子类实例不能继承父类的构造属性和方法；</p>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);              <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Parent()                  <span class=\"comment\">// 核心, 父类的实例作为子类的原型对象</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;              <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                       <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                   <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；<br>3、不共享父类的构造方法及属性；<br>缺点: 调用了2次父类的构造方法</p>\n<h4 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                       <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = Parent.prototype;                      <span class=\"comment\">// 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                       <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                            <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                              <span class=\"comment\">// 修改继承于父类原型属性值 pArr;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                               <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，</span></span><br><span class=\"line\"><span class=\"comment\">// 至此简直是完美呀~~~ 然鹅！</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                      <span class=\"comment\">// 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、子类的实例不共享父类的构造方法及属性；<br>3、只调用了1次父类的构造方法；<br>缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；</p>\n<h4 id=\"寄生组合继承（简直完美）\"><a href=\"#寄生组合继承（简直完美）\" class=\"headerlink\" title=\"寄生组合继承（简直完美）\"></a>寄生组合继承（简直完美）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                        <span class=\"comment\">// 核心，把父类的实例方法属性指向子类；</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;                                   <span class=\"comment\">// 核心，利用空对象作为中介；</span></span><br><span class=\"line\">F.prototype = Parent.prototype;                         <span class=\"comment\">// 核心，将父类的原型赋值给空对象F；</span></span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();                                <span class=\"comment\">// 核心，将F的实例赋值给子类；</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                        <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱；</span></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                 <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                             <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                               <span class=\"comment\">// 修改继承于父类原型属性值 pArr；</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                                <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                       <span class=\"comment\">// undefind  父类实例化的对象不拥有子类的原型属性/方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 完美实现继承；<br>缺点:实现相对复杂</p>\n<h4 id=\"附YUI库实现继承\"><a href=\"#附YUI库实现继承\" class=\"headerlink\" title=\"附YUI库实现继承\"></a>附YUI库实现继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">Child, Parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  F.prototype = Parent.prototype;</span><br><span class=\"line\">  hild.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  Child.prototype.constructor = Child;</span><br><span class=\"line\">  Child.uber = Parent.prototype;                          </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">extend(Cat,Animal);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Child.uber = Parent.prototype;</code> 的意思是为子对象设一个uber属性，这个属性直接指向父对象的<code>prototype</code>属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>\n</blockquote>\n<h3 id=\"ES6继承方式\"><a href=\"#ES6继承方式\" class=\"headerlink\" title=\"ES6继承方式\"></a>ES6继承方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;                             <span class=\"comment\">// 父类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;                      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  eat()&#123;                                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;                 <span class=\"comment\">// 子类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);                          <span class=\"comment\">// 调用实现父类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pName = name;            </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sing()&#123;</span><br><span class=\"line\"> \t <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法<a href=\"https://segmentfault.com/a/1190000015343232\" target=\"_blank\" rel=\"noopener\">js构造函数</a>，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~</p>","more":"<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Persion</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;                         <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nameName</span>)</span>&#123;        <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = newName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Persion.prototype.sex = <span class=\"string\">'man'</span>;              <span class=\"comment\">// 向 Persion 原型中追加属性（原型方法）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> persion = <span class=\"keyword\">new</span> Persion(<span class=\"string\">'zhang'</span>);         <span class=\"comment\">// 此时我们实例化一个persion对象，看一下name和sex有什么区别</span></span><br></pre></td></tr></table></figure>\n<p>通过 prototype 添加的属性将出现在实例对象的原型链中，</p>\n<blockquote>\n<p>每个对象都会有一个内置 <strong>proto</strong> 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）</p>\n</blockquote>\n<p>我们再来看下面的例子</p>\n<blockquote>\n<p><strong>注意</strong>：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;                      <span class=\"comment\">// 声明一个构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;             \t\t\t\t\t    <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                          <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];               <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们看一下实例属性/方法 和 原型属性/方法的区别</p>\n<blockquote>\n<p>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);               <span class=\"comment\">// 实例化cat对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);\t             <span class=\"comment\">// 实例化狗子对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.say === dog.say                        <span class=\"comment\">// false 不同的实例拥有不同的实例属性/方法</span></span><br><span class=\"line\">cat.sing === dog.sing                      <span class=\"comment\">// true 不同的实例共享相同的原型属性/方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.arr.push(<span class=\"string\">'zz'</span>);                        <span class=\"comment\">// 向cat实例对象的arr中追加元素；（私有）</span></span><br><span class=\"line\">cat.pArr.push(<span class=\"string\">'xx'</span>);                       <span class=\"comment\">// 向cat原型对象的pArr中追加元素；（共享）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.arr);                      <span class=\"comment\">// 打印出 []，因为cat只改变了其私有的arr</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.pArr);                             <span class=\"comment\">// 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr</span></span><br></pre></td></tr></table></figure>\n<p>当然，原型属性为基本数据类型，则不会被共享<br>在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：<br>1、将属性封装在构造函数中<br>2、将方法定义在原型对象上</p>\n<h3 id=\"ES5继承方式\"><a href=\"#ES5继承方式\" class=\"headerlink\" title=\"ES5继承方式\"></a>ES5继承方式</h3><p>首先，我们定义一个Animal父类</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;          \t\t\t\t\t</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;                            <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                            <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                    <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;        <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];                 <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();                <span class=\"comment\">// 父类的实例作为子类的原型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；<br>缺点: 子类实例共享了父类构造函数的引用数据类型属性。</p>\n<h4 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);             <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                  <span class=\"comment\">// undefind 无法继承父类的原型属性及方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；<br>2、 创建子类实例，可以向父类构造函数传参数；<br>缺点: 子类实例不能继承父类的构造属性和方法；</p>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);              <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Parent()                  <span class=\"comment\">// 核心, 父类的实例作为子类的原型对象</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;              <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                       <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                   <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；<br>3、不共享父类的构造方法及属性；<br>缺点: 调用了2次父类的构造方法</p>\n<h4 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                       <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = Parent.prototype;                      <span class=\"comment\">// 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                       <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                            <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                              <span class=\"comment\">// 修改继承于父类原型属性值 pArr;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                               <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，</span></span><br><span class=\"line\"><span class=\"comment\">// 至此简直是完美呀~~~ 然鹅！</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                      <span class=\"comment\">// 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、子类的实例不共享父类的构造方法及属性；<br>3、只调用了1次父类的构造方法；<br>缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；</p>\n<h4 id=\"寄生组合继承（简直完美）\"><a href=\"#寄生组合继承（简直完美）\" class=\"headerlink\" title=\"寄生组合继承（简直完美）\"></a>寄生组合继承（简直完美）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                        <span class=\"comment\">// 核心，把父类的实例方法属性指向子类；</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;                                   <span class=\"comment\">// 核心，利用空对象作为中介；</span></span><br><span class=\"line\">F.prototype = Parent.prototype;                         <span class=\"comment\">// 核心，将父类的原型赋值给空对象F；</span></span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();                                <span class=\"comment\">// 核心，将F的实例赋值给子类；</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                        <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱；</span></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                 <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                             <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                               <span class=\"comment\">// 修改继承于父类原型属性值 pArr；</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                                <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                       <span class=\"comment\">// undefind  父类实例化的对象不拥有子类的原型属性/方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 完美实现继承；<br>缺点:实现相对复杂</p>\n<h4 id=\"附YUI库实现继承\"><a href=\"#附YUI库实现继承\" class=\"headerlink\" title=\"附YUI库实现继承\"></a>附YUI库实现继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">Child, Parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  F.prototype = Parent.prototype;</span><br><span class=\"line\">  hild.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  Child.prototype.constructor = Child;</span><br><span class=\"line\">  Child.uber = Parent.prototype;                          </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">extend(Cat,Animal);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Child.uber = Parent.prototype;</code> 的意思是为子对象设一个uber属性，这个属性直接指向父对象的<code>prototype</code>属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>\n</blockquote>\n<h3 id=\"ES6继承方式\"><a href=\"#ES6继承方式\" class=\"headerlink\" title=\"ES6继承方式\"></a>ES6继承方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;                             <span class=\"comment\">// 父类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;                      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  eat()&#123;                                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;                 <span class=\"comment\">// 子类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);                          <span class=\"comment\">// 调用实现父类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pName = name;            </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sing()&#123;</span><br><span class=\"line\"> \t <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"监听浏览器刷新及关闭","date":"2018-12-12T02:37:25.000Z","comments":1,"toc":true,"_content":"\n需求背景： 为保证‘高度安全性’，用户每次退出页面或浏览器都要清除登陆信息，每次进入系统都要重新登陆（每次登陆还要手机验证码等乱七八糟的验证信息，，，求用户的心里阴影面积），但是刷新页面不可以清除登陆信息。\n解决思路： javascript 对于浏览器的关闭和刷新会触发两个事件 `onbeforeunload()`和`onunload()`，问题在于如何区分用户是想刷新还是退出（此时应该将用户催眠，然后获得用户的思想，预判用户走位及操作。。。），本文主要记录这两个方法的区别，设备兼容性及如何催眠用户（开玩笑的），是如何区分刷新和退出浏览器\n\n<!-- more -->\n\n### onbeforeunload()和onunload()\n\n>onbeforeunload 和 onunload 都是在页面刷新或退出时触发的事件\n\n用法：\n>|      事件      |                          用法                         |\n|----------------|-------------------------------------------------------|\n| onunload       | window.onunload=function(){SomeJavaScriptCode};       |\n| onbeforeunload | window.onbeforeunload=function(){SomeJavaScriptCode}; |\n\n区别：\n>1. `unbeforeunload()`是在页面刷新或关闭之前触发的事件，而`onubload()`是在页面刷新或关闭之后才会触发的。\n2. `unbeforeunload()`事件执行的顺序在`onunload()`事件之前发生。\n3. `unbeforeunload()`事件可以禁止`onunload()`事件的触发。\n4. `onunload()`事件是无法阻止页面关闭的。\n\n兼容性（pc）：\n\n>|      事件      |      Chrome     |     Firefox     |        IE       |      Opera      | Safari |\n|----------------|:---------------:|:---------------:|:---------------:|:---------------:|:------:|\n| onunload       | yes&nbsp;&nbsp; | yes&nbsp;&nbsp; | yes&nbsp;&nbsp; | yes&nbsp;&nbsp; | yes    |\n| onbeforeunload | 1               | 1               | 4               | 12              | 3      |\nonbeforeunoad 在移动端基本都不兼容，onunload则兼容大部分主流移动端浏览器\n\n>参考文献：\nMDN: [window.onbeforeunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload)\nMDN: [window.onunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload)\n\n### 区分刷新和退出\n\n>在浏览器关闭前是无法判断用户是刷新还是退出，所以我们在用户再次打开的时候来判断用户是否刷新\n\n>解决思路：\n1. 用户关闭浏览器时，记录当前时间，并存于浏览器缓存中\n2. 用户再次打开页面时，获取上次退出的时间，并于当前时间进行比较，若小于5s则表示用户执行的是刷新操作，若大于5s则判定为退出\n\n>注意： 5s并非固定，要根据实际情况调整\n\n上代码：\n\n```js\n// 进入页面执行\n// 记录当前时间并转成时间戳\nconst now = new Date().getTime();\n// 从缓存中获取用户上次退出的时间戳\nconst leaveTime = parseInt(localStorage.getItem('leaveTime'), 10);\n// 判断是否为刷新，两次间隔在5s内判定为刷新操作\nconst refresh = (now - leaveTime) <= 5000;\n// 测试alert\nalert(refresh ? '刷新' : '重新登陆');\n\n// 退出当前页面执行\nwindow.onunload = function(e){ // ios 不支持 window.onbeforeunload()\n  // 将退出时间存于localstorage中\n  localStorage.setItem('leaveTime', new Date().getTime());\n}\n```","source":"_posts/监听浏览器刷新及关闭.md","raw":"---\ntitle: 监听浏览器刷新及关闭\ndate: 2018-12-12 10:37:25\ncomments: true\ntoc: true\ncategories: '随笔'\ntags: \n\t- js\n\t- 前端\n---\n\n需求背景： 为保证‘高度安全性’，用户每次退出页面或浏览器都要清除登陆信息，每次进入系统都要重新登陆（每次登陆还要手机验证码等乱七八糟的验证信息，，，求用户的心里阴影面积），但是刷新页面不可以清除登陆信息。\n解决思路： javascript 对于浏览器的关闭和刷新会触发两个事件 `onbeforeunload()`和`onunload()`，问题在于如何区分用户是想刷新还是退出（此时应该将用户催眠，然后获得用户的思想，预判用户走位及操作。。。），本文主要记录这两个方法的区别，设备兼容性及如何催眠用户（开玩笑的），是如何区分刷新和退出浏览器\n\n<!-- more -->\n\n### onbeforeunload()和onunload()\n\n>onbeforeunload 和 onunload 都是在页面刷新或退出时触发的事件\n\n用法：\n>|      事件      |                          用法                         |\n|----------------|-------------------------------------------------------|\n| onunload       | window.onunload=function(){SomeJavaScriptCode};       |\n| onbeforeunload | window.onbeforeunload=function(){SomeJavaScriptCode}; |\n\n区别：\n>1. `unbeforeunload()`是在页面刷新或关闭之前触发的事件，而`onubload()`是在页面刷新或关闭之后才会触发的。\n2. `unbeforeunload()`事件执行的顺序在`onunload()`事件之前发生。\n3. `unbeforeunload()`事件可以禁止`onunload()`事件的触发。\n4. `onunload()`事件是无法阻止页面关闭的。\n\n兼容性（pc）：\n\n>|      事件      |      Chrome     |     Firefox     |        IE       |      Opera      | Safari |\n|----------------|:---------------:|:---------------:|:---------------:|:---------------:|:------:|\n| onunload       | yes&nbsp;&nbsp; | yes&nbsp;&nbsp; | yes&nbsp;&nbsp; | yes&nbsp;&nbsp; | yes    |\n| onbeforeunload | 1               | 1               | 4               | 12              | 3      |\nonbeforeunoad 在移动端基本都不兼容，onunload则兼容大部分主流移动端浏览器\n\n>参考文献：\nMDN: [window.onbeforeunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload)\nMDN: [window.onunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload)\n\n### 区分刷新和退出\n\n>在浏览器关闭前是无法判断用户是刷新还是退出，所以我们在用户再次打开的时候来判断用户是否刷新\n\n>解决思路：\n1. 用户关闭浏览器时，记录当前时间，并存于浏览器缓存中\n2. 用户再次打开页面时，获取上次退出的时间，并于当前时间进行比较，若小于5s则表示用户执行的是刷新操作，若大于5s则判定为退出\n\n>注意： 5s并非固定，要根据实际情况调整\n\n上代码：\n\n```js\n// 进入页面执行\n// 记录当前时间并转成时间戳\nconst now = new Date().getTime();\n// 从缓存中获取用户上次退出的时间戳\nconst leaveTime = parseInt(localStorage.getItem('leaveTime'), 10);\n// 判断是否为刷新，两次间隔在5s内判定为刷新操作\nconst refresh = (now - leaveTime) <= 5000;\n// 测试alert\nalert(refresh ? '刷新' : '重新登陆');\n\n// 退出当前页面执行\nwindow.onunload = function(e){ // ios 不支持 window.onbeforeunload()\n  // 将退出时间存于localstorage中\n  localStorage.setItem('leaveTime', new Date().getTime());\n}\n```","slug":"监听浏览器刷新及关闭","published":1,"updated":"2018-12-21T02:57:41.986Z","layout":"post","photos":[],"link":"","_id":"cjpy1k4px000e30uj4h22rdss","content":"<p>需求背景： 为保证‘高度安全性’，用户每次退出页面或浏览器都要清除登陆信息，每次进入系统都要重新登陆（每次登陆还要手机验证码等乱七八糟的验证信息，，，求用户的心里阴影面积），但是刷新页面不可以清除登陆信息。<br>解决思路： javascript 对于浏览器的关闭和刷新会触发两个事件 <code>onbeforeunload()</code>和<code>onunload()</code>，问题在于如何区分用户是想刷新还是退出（此时应该将用户催眠，然后获得用户的思想，预判用户走位及操作。。。），本文主要记录这两个方法的区别，设备兼容性及如何催眠用户（开玩笑的），是如何区分刷新和退出浏览器</p>\n<a id=\"more\"></a>\n<h3 id=\"onbeforeunload-和onunload\"><a href=\"#onbeforeunload-和onunload\" class=\"headerlink\" title=\"onbeforeunload()和onunload()\"></a>onbeforeunload()和onunload()</h3><blockquote>\n<p>onbeforeunload 和 onunload 都是在页面刷新或退出时触发的事件</p>\n</blockquote>\n<p>用法：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onunload</td>\n<td>window.onunload=function(){SomeJavaScriptCode};</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td>window.onbeforeunload=function(){SomeJavaScriptCode};</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p>区别：</p>\n<blockquote>\n<ol>\n<li><code>unbeforeunload()</code>是在页面刷新或关闭之前触发的事件，而<code>onubload()</code>是在页面刷新或关闭之后才会触发的。</li>\n<li><code>unbeforeunload()</code>事件执行的顺序在<code>onunload()</code>事件之前发生。</li>\n<li><code>unbeforeunload()</code>事件可以禁止<code>onunload()</code>事件的触发。</li>\n<li><code>onunload()</code>事件是无法阻止页面关闭的。</li>\n</ol>\n</blockquote>\n<p>兼容性（pc）：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th style=\"text-align:center\">Chrome</th>\n<th style=\"text-align:center\">Firefox</th>\n<th style=\"text-align:center\">IE</th>\n<th style=\"text-align:center\">Opera</th>\n<th style=\"text-align:center\">Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onunload</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<p>onbeforeunoad 在移动端基本都不兼容，onunload则兼容大部分主流移动端浏览器</p>\n</blockquote>\n<blockquote>\n<p>参考文献：<br>MDN: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload\" target=\"_blank\" rel=\"noopener\">window.onbeforeunload</a><br>MDN: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload\" target=\"_blank\" rel=\"noopener\">window.onunload</a></p>\n</blockquote>\n<h3 id=\"区分刷新和退出\"><a href=\"#区分刷新和退出\" class=\"headerlink\" title=\"区分刷新和退出\"></a>区分刷新和退出</h3><blockquote>\n<p>在浏览器关闭前是无法判断用户是刷新还是退出，所以我们在用户再次打开的时候来判断用户是否刷新</p>\n</blockquote>\n<blockquote>\n<p>解决思路：</p>\n<ol>\n<li>用户关闭浏览器时，记录当前时间，并存于浏览器缓存中</li>\n<li>用户再次打开页面时，获取上次退出的时间，并于当前时间进行比较，若小于5s则表示用户执行的是刷新操作，若大于5s则判定为退出</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意： 5s并非固定，要根据实际情况调整</p>\n</blockquote>\n<p>上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 进入页面执行</span></span><br><span class=\"line\"><span class=\"comment\">// 记录当前时间并转成时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\"><span class=\"comment\">// 从缓存中获取用户上次退出的时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> leaveTime = <span class=\"built_in\">parseInt</span>(localStorage.getItem(<span class=\"string\">'leaveTime'</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 判断是否为刷新，两次间隔在5s内判定为刷新操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> refresh = (now - leaveTime) &lt;= <span class=\"number\">5000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 测试alert</span></span><br><span class=\"line\">alert(refresh ? <span class=\"string\">'刷新'</span> : <span class=\"string\">'重新登陆'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 退出当前页面执行</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onunload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123; <span class=\"comment\">// ios 不支持 window.onbeforeunload()</span></span><br><span class=\"line\">  <span class=\"comment\">// 将退出时间存于localstorage中</span></span><br><span class=\"line\">  localStorage.setItem(<span class=\"string\">'leaveTime'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>需求背景： 为保证‘高度安全性’，用户每次退出页面或浏览器都要清除登陆信息，每次进入系统都要重新登陆（每次登陆还要手机验证码等乱七八糟的验证信息，，，求用户的心里阴影面积），但是刷新页面不可以清除登陆信息。<br>解决思路： javascript 对于浏览器的关闭和刷新会触发两个事件 <code>onbeforeunload()</code>和<code>onunload()</code>，问题在于如何区分用户是想刷新还是退出（此时应该将用户催眠，然后获得用户的思想，预判用户走位及操作。。。），本文主要记录这两个方法的区别，设备兼容性及如何催眠用户（开玩笑的），是如何区分刷新和退出浏览器</p>","more":"<h3 id=\"onbeforeunload-和onunload\"><a href=\"#onbeforeunload-和onunload\" class=\"headerlink\" title=\"onbeforeunload()和onunload()\"></a>onbeforeunload()和onunload()</h3><blockquote>\n<p>onbeforeunload 和 onunload 都是在页面刷新或退出时触发的事件</p>\n</blockquote>\n<p>用法：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onunload</td>\n<td>window.onunload=function(){SomeJavaScriptCode};</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td>window.onbeforeunload=function(){SomeJavaScriptCode};</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p>区别：</p>\n<blockquote>\n<ol>\n<li><code>unbeforeunload()</code>是在页面刷新或关闭之前触发的事件，而<code>onubload()</code>是在页面刷新或关闭之后才会触发的。</li>\n<li><code>unbeforeunload()</code>事件执行的顺序在<code>onunload()</code>事件之前发生。</li>\n<li><code>unbeforeunload()</code>事件可以禁止<code>onunload()</code>事件的触发。</li>\n<li><code>onunload()</code>事件是无法阻止页面关闭的。</li>\n</ol>\n</blockquote>\n<p>兼容性（pc）：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th style=\"text-align:center\">Chrome</th>\n<th style=\"text-align:center\">Firefox</th>\n<th style=\"text-align:center\">IE</th>\n<th style=\"text-align:center\">Opera</th>\n<th style=\"text-align:center\">Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onunload</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes&nbsp;&nbsp;</td>\n<td style=\"text-align:center\">yes</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<p>onbeforeunoad 在移动端基本都不兼容，onunload则兼容大部分主流移动端浏览器</p>\n</blockquote>\n<blockquote>\n<p>参考文献：<br>MDN: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload\" target=\"_blank\" rel=\"noopener\">window.onbeforeunload</a><br>MDN: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload\" target=\"_blank\" rel=\"noopener\">window.onunload</a></p>\n</blockquote>\n<h3 id=\"区分刷新和退出\"><a href=\"#区分刷新和退出\" class=\"headerlink\" title=\"区分刷新和退出\"></a>区分刷新和退出</h3><blockquote>\n<p>在浏览器关闭前是无法判断用户是刷新还是退出，所以我们在用户再次打开的时候来判断用户是否刷新</p>\n</blockquote>\n<blockquote>\n<p>解决思路：</p>\n<ol>\n<li>用户关闭浏览器时，记录当前时间，并存于浏览器缓存中</li>\n<li>用户再次打开页面时，获取上次退出的时间，并于当前时间进行比较，若小于5s则表示用户执行的是刷新操作，若大于5s则判定为退出</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意： 5s并非固定，要根据实际情况调整</p>\n</blockquote>\n<p>上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 进入页面执行</span></span><br><span class=\"line\"><span class=\"comment\">// 记录当前时间并转成时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\"><span class=\"comment\">// 从缓存中获取用户上次退出的时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> leaveTime = <span class=\"built_in\">parseInt</span>(localStorage.getItem(<span class=\"string\">'leaveTime'</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 判断是否为刷新，两次间隔在5s内判定为刷新操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> refresh = (now - leaveTime) &lt;= <span class=\"number\">5000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 测试alert</span></span><br><span class=\"line\">alert(refresh ? <span class=\"string\">'刷新'</span> : <span class=\"string\">'重新登陆'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 退出当前页面执行</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onunload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123; <span class=\"comment\">// ios 不支持 window.onbeforeunload()</span></span><br><span class=\"line\">  <span class=\"comment\">// 将退出时间存于localstorage中</span></span><br><span class=\"line\">  localStorage.setItem(<span class=\"string\">'leaveTime'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"给Hexo博客添加访问统计","date":"2018-03-20T08:35:58.000Z","thumbnail":"/bolg/2018/09/27/给Hexo博客添加访问统计/bsz.jpg","_content":"导语： 引入不蒜子为你的博客添加访问量\n<!--more-->\n### 引入不蒜子\n``` bash\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里\n\n### 添加站点访问量\n通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：\n``` bash\n<span id=\"busuanzi_container_site_uv\"> \n  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n</span>\n```\n计算访问量的方法有两种：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n我用的是uv的方式，大家自行选择即可。\n\n### 添加文章访问量\n文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：\n``` bash\n<span id=\"busuanzi_container_page_pv\">\n   本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n</span>\n```\n\n### 注意\n由于原有的『dn-lbstatics.qbox.me』域名过期，需把原有的：\n``` js\n<script async src=\"\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"></script>\n```\n域名改为：\n``` js\n<script async src=\"\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"></script>\n```\n\n参考 : [不蒜子](http://busuanzi.ibruce.info/)\n","source":"_posts/给Hexo博客添加访问统计.md","raw":"---\ntitle: 给Hexo博客添加访问统计\ndate: 2018-03-20 16:35:58\ncategories: 工具\ntags: hexo\nthumbnail: /bolg/2018/09/27/给Hexo博客添加访问统计/bsz.jpg\n---\n导语： 引入不蒜子为你的博客添加访问量\n<!--more-->\n### 引入不蒜子\n``` bash\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里\n\n### 添加站点访问量\n通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：\n``` bash\n<span id=\"busuanzi_container_site_uv\"> \n  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n</span>\n```\n计算访问量的方法有两种：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n我用的是uv的方式，大家自行选择即可。\n\n### 添加文章访问量\n文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：\n``` bash\n<span id=\"busuanzi_container_page_pv\">\n   本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n</span>\n```\n\n### 注意\n由于原有的『dn-lbstatics.qbox.me』域名过期，需把原有的：\n``` js\n<script async src=\"\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"></script>\n```\n域名改为：\n``` js\n<script async src=\"\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"></script>\n```\n\n参考 : [不蒜子](http://busuanzi.ibruce.info/)\n","slug":"给Hexo博客添加访问统计","published":1,"updated":"2018-11-30T01:13:34.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4py000f30ujmlvzcjbn","content":"<p>导语： 引入不蒜子为你的博客添加访问量<br><a id=\"more\"></a></p>\n<h3 id=\"引入不蒜子\"><a href=\"#引入不蒜子\" class=\"headerlink\" title=\"引入不蒜子\"></a>引入不蒜子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=<span class=\"string\">\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里</p>\n<h3 id=\"添加站点访问量\"><a href=\"#添加站点访问量\" class=\"headerlink\" title=\"添加站点访问量\"></a>添加站点访问量</h3><p>通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_site_uv\"</span>&gt; </span><br><span class=\"line\">  本站访客数&lt;span id=<span class=\"string\">\"busuanzi_value_site_uv\"</span>&gt;&lt;/span&gt;人次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>计算访问量的方法有两种：<br>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。<br>我用的是uv的方式，大家自行选择即可。</p>\n<h3 id=\"添加文章访问量\"><a href=\"#添加文章访问量\" class=\"headerlink\" title=\"添加文章访问量\"></a>添加文章访问量</h3><p>文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_page_pv\"</span>&gt;</span><br><span class=\"line\">   本文总阅读量&lt;span id=<span class=\"string\">\"busuanzi_value_page_pv\"</span>&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>由于原有的『dn-lbstatics.qbox.me』域名过期，需把原有的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>域名改为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参考 : <a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子</a></p>\n","site":{"data":{}},"excerpt":"<p>导语： 引入不蒜子为你的博客添加访问量<br></p>","more":"<p></p>\n<h3 id=\"引入不蒜子\"><a href=\"#引入不蒜子\" class=\"headerlink\" title=\"引入不蒜子\"></a>引入不蒜子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=<span class=\"string\">\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里</p>\n<h3 id=\"添加站点访问量\"><a href=\"#添加站点访问量\" class=\"headerlink\" title=\"添加站点访问量\"></a>添加站点访问量</h3><p>通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_site_uv\"</span>&gt; </span><br><span class=\"line\">  本站访客数&lt;span id=<span class=\"string\">\"busuanzi_value_site_uv\"</span>&gt;&lt;/span&gt;人次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>计算访问量的方法有两种：<br>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。<br>我用的是uv的方式，大家自行选择即可。</p>\n<h3 id=\"添加文章访问量\"><a href=\"#添加文章访问量\" class=\"headerlink\" title=\"添加文章访问量\"></a>添加文章访问量</h3><p>文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_page_pv\"</span>&gt;</span><br><span class=\"line\">   本文总阅读量&lt;span id=<span class=\"string\">\"busuanzi_value_page_pv\"</span>&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>由于原有的『dn-lbstatics.qbox.me』域名过期，需把原有的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>域名改为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">\"\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参考 : <a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子</a></p>"},{"title":"递归尾调用优化","date":"2018-04-08T09:19:48.000Z","banner":"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg","_content":"\n>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误...\n\n<!-- more -->\n\n### 什么是尾调用？\n\n>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n\n``` bash\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数`f`的最后一步是调用函数`g`，这就叫尾调用。\n以下三种情况，都不属于尾调用。\n\n``` bash\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n上面代码中\n情况一: 是调用函数`g`之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;\n情况二: 属于调用后还有操作，即使写在一行内;\n情况三: 等同于下面的代码;\n\n``` bash\nfunction f(x){\n  g(x);\n  return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n``` bash\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数`m`和`n`都属于尾调用，因为它们都是函数`f`的最后一步操作。\n\n### 尾调用优化\n\n>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n``` bash\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数g不是尾调用，函数`f`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息。但由于调用`g`之后，函数`f`就结束了，所以执行到最后一步，完全可以删除`f(x)`的调用帧，只保留`g(3)`的调用帧。\n\n>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n``` bash\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n```\n\n上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。\n\n\n### 尾递归\n\n>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n``` bash\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n```\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n``` bash\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n```\n\n还有一个比较著名的例子，就是计算 `Fibonacci` 数列，也能充分说明尾递归优化的重要性。\n非尾递归的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10)  // 89\nFibonacci(100) // 堆栈溢出\nFibonacci(500) // 堆栈溢出\n```\n\n尾递归优化过的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100)   // 573147844013817200000\nFibonacci2(1000)  // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n附： 循环版\n\n``` bash\nfunction Fibonacci3(n){\n    if (n===1 || n===2) {\n        return 1;\n    }\n    let ac1 = 1, ac2 = 1;\n    for (let i = 2; i < n; i++){\n        [ac1, ac2] = [ac2, ac1 + ac2];\n    }\n    return ac2;\n}\n```\n\n>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n参考文献：[ECMAScript 6 入门 - 阮一峰][1]\n[1]:http://es6.ruanyifeng.com/\n","source":"_posts/递归尾调用优化.md","raw":"---\ntitle: '递归尾调用优化'\ndate: 2018-04-08 17:19:48\nbanner: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg\ncategories: '笔记'\ntags:\n\t- js\n\t- 算法\n\t- ES6\n\t- 前端\n---\n\n>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误...\n\n<!-- more -->\n\n### 什么是尾调用？\n\n>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n\n``` bash\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数`f`的最后一步是调用函数`g`，这就叫尾调用。\n以下三种情况，都不属于尾调用。\n\n``` bash\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n上面代码中\n情况一: 是调用函数`g`之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;\n情况二: 属于调用后还有操作，即使写在一行内;\n情况三: 等同于下面的代码;\n\n``` bash\nfunction f(x){\n  g(x);\n  return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n``` bash\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数`m`和`n`都属于尾调用，因为它们都是函数`f`的最后一步操作。\n\n### 尾调用优化\n\n>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n``` bash\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数g不是尾调用，函数`f`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息。但由于调用`g`之后，函数`f`就结束了，所以执行到最后一步，完全可以删除`f(x)`的调用帧，只保留`g(3)`的调用帧。\n\n>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n``` bash\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n```\n\n上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。\n\n\n### 尾递归\n\n>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n``` bash\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n```\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n``` bash\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n```\n\n还有一个比较著名的例子，就是计算 `Fibonacci` 数列，也能充分说明尾递归优化的重要性。\n非尾递归的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10)  // 89\nFibonacci(100) // 堆栈溢出\nFibonacci(500) // 堆栈溢出\n```\n\n尾递归优化过的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100)   // 573147844013817200000\nFibonacci2(1000)  // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n附： 循环版\n\n``` bash\nfunction Fibonacci3(n){\n    if (n===1 || n===2) {\n        return 1;\n    }\n    let ac1 = 1, ac2 = 1;\n    for (let i = 2; i < n; i++){\n        [ac1, ac2] = [ac2, ac1 + ac2];\n    }\n    return ac2;\n}\n```\n\n>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n参考文献：[ECMAScript 6 入门 - 阮一峰][1]\n[1]:http://es6.ruanyifeng.com/\n","slug":"递归尾调用优化","published":1,"updated":"2018-11-30T01:14:03.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pz000g30ujcyws3t0m","content":"<blockquote>\n<p>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误…</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h3><blockquote>\n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。<br>以下三种情况，都不属于尾调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 情况一</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况二</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x) + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况三</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中<br>情况一: 是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;<br>情况二: 属于调用后还有操作，即使写在一行内;<br>情况三: 等同于下面的代码;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; 0) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>\n<h3 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><blockquote>\n<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n</blockquote>\n<blockquote>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> m = 1;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> n = 2;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">g(3);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果函数g不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>\n<blockquote>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n</blockquote>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addOne(a)&#123;</span><br><span class=\"line\">  var one = 1;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> inner(b)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> b + one;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> inner(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><blockquote>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n</blockquote>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n * factorial(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5) // 120</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n, total) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> total;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> factorial(n - 1, n * total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure>\n<p>还有一个比较著名的例子，就是计算 <code>Fibonacci</code> 数列，也能充分说明尾递归优化的重要性。<br>非尾递归的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci (n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> 1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci(10)  // 89</span><br><span class=\"line\">Fibonacci(100) // 堆栈溢出</span><br><span class=\"line\">Fibonacci(500) // 堆栈溢出</span><br></pre></td></tr></table></figure>\n<p>尾递归优化过的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> ac2&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci2(100)   // 573147844013817200000</span><br><span class=\"line\">Fibonacci2(1000)  // 7.0330367711422765e+208</span><br><span class=\"line\">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure>\n<p>附： 循环版</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci3(n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n===1 || n===2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> ac1 = 1, ac2 = 1;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 2; i &lt; n; i++)&#123;</span><br><span class=\"line\">        [ac1, ac2] = [ac2, ac1 + ac2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> ac2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n</blockquote>\n<p>参考文献：[ECMAScript 6 入门 - 阮一峰][1]<br>[1]:<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误…</p>\n</blockquote>","more":"<h3 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h3><blockquote>\n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。<br>以下三种情况，都不属于尾调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 情况一</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况二</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x) + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况三</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中<br>情况一: 是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;<br>情况二: 属于调用后还有操作，即使写在一行内;<br>情况三: 等同于下面的代码;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; 0) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>\n<h3 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><blockquote>\n<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n</blockquote>\n<blockquote>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> m = 1;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> n = 2;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">g(3);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果函数g不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>\n<blockquote>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n</blockquote>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addOne(a)&#123;</span><br><span class=\"line\">  var one = 1;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> inner(b)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> b + one;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> inner(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><blockquote>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n</blockquote>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n * factorial(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5) // 120</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n, total) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> total;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> factorial(n - 1, n * total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure>\n<p>还有一个比较著名的例子，就是计算 <code>Fibonacci</code> 数列，也能充分说明尾递归优化的重要性。<br>非尾递归的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci (n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> 1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci(10)  // 89</span><br><span class=\"line\">Fibonacci(100) // 堆栈溢出</span><br><span class=\"line\">Fibonacci(500) // 堆栈溢出</span><br></pre></td></tr></table></figure>\n<p>尾递归优化过的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> ac2&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci2(100)   // 573147844013817200000</span><br><span class=\"line\">Fibonacci2(1000)  // 7.0330367711422765e+208</span><br><span class=\"line\">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure>\n<p>附： 循环版</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci3(n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n===1 || n===2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> ac1 = 1, ac2 = 1;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 2; i &lt; n; i++)&#123;</span><br><span class=\"line\">        [ac1, ac2] = [ac2, ac1 + ac2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> ac2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n</blockquote>\n<p>参考文献：[ECMAScript 6 入门 - 阮一峰][1]<br>[1]:<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a></p>"},{"title":"递归树结构解析","date":"2018-04-08T03:40:07.000Z","banner":"/bolg/2018/04/08/递归树结构解析/banner.jpg","_content":"\n用递归的方式将树结构从根到叶子节点解析成数组\n<!-- more -->\n\n从后台获取树结构的 json 数据，渲染成树图结构\n由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组\n算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看\n\n``` bash\n数据结构如下：                  目标数组如下：         \n     a                       \n    / \\                      1) [a, b, c]\n   b   e         ==>>        2) [a, b, d]\n  / \\   \\                    3) [a, e, f]\n c   d   f     \n```\n\n``` bash\nconst obj = {\n  val: 'a',\n  children: [\n    { val: 'b', children: [\n        { val: 'c', children: [] },\n        { val: 'd', children: [] },\n      ],\n    },\n    { val: 'e', children: [\n        { val: 'f', }\n      ],\n    },\n  ],\n};\n```\n\n废话不多说，直接上代码\n``` bash\n// 法一\nconst initArr = (obj) => {\n  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果\n  (function travel(item, arr){                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组\n    if (item.children && item.children.length) {            // 判断是否存在子元素，存在则遍历子元素递归调用\n      for (let i = 0; i < item.children.length; i += 1) {\n        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度\n      }\n    } else {                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中\n      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中\n    }\n  }(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空\n  return newArr;\n}\n```\n\n``` bash\n// 法二\nconst initArr = (obj) => {\n  const newArr = [];\n  (function travel(item, arr){\n    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染\n    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可\n    if (item.children && item.children.length) {\n      for (let i in item.children) {\n        travel(data.children[i], itemArr);\n      }\n    } else {\n      newArr.push(itemArr);\n    }\n  })(obj, [])\n  return newArr;\n}\n```\n\n`\n结果如下图\n`\n![递归解析树结构](递归树结构解析/result.jpg)\n\n","source":"_posts/递归树结构解析.md","raw":"---\ntitle: '递归树结构解析'\ndate: 2018-04-08 11:40:07\ncategories: \"笔记\"\ntags: [js, 算法, 前端]\nbanner: /bolg/2018/04/08/递归树结构解析/banner.jpg\n---\n\n用递归的方式将树结构从根到叶子节点解析成数组\n<!-- more -->\n\n从后台获取树结构的 json 数据，渲染成树图结构\n由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组\n算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看\n\n``` bash\n数据结构如下：                  目标数组如下：         \n     a                       \n    / \\                      1) [a, b, c]\n   b   e         ==>>        2) [a, b, d]\n  / \\   \\                    3) [a, e, f]\n c   d   f     \n```\n\n``` bash\nconst obj = {\n  val: 'a',\n  children: [\n    { val: 'b', children: [\n        { val: 'c', children: [] },\n        { val: 'd', children: [] },\n      ],\n    },\n    { val: 'e', children: [\n        { val: 'f', }\n      ],\n    },\n  ],\n};\n```\n\n废话不多说，直接上代码\n``` bash\n// 法一\nconst initArr = (obj) => {\n  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果\n  (function travel(item, arr){                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组\n    if (item.children && item.children.length) {            // 判断是否存在子元素，存在则遍历子元素递归调用\n      for (let i = 0; i < item.children.length; i += 1) {\n        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度\n      }\n    } else {                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中\n      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中\n    }\n  }(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空\n  return newArr;\n}\n```\n\n``` bash\n// 法二\nconst initArr = (obj) => {\n  const newArr = [];\n  (function travel(item, arr){\n    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染\n    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可\n    if (item.children && item.children.length) {\n      for (let i in item.children) {\n        travel(data.children[i], itemArr);\n      }\n    } else {\n      newArr.push(itemArr);\n    }\n  })(obj, [])\n  return newArr;\n}\n```\n\n`\n结果如下图\n`\n![递归解析树结构](递归树结构解析/result.jpg)\n\n","slug":"递归树结构解析","published":1,"updated":"2018-12-06T02:52:35.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpy1k4pz000h30ujbalq2gmo","content":"<p>用递归的方式将树结构从根到叶子节点解析成数组<br><a id=\"more\"></a></p>\n<p>从后台获取树结构的 json 数据，渲染成树图结构<br>由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组<br>算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据结构如下：                  目标数组如下：         </span><br><span class=\"line\">     a                       </span><br><span class=\"line\">    / \\                      1) [a, b, c]</span><br><span class=\"line\">   b   e         ==&gt;&gt;        2) [a, b, d]</span><br><span class=\"line\">  / \\   \\                    3) [a, e, f]</span><br><span class=\"line\"> c   d   f</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">  val: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  children: [</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'b'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'c'</span>, children: [] &#125;,</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'d'</span>, children: [] &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'e'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'f'</span>, &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>废话不多说，直接上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法一</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;            // 判断是否存在子元素，存在则遍历子元素递归调用</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 0; i &lt; item.children.length; i += 1) &#123;</span><br><span class=\"line\">        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中</span><br><span class=\"line\">      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法二</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;</span><br><span class=\"line\">    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染</span><br><span class=\"line\">    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i <span class=\"keyword\">in</span> item.children) &#123;</span><br><span class=\"line\">        travel(data.children[i], itemArr);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newArr.push(itemArr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(obj, [])</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>结果如下图</code><br><img src=\"/blog/2018/04/08/递归树结构解析/result.jpg\" alt=\"递归解析树结构\"></p>\n","site":{"data":{}},"excerpt":"<p>用递归的方式将树结构从根到叶子节点解析成数组<br></p>","more":"<p></p>\n<p>从后台获取树结构的 json 数据，渲染成树图结构<br>由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组<br>算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据结构如下：                  目标数组如下：         </span><br><span class=\"line\">     a                       </span><br><span class=\"line\">    / \\                      1) [a, b, c]</span><br><span class=\"line\">   b   e         ==&gt;&gt;        2) [a, b, d]</span><br><span class=\"line\">  / \\   \\                    3) [a, e, f]</span><br><span class=\"line\"> c   d   f</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">  val: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  children: [</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'b'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'c'</span>, children: [] &#125;,</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'d'</span>, children: [] &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'e'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'f'</span>, &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>废话不多说，直接上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法一</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;            // 判断是否存在子元素，存在则遍历子元素递归调用</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 0; i &lt; item.children.length; i += 1) &#123;</span><br><span class=\"line\">        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中</span><br><span class=\"line\">      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法二</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;</span><br><span class=\"line\">    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染</span><br><span class=\"line\">    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i <span class=\"keyword\">in</span> item.children) &#123;</span><br><span class=\"line\">        travel(data.children[i], itemArr);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newArr.push(itemArr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(obj, [])</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>结果如下图</code><br><img src=\"/blog/2018/04/08/递归树结构解析/result.jpg\" alt=\"递归解析树结构\"></p>"}],"PostAsset":[{"_id":"source/_posts/GITduozhanghu/git_1.jpg","post":"cjpy1k4pf000130uj0w32y5gp","slug":"git_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/HTTP状态码和AJAX状态值/http.jpg","post":"cjpy1k4pk000330ujn6ugv6ls","slug":"http.jpg","modified":1,"renderable":1},{"_id":"source/_posts/RISE/banner.jpg","post":"cjpy1k4po000830ujzinapmm8","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/js构造函数/banner.jpg","post":"cjpy1k4pv000d30ujalqhsmfp","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/js构造函数/slt.jpg","post":"cjpy1k4pv000d30ujalqhsmfp","slug":"slt.jpg","modified":1,"renderable":1},{"_id":"source/_posts/给Hexo博客添加访问统计/bsz.jpg","post":"cjpy1k4py000f30ujmlvzcjbn","slug":"bsz.jpg","modified":1,"renderable":1},{"_id":"source/_posts/给Hexo博客添加访问统计/timg.jpg","post":"cjpy1k4py000f30ujmlvzcjbn","slug":"timg.jpg","modified":1,"renderable":1},{"_id":"source/_posts/递归树结构解析/banner.jpg","post":"cjpy1k4pz000h30ujbalq2gmo","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/递归树结构解析/result.jpg","post":"cjpy1k4pz000h30ujbalq2gmo","slug":"result.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/banner.jpg","post":"cjpy1k4pr000a30ujpswrp2tc","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/lujing.jpg","post":"cjpy1k4pr000a30ujpswrp2tc","slug":"lujing.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/lujing2.jpg","post":"cjpy1k4pr000a30ujpswrp2tc","slug":"lujing2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/suoluetu.png","post":"cjpy1k4pr000a30ujpswrp2tc","slug":"suoluetu.png","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/wenjian.jpg","post":"cjpy1k4pr000a30ujpswrp2tc","slug":"wenjian.jpg","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jdk-1.png","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jdk-1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jdk-2.png","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jdk-2.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jdk-3.png","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jdk-3.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jdk.png","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jdk.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jenkins-1.jpg","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jenkins-1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jenkins-2.jpg","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jenkins-2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jenkins-3.jpg","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jenkins-3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jenkins-4.jpg","post":"cjpy1k4pu000c30ujzaz5zfoc","slug":"jenkins-4.jpg","modified":1,"renderable":1},{"_id":"source/_posts/jenkins部署个人博客/jenkins.png","slug":"jenkins.png","post":"cjpy1k4pu000c30ujzaz5zfoc","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cjpy1k4pf000130uj0w32y5gp","category_id":"cjpy1k4rf000i30ujq3u53ogf","_id":"cjpy1k4t6001u30uj5vinsbje"},{"post_id":"cjpy1k4pk000330ujn6ugv6ls","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4t7001w30ujc34u7fzi"},{"post_id":"cjpy1k4pm000530uj1p201td8","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4t7001y30ujq08ma41s"},{"post_id":"cjpy1k4pn000730uji4xkn7c4","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4t8002030ujba2cuni5"},{"post_id":"cjpy1k4po000830ujzinapmm8","category_id":"cjpy1k4rv000q30ujt11sz97j","_id":"cjpy1k4t9002230uj98jqddtv"},{"post_id":"cjpy1k4pq000930ujt91coaiz","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4t9002430ujkf4igz7v"},{"post_id":"cjpy1k4pr000a30ujpswrp2tc","category_id":"cjpy1k4ry000u30ujbyob71e4","_id":"cjpy1k4ta002630ujik30kp0o"},{"post_id":"cjpy1k4pt000b30ujywyfayt8","category_id":"cjpy1k4ry000u30ujbyob71e4","_id":"cjpy1k4ta002830ujjsjllip1"},{"post_id":"cjpy1k4pu000c30ujzaz5zfoc","category_id":"cjpy1k4rf000i30ujq3u53ogf","_id":"cjpy1k4ta002a30ujck5wm6xd"},{"post_id":"cjpy1k4pv000d30ujalqhsmfp","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4tb002c30ujxtqnn3sx"},{"post_id":"cjpy1k4px000e30uj4h22rdss","category_id":"cjpy1k4rf000i30ujq3u53ogf","_id":"cjpy1k4tb002e30ujj7yj9yfy"},{"post_id":"cjpy1k4py000f30ujmlvzcjbn","category_id":"cjpy1k4ry000u30ujbyob71e4","_id":"cjpy1k4tc002g30ujsj51nbq5"},{"post_id":"cjpy1k4pz000g30ujcyws3t0m","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4tc002i30ujbnl40en0"},{"post_id":"cjpy1k4pz000h30ujbalq2gmo","category_id":"cjpy1k4ro000k30ujbigmwh5c","_id":"cjpy1k4td002k30ujokcctwrw"}],"PostTag":[{"post_id":"cjpy1k4pf000130uj0w32y5gp","tag_id":"cjpy1k4rl000j30ujrls5wjkc","_id":"cjpy1k4t6001t30ujn597kmtk"},{"post_id":"cjpy1k4pk000330ujn6ugv6ls","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4t6001v30uj6frz12ep"},{"post_id":"cjpy1k4pk000330ujn6ugv6ls","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4t7001x30ujpfu70yul"},{"post_id":"cjpy1k4pm000530uj1p201td8","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4t7001z30ujwrd1mrhs"},{"post_id":"cjpy1k4pm000530uj1p201td8","tag_id":"cjpy1k4rv000r30uj4415goha","_id":"cjpy1k4t8002130uj69h9t2wq"},{"post_id":"cjpy1k4pm000530uj1p201td8","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4t9002330uj52i5gz7z"},{"post_id":"cjpy1k4pn000730uji4xkn7c4","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4t9002530uj2gv053mf"},{"post_id":"cjpy1k4pn000730uji4xkn7c4","tag_id":"cjpy1k4rv000r30uj4415goha","_id":"cjpy1k4ta002730ujy3ufyhdk"},{"post_id":"cjpy1k4pn000730uji4xkn7c4","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4ta002930uj36ptljn5"},{"post_id":"cjpy1k4po000830ujzinapmm8","tag_id":"cjpy1k4s7001130ujf44ihcti","_id":"cjpy1k4tb002b30ujuaygccgm"},{"post_id":"cjpy1k4po000830ujzinapmm8","tag_id":"cjpy1k4s8001330ujddef9oil","_id":"cjpy1k4tb002d30ujus1vin0f"},{"post_id":"cjpy1k4pq000930ujt91coaiz","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4tc002f30uj1w1rrg6o"},{"post_id":"cjpy1k4pq000930ujt91coaiz","tag_id":"cjpy1k4rv000r30uj4415goha","_id":"cjpy1k4tc002h30ujvqbi51wu"},{"post_id":"cjpy1k4pq000930ujt91coaiz","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4td002j30ujhradfbsu"},{"post_id":"cjpy1k4pr000a30ujpswrp2tc","tag_id":"cjpy1k4sg001a30ujp4lohluz","_id":"cjpy1k4te002l30ujpuw818jd"},{"post_id":"cjpy1k4pr000a30ujpswrp2tc","tag_id":"cjpy1k4sg001b30ujop6mqjkt","_id":"cjpy1k4te002m30ujedrikpda"},{"post_id":"cjpy1k4pr000a30ujpswrp2tc","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4te002n30uj3w2d5xtr"},{"post_id":"cjpy1k4pt000b30ujywyfayt8","tag_id":"cjpy1k4sg001a30ujp4lohluz","_id":"cjpy1k4tf002o30ujuc4xy612"},{"post_id":"cjpy1k4pu000c30ujzaz5zfoc","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4tf002p30ujvssf99gr"},{"post_id":"cjpy1k4pu000c30ujzaz5zfoc","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4tf002q30uj6yvn2tat"},{"post_id":"cjpy1k4pu000c30ujzaz5zfoc","tag_id":"cjpy1k4so001g30ujy6czxy1h","_id":"cjpy1k4tf002r30ujyustv63x"},{"post_id":"cjpy1k4pu000c30ujzaz5zfoc","tag_id":"cjpy1k4so001h30ujgqwqx0c9","_id":"cjpy1k4tg002s30uj47dkekew"},{"post_id":"cjpy1k4pv000d30ujalqhsmfp","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4tg002t30ujx32zahz1"},{"post_id":"cjpy1k4px000e30uj4h22rdss","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4tg002u30ujjdgq9y1r"},{"post_id":"cjpy1k4px000e30uj4h22rdss","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4tg002v30uj8nfx4j7k"},{"post_id":"cjpy1k4py000f30ujmlvzcjbn","tag_id":"cjpy1k4sg001a30ujp4lohluz","_id":"cjpy1k4th002w30ujzgw1xvbf"},{"post_id":"cjpy1k4pz000g30ujcyws3t0m","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4th002x30ujcc18c3qz"},{"post_id":"cjpy1k4pz000g30ujcyws3t0m","tag_id":"cjpy1k4st001n30uj89s5xp3e","_id":"cjpy1k4th002y30uj37xdcvfk"},{"post_id":"cjpy1k4pz000g30ujcyws3t0m","tag_id":"cjpy1k4rv000r30uj4415goha","_id":"cjpy1k4th002z30uj7nnoopl6"},{"post_id":"cjpy1k4pz000g30ujcyws3t0m","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4ti003030ujoid3szq2"},{"post_id":"cjpy1k4pz000h30ujbalq2gmo","tag_id":"cjpy1k4ro000l30uj6ubaivnd","_id":"cjpy1k4ti003130uj1zf6h97u"},{"post_id":"cjpy1k4pz000h30ujbalq2gmo","tag_id":"cjpy1k4st001n30uj89s5xp3e","_id":"cjpy1k4ti003230ujt2f01ccf"},{"post_id":"cjpy1k4pz000h30ujbalq2gmo","tag_id":"cjpy1k4rq000n30ujledrmpsa","_id":"cjpy1k4ti003330ujq4teoeak"}],"Tag":[{"name":"git","_id":"cjpy1k4rl000j30ujrls5wjkc"},{"name":"js","_id":"cjpy1k4ro000l30uj6ubaivnd"},{"name":"前端","_id":"cjpy1k4rq000n30ujledrmpsa"},{"name":"ES6","_id":"cjpy1k4rv000r30uj4415goha"},{"name":"LOL","_id":"cjpy1k4s7001130ujf44ihcti"},{"name":"video","_id":"cjpy1k4s8001330ujddef9oil"},{"name":"hexo","_id":"cjpy1k4sg001a30ujp4lohluz"},{"name":"markdown","_id":"cjpy1k4sg001b30ujop6mqjkt"},{"name":"部署","_id":"cjpy1k4so001g30ujy6czxy1h"},{"name":"jenkins","_id":"cjpy1k4so001h30ujgqwqx0c9"},{"name":"算法","_id":"cjpy1k4st001n30uj89s5xp3e"}]}}
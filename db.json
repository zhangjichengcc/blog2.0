{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/Valine.min.js","path":"js/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.css","path":"libs/font-awesome5/css/fa-brands.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.min.css","path":"libs/font-awesome5/css/fa-brands.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.css","path":"libs/font-awesome5/css/fa-solid.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.min.css","path":"libs/font-awesome5/css/fa-solid.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.css","path":"libs/font-awesome5/css/fontawesome.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.min.css","path":"libs/font-awesome5/css/fontawesome.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff2","path":"libs/font-awesome5/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff","path":"libs/font-awesome5/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff2","path":"libs/font-awesome5/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.eot","path":"libs/font-awesome5/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.ttf","path":"libs/font-awesome5/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff","path":"libs/font-awesome5/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.eot","path":"libs/font-awesome5/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.ttf","path":"libs/font-awesome5/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.jpg","path":"css/images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.svg","path":"libs/font-awesome5/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.svg","path":"libs/font-awesome5/webfonts/fa-brands-400.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1531408992000},{"_id":"themes/icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1531408992000},{"_id":"themes/icarus/README.md","hash":"acd2d5d12820b065345d68f88bfc3a739f8d8ae2","modified":1531408992000},{"_id":"themes/icarus/_config.yml","hash":"6f8e409fac46b8bd146b3e80b81e6ecf7c32b8ad","modified":1538967897559},{"_id":"themes/icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1531408992000},{"_id":"source/_posts/Promise.md","hash":"a2acb6310a3e9178d7304ff9500ab655256fab58","modified":1539074883155},{"_id":"source/_posts/RISE.md","hash":"331d535ef077e11af707f1057e2f3dbe0f40c399","modified":1539081258183},{"_id":"source/_posts/hexo-创建文章.md","hash":"f9e7c77c634dbfe57a57b5d75c767ad9a0933710","modified":1538967233485},{"_id":"source/_posts/hexo常用指令.md","hash":"c6330304d1ce4ea26bb261dfd722bac0ad3fdfd3","modified":1538191352833},{"_id":"source/_posts/js构造函数.md","hash":"165893a6828554ba2e8cf98bdcc4e9b0d95448cd","modified":1539076811831},{"_id":"source/_posts/给Hexo博客添加访问统计.md","hash":"c23aa9a75356c85d54784180f8f8c1821473b2d1","modified":1539054469272},{"_id":"source/_posts/递归尾调用优化.md","hash":"4500999327c38aa9fce499f06b6de111b6cb6f64","modified":1539066694696},{"_id":"source/_posts/递归树结构解析.md","hash":"f22aa96ac13962ce950899e7be48d309aa35179b","modified":1539067178776},{"_id":"source/about/index.md","hash":"32032f4e0c314116bc18bd8c1aa7fac06c71673d","modified":1538994047990},{"_id":"source/categories/index.md","hash":"fddef9937a21af2e81fe6bd4549e63fcc9c4a63c","modified":1538042427766},{"_id":"source/tags/index.md","hash":"e2ccf34d45ddbfc8ce1a41192350ff6d42239dd9","modified":1538042474759},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"9393fd3dbc943f1544facb66af7fd8b7a5b9ddbb","modified":1531408992000},{"_id":"themes/icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1531408992000},{"_id":"themes/icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1531408992000},{"_id":"themes/icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1531408992000},{"_id":"themes/icarus/languages/id.yml","hash":"e4961da507f66c8f7c37f85653a9437cb2056bf6","modified":1531408992000},{"_id":"themes/icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1531408992000},{"_id":"themes/icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1531408992000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1531408992000},{"_id":"themes/icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1531408992000},{"_id":"themes/icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1531408992000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1531408992000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1531408992000},{"_id":"themes/icarus/layout/archive.ejs","hash":"a369f50b7bb4a3fb30c95dccc813f0552172d827","modified":1531408992000},{"_id":"themes/icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1538102359397},{"_id":"themes/icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1531408992000},{"_id":"themes/icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1531408992000},{"_id":"themes/icarus/layout/layout.ejs","hash":"355f02f9f21bd99c8006c88235a8262f986d2101","modified":1538207719751},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1531408992000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1531408992000},{"_id":"themes/icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1531408992000},{"_id":"themes/icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1531408992000},{"_id":"themes/icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1531408992000},{"_id":"themes/icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1531408992000},{"_id":"source/_posts/RISE/banner.jpg","hash":"046ae6a9ddf3c7c60a04271c44e9df49813301d0","modified":1539077776797},{"_id":"source/_posts/hexo-创建文章/lujing2.jpg","hash":"a390f5b69d7f608004d42bc55182e503bb64f7ff","modified":1538129660626},{"_id":"source/_posts/hexo-创建文章/wenjian.jpg","hash":"1d46842690b5f85273dc39bfebd5157707b982a8","modified":1538130158856},{"_id":"source/_posts/js构造函数/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1539076680366},{"_id":"source/_posts/给Hexo博客添加访问统计/bsz.jpg","hash":"bf72ba6bbc89d3979c9e83ebaf90a2f0673de6e2","modified":1539054558509},{"_id":"source/_posts/给Hexo博客添加访问统计/timg.jpg","hash":"48008426aebff3897fb41aa4319b0dc6637778ed","modified":1538036753161},{"_id":"source/_posts/递归树结构解析/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1539076680366},{"_id":"source/_posts/递归树结构解析/result.jpg","hash":"d3cc67d6e6db5ab158ddcd335be3b354f2b36a56","modified":1538986270957},{"_id":"themes/icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1531408992000},{"_id":"themes/icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1531408992000},{"_id":"themes/icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1531408992000},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"b4bd2e641af59e06becaa8f2dc97867f023b8dcf","modified":1531408992000},{"_id":"themes/icarus/layout/comment/counter.ejs","hash":"57c194d0fa268ce2f3e9c755b3154b8a0709f613","modified":1531408992000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1531408992000},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1531408992000},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1531408992000},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"c7998209b9a766eeba6976dd4bdffb1f87469358","modified":1531408992000},{"_id":"themes/icarus/layout/comment/index.ejs","hash":"0bce9ca0767b49d2a9fc026a6004a8526a20624b","modified":1531408992000},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"4f8b81ff5bb418ec11ce080d515f247bfe436014","modified":1531408992000},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"792e4f0e93b2bdc5abd85d447d804a5c608a9c5c","modified":1531408992000},{"_id":"themes/icarus/layout/comment/scripts.ejs","hash":"d45f652268671de96c86d8ca50b9deaf011274f0","modified":1531408992000},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"709bad05d9d9a2578110b845122982070a1d70f0","modified":1538300512585},{"_id":"themes/icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1531408992000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"af6381cad6117c940a44cff443e62c34ca0ca72e","modified":1538214457063},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"39be5e6601fd2c251f0a9da3cdec65c3e03f320b","modified":1538036253423},{"_id":"themes/icarus/layout/common/head.ejs","hash":"daf0b5a6201e09782500795f3db84713a92c791a","modified":1531408992000},{"_id":"themes/icarus/layout/common/header.ejs","hash":"83666c38283d0a22082f143dbe629c2853e4e0b7","modified":1538193298500},{"_id":"themes/icarus/layout/common/profile.ejs","hash":"a60d519c968b622e5bdbddd623af41f0d32a5241","modified":1538103252466},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1531408992000},{"_id":"themes/icarus/layout/common/sidebar.ejs","hash":"8cee4531fb0deca8f0951ef93f039028bc7f343c","modified":1531408992000},{"_id":"themes/icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1531408992000},{"_id":"themes/icarus/layout/common/timeline.ejs","hash":"48235931698f04ad0ff057a1693ce81e628f9e0a","modified":1531408992000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1531408992000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1531408992000},{"_id":"themes/icarus/layout/plugin/scripts.ejs","hash":"e22f99652a220d926103801a3cad55ea9c450e05","modified":1531408992000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1531408992000},{"_id":"themes/icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1531408992000},{"_id":"themes/icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1531408992000},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"bcf275e42efbc6677a0fd35f5501e7618ffe9e4c","modified":1531408992000},{"_id":"themes/icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1531408992000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1531408992000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1531408992000},{"_id":"themes/icarus/layout/share/default.ejs","hash":"bddd4425db187d893a5599d69810fa4159d0c45e","modified":1531408992000},{"_id":"themes/icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1531408992000},{"_id":"themes/icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1531408992000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1531408992000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1531408992000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1531408992000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"e7942ff12fe2220dd2667216886a71e4f6432bdc","modified":1538122406201},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1531408992000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1531408992000},{"_id":"themes/icarus/source/css/_extend.styl","hash":"539e02107f35e8b3bdb9bf160dc212a433a7b60e","modified":1531408992000},{"_id":"themes/icarus/source/css/_variables.styl","hash":"72cc7b96563d80bb924e615913095f07ea8339b9","modified":1538019030248},{"_id":"themes/icarus/source/css/style.styl","hash":"1716b199dba80b26086f325d69c36fa682465106","modified":1538123771445},{"_id":"themes/icarus/source/js/Valine.min.js","hash":"15cb71314ed92194e1137305b87aa9e122494c72","modified":1538299082941},{"_id":"themes/icarus/source/js/insight.js","hash":"f507ab7b2236349719f1af2c918f2f5c22d410c2","modified":1531408992000},{"_id":"themes/icarus/source/js/main.js","hash":"2c148f06c5799b5d7dd165c5162e780535e07a40","modified":1531408992000},{"_id":"source/_posts/hexo-创建文章/lujing.jpg","hash":"e08d55018e7afef50bd664085f701c7732933a01","modified":1538129531550},{"_id":"source/_posts/hexo-创建文章/banner.jpg","hash":"9299f035bf4bdb1c77ca7f74dad3919c473d6b1c","modified":1538127775207},{"_id":"source/_posts/hexo-创建文章/suoluetu.png","hash":"2f244d1faccdca8ed2661cecf7b0ca08799c2156","modified":1538127381617},{"_id":"source/_posts/js构造函数/slt.jpg","hash":"c8e9271a488c7eef94de87c6b90f9f17bdcdbf80","modified":1539076620628},{"_id":"themes/icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/category.ejs","hash":"9977603db05db02a55996e1ab3620d682a3c87b2","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/date.ejs","hash":"7817a75f3b8933ccf6366c1fdbce1e19912b0b35","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/tag.ejs","hash":"d3f5a2a17b1235135c7d1f2f9bc5878ef7687e8c","modified":1531408992000},{"_id":"themes/icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/index.styl","hash":"5ea847a03ff704ab7f4752518367115ca3862890","modified":1538987384012},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1531408992000},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/archive.styl","hash":"7417c254aae2b1b2132b3fb9f9efa4b32c09dd8d","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/article.styl","hash":"60d5a86798010e45d8f70f49b00af2beebb64067","modified":1538967322596},{"_id":"themes/icarus/source/css/_partial/comment.styl","hash":"1330bc399de3c5f41dd894cc33d0006be0309271","modified":1538300380251},{"_id":"themes/icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/header.styl","hash":"1db9d1ca6402a9ad2767d2c4fe26fed4c835b1d0","modified":1538193222252},{"_id":"themes/icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1531408992000},{"_id":"themes/icarus/source/css/_partial/profile.styl","hash":"4cbc22ad02d88d4e0abcbbc192a2dccee0980215","modified":1538104402740},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","hash":"7aa8566ed33bd005ffed2659e3172d4936ca62fb","modified":1538122999671},{"_id":"themes/icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1531408992000},{"_id":"themes/icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1531408992000},{"_id":"themes/icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1531408992000},{"_id":"themes/icarus/source/css/images/_logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1531408992000},{"_id":"themes/icarus/source/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1531408992000},{"_id":"themes/icarus/source/css/images/favicon.ico","hash":"d2c1d45f1d1dc4919269b4b9dc15a5570ee6ac8c","modified":1538967714951},{"_id":"themes/icarus/source/css/images/logo.png","hash":"8edea620d152599bf9d07730d74a3f16058179da","modified":1538018365721},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1531408992000},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1531408992000},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1531408992000},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.css","hash":"3dc468f3a5d6dcbdb977b17c2c021f751c5bf7c6","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-brands.min.css","hash":"ae33d7d508d9fb4d8cc026f74007fae27017fc80","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.css","hash":"5c960e4efb31a88b1319dcf63d4806175e3cb8cd","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fa-solid.min.css","hash":"ac3cc27cd41d44ed5d680541636604d0c397e5f6","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.css","hash":"b818fea784ea93c6cc393d545bfc5e1ec2045ff7","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/css/fontawesome.min.css","hash":"8518d72f88b376749244da2bdc96f261d9bd5645","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff2","hash":"0ec12ea1707f5bc812b627f41cccad2aff01e54b","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff","hash":"7b4a63abc8476f745f09775d7465f0a6c33daf85","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.woff2","hash":"1ba4dd60af529d1a72d0e57467c3bc0bbb728a4d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1531408992000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1531408992000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1531408992000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1531408992000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.eot","hash":"d92c68223732a10ceffe54eecbe4ef70073e6dea","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.ttf","hash":"9b4bb228d5b132e69ff8b6b248262449879eff3e","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.woff","hash":"8b5cac7fbf1712c81d9cac19cda04e6a604eb9da","modified":1531408992000},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.eot","hash":"69aa0b829fd8562d0fb72948ce49ef201ff0ee83","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.ttf","hash":"31dc9b748b8d2bf6c3edec919e763791e037bbff","modified":1531408992000},{"_id":"themes/icarus/source/css/images/avatar.jpg","hash":"1047ff989dd0033e273f8e6f96c5c182edf0c600","modified":1538036792613},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-solid-900.svg","hash":"24a7c19c323e91705be51641e87da7d5dfea5d10","modified":1531408992000},{"_id":"themes/icarus/source/libs/font-awesome5/webfonts/fa-brands-400.svg","hash":"b07d27980b351d78f322260386450dde60d298cc","modified":1531408992000},{"_id":"public/about/index.html","hash":"a83ae145e1e123f6680f838050efcb79f1d7b667","modified":1539081332135},{"_id":"public/categories/index.html","hash":"ba8c6d889b03dc547f2d9317605eeafc6e47f47c","modified":1539081332135},{"_id":"public/tags/index.html","hash":"133287eccaa6595131f6833d04453f12a73a5991","modified":1539081332135},{"_id":"public/2018/10/09/js构造函数/index.html","hash":"c7888bc613e42a44cad1e84f8d9d2935c56d0735","modified":1539081332135},{"_id":"public/2018/10/09/Promise/index.html","hash":"5cbba2ce7fcbdcac925786089a96733a3ee05578","modified":1539081332135},{"_id":"public/2018/10/08/递归尾调用优化/index.html","hash":"26eec6ff9c25d55cea64c9f6a8c7ae64e728f48f","modified":1539081332136},{"_id":"public/2018/10/08/递归树结构解析/index.html","hash":"580c4deacabf515d73ea4bd301708d65ef6abd3f","modified":1539081332136},{"_id":"public/2018/09/29/RISE/index.html","hash":"7f5873c6a0b7d2fe176539449a4406eba47505d6","modified":1539081332136},{"_id":"public/2018/09/27/给Hexo博客添加访问统计/index.html","hash":"88717b54ad0eb9e3723af20141df17158fd0f3f8","modified":1539081332136},{"_id":"public/2018/09/27/hexo-创建文章/index.html","hash":"ad9a6546e001dbef479497e2dda78a3a57335f0f","modified":1539081332136},{"_id":"public/2018/09/25/hexo常用指令/index.html","hash":"cd09a60e4042a551c49f2e4f5caad29cc9c91507","modified":1539081332136},{"_id":"public/archives/index.html","hash":"4efd34bc187c62c32d41312b3303151bd93be1c0","modified":1539081332136},{"_id":"public/archives/2018/index.html","hash":"accf61c39218543a39877d701436bb4b3058e1ec","modified":1539081332136},{"_id":"public/archives/2018/09/index.html","hash":"07d1f60733bfb3a3e66eb2386f02c752e96b709f","modified":1539081332136},{"_id":"public/archives/2018/10/index.html","hash":"4e199194241eec0ddcab80ca74428ccad3373bc1","modified":1539081332137},{"_id":"public/categories/娱乐/index.html","hash":"0ffb401e4d75b88fc70c2428348a0b596c2bdea5","modified":1539081332137},{"_id":"public/categories/笔记/index.html","hash":"2ff96f31995c8af6af477b9f7873168dc269621a","modified":1539081332137},{"_id":"public/categories/工具/index.html","hash":"09681504c62f315d9bdbd1a56c16cd5b17fcde01","modified":1539081332137},{"_id":"public/index.html","hash":"6622ff5a54d4c09a3084858b712211acf30d16f4","modified":1539081332137},{"_id":"public/tags/LOL/index.html","hash":"74f6e0532bd0cb8f5856d57f567bfbf53616b281","modified":1539081332137},{"_id":"public/tags/video/index.html","hash":"8a5dc32fa934ed2992824bcf34e34ae4c44d3c41","modified":1539081332137},{"_id":"public/tags/js/index.html","hash":"4545d648864cf76894e55df11820edcb4083ef82","modified":1539081332137},{"_id":"public/tags/ES6/index.html","hash":"e59a6ef47e35ff068e311be7a1eac52e60696362","modified":1539081332138},{"_id":"public/tags/hexo/index.html","hash":"7f002df421fc495d38d1e427af906f0041071b50","modified":1539081332138},{"_id":"public/tags/markdown/index.html","hash":"238d0caf9dcacfd5fc053d24d7d7cd0142649751","modified":1539081332138},{"_id":"public/tags/前端/index.html","hash":"6d6630cf4c8bad7a79cbe668f80a1f2889f1ced5","modified":1539081332138},{"_id":"public/tags/算法/index.html","hash":"120e7be1097b9c89995e4a23b2a7d4fad95a44c8","modified":1539081332138},{"_id":"public/../assets/css/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1539081332148},{"_id":"public/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1539081332148},{"_id":"public/css/images/favicon.ico","hash":"d2c1d45f1d1dc4919269b4b9dc15a5570ee6ac8c","modified":1539081332148},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1539081332148},{"_id":"public/css/images/logo.png","hash":"8edea620d152599bf9d07730d74a3f16058179da","modified":1539081332148},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.woff2","hash":"0ec12ea1707f5bc812b627f41cccad2aff01e54b","modified":1539081332148},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.woff","hash":"7b4a63abc8476f745f09775d7465f0a6c33daf85","modified":1539081332148},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1539081332148},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.woff2","hash":"1ba4dd60af529d1a72d0e57467c3bc0bbb728a4d","modified":1539081332149},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1539081332149},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1539081332149},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1539081332149},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1539081332149},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1539081332149},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1539081332149},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1539081332149},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1539081332149},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1539081332149},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1539081332149},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1539081332150},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1539081332151},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1539081332151},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1539081332152},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1539081332152},{"_id":"public/2018/09/29/RISE/banner.jpg","hash":"046ae6a9ddf3c7c60a04271c44e9df49813301d0","modified":1539081332152},{"_id":"public/2018/10/09/js构造函数/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1539081332152},{"_id":"public/2018/09/27/给Hexo博客添加访问统计/bsz.jpg","hash":"bf72ba6bbc89d3979c9e83ebaf90a2f0673de6e2","modified":1539081332152},{"_id":"public/2018/10/08/递归树结构解析/banner.jpg","hash":"26426f920ad61c5e6dfd08b3cff52a0fb6edf182","modified":1539081332152},{"_id":"public/2018/10/08/递归树结构解析/result.jpg","hash":"d3cc67d6e6db5ab158ddcd335be3b354f2b36a56","modified":1539081332153},{"_id":"public/2018/09/27/给Hexo博客添加访问统计/timg.jpg","hash":"48008426aebff3897fb41aa4319b0dc6637778ed","modified":1539081332153},{"_id":"public/2018/09/27/hexo-创建文章/lujing2.jpg","hash":"a390f5b69d7f608004d42bc55182e503bb64f7ff","modified":1539081332153},{"_id":"public/2018/09/27/hexo-创建文章/wenjian.jpg","hash":"1d46842690b5f85273dc39bfebd5157707b982a8","modified":1539081332153},{"_id":"public/../assets/js/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1539081332829},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.eot","hash":"d92c68223732a10ceffe54eecbe4ef70073e6dea","modified":1539081332832},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.ttf","hash":"9b4bb228d5b132e69ff8b6b248262449879eff3e","modified":1539081332835},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.woff","hash":"8b5cac7fbf1712c81d9cac19cda04e6a604eb9da","modified":1539081332835},{"_id":"public/2018/09/27/hexo-创建文章/lujing.jpg","hash":"e08d55018e7afef50bd664085f701c7732933a01","modified":1539081332836},{"_id":"public/js/insight.js","hash":"f507ab7b2236349719f1af2c918f2f5c22d410c2","modified":1539081332844},{"_id":"public/js/main.js","hash":"2c148f06c5799b5d7dd165c5162e780535e07a40","modified":1539081332844},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1539081332844},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1539081332845},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1539081332845},{"_id":"public/libs/font-awesome5/css/fa-brands.min.css","hash":"ae33d7d508d9fb4d8cc026f74007fae27017fc80","modified":1539081332845},{"_id":"public/libs/font-awesome5/css/fa-brands.css","hash":"3dc468f3a5d6dcbdb977b17c2c021f751c5bf7c6","modified":1539081332845},{"_id":"public/libs/font-awesome5/css/fa-solid.css","hash":"5c960e4efb31a88b1319dcf63d4806175e3cb8cd","modified":1539081332845},{"_id":"public/libs/font-awesome5/css/fa-solid.min.css","hash":"ac3cc27cd41d44ed5d680541636604d0c397e5f6","modified":1539081332845},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1539081332845},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1539081332845},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1539081332846},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1539081332846},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1539081332846},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1539081332846},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1539081332846},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1539081332846},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1539081332846},{"_id":"public/css/style.css","hash":"077a857c16071f4b5dac3d0a2bda536e217aba16","modified":1539081332846},{"_id":"public/js/Valine.min.js","hash":"8e71573bc334c2d74654a68bdfb421e68e2b45da","modified":1539081332846},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1539081332846},{"_id":"public/libs/font-awesome5/css/fontawesome.css","hash":"b818fea784ea93c6cc393d545bfc5e1ec2045ff7","modified":1539081332846},{"_id":"public/libs/font-awesome5/css/fontawesome.min.css","hash":"8518d72f88b376749244da2bdc96f261d9bd5645","modified":1539081332847},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1539081332847},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1539081332847},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1539081332847},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1539081332847},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1539081332847},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1539081332847},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1539081332847},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1539081332847},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1539081332847},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.eot","hash":"69aa0b829fd8562d0fb72948ce49ef201ff0ee83","modified":1539081332847},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.ttf","hash":"31dc9b748b8d2bf6c3edec919e763791e037bbff","modified":1539081332848},{"_id":"public/2018/09/27/hexo-创建文章/suoluetu.png","hash":"2f244d1faccdca8ed2661cecf7b0ca08799c2156","modified":1539081332848},{"_id":"public/2018/10/09/js构造函数/slt.jpg","hash":"c8e9271a488c7eef94de87c6b90f9f17bdcdbf80","modified":1539081332848},{"_id":"public/2018/09/27/hexo-创建文章/banner.jpg","hash":"9299f035bf4bdb1c77ca7f74dad3919c473d6b1c","modified":1539081332848},{"_id":"public/libs/font-awesome5/webfonts/fa-solid-900.svg","hash":"24a7c19c323e91705be51641e87da7d5dfea5d10","modified":1539081332892},{"_id":"public/libs/font-awesome5/webfonts/fa-brands-400.svg","hash":"b07d27980b351d78f322260386450dde60d298cc","modified":1539081332942},{"_id":"public/css/images/avatar.jpg","hash":"1047ff989dd0033e273f8e6f96c5c182edf0c600","modified":1539081332943}],"Category":[{"name":"娱乐","_id":"cjn1lab630004ccuj91c1rsdb"},{"name":"笔记","_id":"cjn1lab6n0009ccuj74chpiau"},{"name":"工具","_id":"cjn1lab6y000eccuj4n07abem"}],"Data":[],"Page":[{"title":"About","date":"2018-09-26T10:22:02.000Z","_content":"\n## 友情链接\n\nECMAScript 6 入门： [http://es6.ruanyifeng.com/](http://es6.ruanyifeng.com/)\n杨某的博客： [https://angusyang9.github.io/](https://angusyang9.github.io/)\n刘某某的博客： [https://provenr.github.io/](https://provenr.github.io/)\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2018-09-26 18:22:02\n---\n\n## 友情链接\n\nECMAScript 6 入门： [http://es6.ruanyifeng.com/](http://es6.ruanyifeng.com/)\n杨某的博客： [https://angusyang9.github.io/](https://angusyang9.github.io/)\n刘某某的博客： [https://provenr.github.io/](https://provenr.github.io/)\n","updated":"2018-10-08T10:20:47.990Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjn1lab5w0001ccujv3ab3h3l","content":"<h2 id=\"友情链接\"><a href=\"#友情链接\" class=\"headerlink\" title=\"友情链接\"></a>友情链接</h2><p>ECMAScript 6 入门： <a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a><br>杨某的博客： <a href=\"https://angusyang9.github.io/\" target=\"_blank\" rel=\"noopener\">https://angusyang9.github.io/</a><br>刘某某的博客： <a href=\"https://provenr.github.io/\" target=\"_blank\" rel=\"noopener\">https://provenr.github.io/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"友情链接\"><a href=\"#友情链接\" class=\"headerlink\" title=\"友情链接\"></a>友情链接</h2><p>ECMAScript 6 入门： <a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a><br>杨某的博客： <a href=\"https://angusyang9.github.io/\" target=\"_blank\" rel=\"noopener\">https://angusyang9.github.io/</a><br>刘某某的博客： <a href=\"https://provenr.github.io/\" target=\"_blank\" rel=\"noopener\">https://provenr.github.io/</a></p>\n"},{"title":"文章分类","date":"2018-09-27T06:23:33.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-09-27 14:23:33\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2018-09-27T10:00:27.766Z","path":"categories/index.html","comments":1,"_id":"cjn1lab610003ccujxrk5i54l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-09-27T06:31:12.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-09-27 14:31:12\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2018-09-27T10:01:14.759Z","path":"tags/index.html","comments":1,"_id":"cjn1lab9d001jccujbuc99m37","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RISE - 巅峰造极境","date":"2018-09-29T02:49:14.000Z","top":true,"banner":"/bolg/2018/09/29/RISE/banner.jpg","thumbnail":"https://gss3.bdstatic.com/84oSdTum2Q5BphGlnYG/timg?wapp&quality=80&size=b150_150&subsize=20480&cut_x=0&cut_w=0&cut_y=0&cut_h=0&sec=1369815402&srctrace&di=92d43c740baeb2f0a45cb3afc9cfa30d&wh_rate=null&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fpic%2Fitem%2F377adab44aed2e73af4253468b01a18b87d6fa35.jpg","_content":"\n2018 英雄联盟全球总决赛主题曲\n<!--more-->\n\n**2018 英雄联盟全球总决赛主题曲**\n\n<!-- <iframe \n\tstyle=\"width: 100%; height: 28vw;\"\n\tautoPlay=\"false\"\n\tsrc=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n\tframeborder=0 allowfullscreen>\n</iframe> -->\n\n<video width=\"100%\" controls preload>\n    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\">\n</video>\n","source":"_posts/RISE.md","raw":"---\ntitle: RISE - 巅峰造极境\ndate: 2018-09-29 10:49:14\ncategories: 娱乐\ntop: true\ntags: \n\t- LOL\n\t- video\nbanner: /bolg/2018/09/29/RISE/banner.jpg\nthumbnail: https://gss3.bdstatic.com/84oSdTum2Q5BphGlnYG/timg?wapp&quality=80&size=b150_150&subsize=20480&cut_x=0&cut_w=0&cut_y=0&cut_h=0&sec=1369815402&srctrace&di=92d43c740baeb2f0a45cb3afc9cfa30d&wh_rate=null&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fpic%2Fitem%2F377adab44aed2e73af4253468b01a18b87d6fa35.jpg\n---\n\n2018 英雄联盟全球总决赛主题曲\n<!--more-->\n\n**2018 英雄联盟全球总决赛主题曲**\n\n<!-- <iframe \n\tstyle=\"width: 100%; height: 28vw;\"\n\tautoPlay=\"false\"\n\tsrc=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n\tframeborder=0 allowfullscreen>\n</iframe> -->\n\n<video width=\"100%\" controls preload>\n    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\">\n</video>\n","slug":"RISE","published":1,"updated":"2018-10-09T10:34:18.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn1lab5o0000ccuj0zz10xqp","content":"<p>2018 英雄联盟全球总决赛主题曲<br><a id=\"more\"></a></p>\n<p><strong>2018 英雄联盟全球总决赛主题曲</strong></p>\n<!-- <iframe \n    style=\"width: 100%; height: 28vw;\"\n    autoPlay=\"false\"\n    src=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n    frameborder=0 allowfullscreen>\n</iframe> -->\n<video width=\"100%\" controls preload=\"\"><br>    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\"><br></video>\n","site":{"data":{}},"excerpt":"<p>2018 英雄联盟全球总决赛主题曲<br></p>","more":"<p></p>\n<p><strong>2018 英雄联盟全球总决赛主题曲</strong></p>\n<!-- <iframe \n    style=\"width: 100%; height: 28vw;\"\n    autoPlay=\"false\"\n    src=\"http://112.90.53.154/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=66DFBEE5353555E7FA4474ED17B20611024530A849765FC5B745363F19C1EB539B55E508AB3C763DAEBD9638E0D5866FDAE24CE39CCFAE307A7815C2F74EB4ED312363B76D722B6E43B277DA3465137296D3B018A859DAB9\" \n    frameborder=0 allowfullscreen>\n</iframe> -->\n<video width=\"100%\" controls preload=\"\"><br>    <source src=\"http://157.255.154.153/vcloud1049.tc.qq.com/1049_M0129600004OHJyg1ho6vG1001585158.f40.mp4?vkey=4C7FBF4CAF4729FF3A60014568F46231452883EA21AC509C261CAD9E4AE815FF630183D5D22B44C0445B4864903803F6BE7977B72D7694AAFC1EB8A597B8A87477BBD8D984DE4C5ADF2A4CB65ABD72962C857CA3DB3EA902\" type=\"video/mp4\"><br></video>"},{"title":"ES6 Promise","date":"2018-10-09T07:13:04.000Z","toc":true,"banner":"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg","_content":"\n>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n\n<!-- more -->\n\n### Promise 的含义\n\n>所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。`Promise` 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\nPromise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 `resolved`（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的`resolved`统一只指`fulfilled`状态，不包含`rejected`状态。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n`Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 [`Stream`](https://nodejs.org/api/stream.html) 模式是比部署 `Promise` 更好的选择。\n\n---\n\n### 基本用法\n\n>ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n下面代码创造了一个`Promise`实例。\n\n``` js\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n`resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n>`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n``` js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n`then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。\n\n下面是一个`Promise`对象的简单例子。\n\n``` js\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n```\n\n上面代码中，`timeout`方法返回一个`Promise`实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，`Promise`实例的状态变为`resolved`，就会触发`then`方法绑定的回调函数。\n\n`Promise` 新建后就会立即执行。\n\n``` js\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// resolved\n```\n上面代码中，`Promise` 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。\n\n下面是异步加载图片的例子。\n\n``` js\nfunction loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url));\n    };\n\n    image.src = url;\n  });\n}\n```\n\n上面代码中，使用`Promise`包装了一个图片加载的异步操作。如果加载成功，就调用`resolve`方法，否则就调用`reject`方法。\n\n下面是一个用`Promise`对象实现的 `Ajax` 操作的例子。\n\n``` js\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n---\n\n#### Promise.prototype.then()\n\n>`Promise` 实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 `Promise` 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。\n\n`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n``` js\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n上面的代码使用`then`方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。\n\n``` js\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"resolved: \", comments);\n}, function funcB(err){\n  console.log(\"rejected: \", err);\n});\n```\n\n上面代码中，第一个`then`方法指定的回调函数，返回的是另一个`Promise`对象。这时，第二个`then`方法指定的回调函数，就会等待这个新的`Promise`对象状态发生变化。如果变为`resolved`，就调用`funcA`，如果状态变为`rejected`，就调用`funcB`。\n\n如果采用箭头函数，上面的代码可以写得更简洁。\n\n``` js\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"resolved: \", comments),\n  err => console.log(\"rejected: \", err)\n);\n```\n\n---\n\n#### Promise.prototype.catch()\n\n>`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。\n\n``` js\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n上面代码中，`getJSON`方法返回一个 `Promise` 对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，`then`方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n`Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。\n\n``` js\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n```\n\n上面代码中，一共有三个 `Promise` 对象：一个由`getJSON`产生，两个由`then`产生。它们之中任何一个抛出的错误，都会被最后一个`catch`捕获。\n\n一般来说，不要在`then`方法里面定义 `Reject` 状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。\n\n``` js\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也更接近同步的写法`（try/catch）`。因此，建议总是使用`catch`方法，而不使用`then`方法的第二个参数。\n\n---\n\n#### Promise.prototype.finally()\n\n>`finally`方法用于指定不管 `Promise` 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\n``` js\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n上面代码中，不管`promise`最后的状态，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。\n\n---\n\n#### Promise.all() \n\n>`Promise.all`方法用于将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，`Promise.all`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是 `Promise` 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。（`Promise.all`方法的参数可以不是数组，但必须具有 `Iterator` 接口，且返回的每个成员都是 `Promise` 实例。）\n\n`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。\n\n（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。\n\n（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。\n\n下面是一个具体的例子。\n\n``` js\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n上面代码中，`promises`是包含 6 个 `Promise` 实例的数组，只有这 6 个实例的状态都变成`fulfilled`，或者其中有一个变为`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n---\n\n#### Promise.race()\n\n>`Promise.race`方法同样是将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 `Promise` 实例的返回值，就传递给`p`的回调函数。\n\n`Promise.race`方法的参数与`Promise.all`方法一样，如果不是 `Promise` 实例，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 `Promise` 的状态变为`reject`，否则变为`resolve`。\n\n``` js\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n\n上面代码中，如果 5 秒之内`fetch`方法无法返回结果，变量`p`的状态就会变为`rejected`，从而触发`catch`方法指定的回调函数。\n\n---\n\n#### Promise.resolve()\n\n>有时需要将现有对象转为 `Promise` 对象，`Promise.resolve`方法就起到这个作用。\n\n``` js\nconst jsPromise = Promise.resolve($.ajax('/whatever.json'));\n```\n\n上面代码将 jQuery 生成的`deferred`对象，转为一个新的 `Promise` 对象。\n\n`Promise.resolve`等价于下面的写法。\n\n``` js\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n#### Promise.reject()\n\n>`Promise.reject(reason)`方法也会返回一个新的 `Promise` 实例，该实例的状态为`rejected`。\n\n``` js\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n上面代码生成一个 `Promise` 对象的实例p，状态为`rejected`，回调函数会立即执行。\n\n**注意**，`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。这一点与`Promise.resolve`方法不一致。\n\n``` js\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n```\n\n上面代码中，`Promise.reject`方法的参数是一个`thenable`对象，执行以后，后面`catch`方法的参数不是`reject`抛出的“出错了”这个字符串，而是`thenable`对象。\n\n#### Promise.try()\n\n>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。\n\n>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\n>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。\n\n``` js\nPromise.try(database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n```\n","source":"_posts/Promise.md","raw":"---\ntitle: ES6 Promise\ndate: 2018-10-09 15:13:04\ntoc: true\nbanner: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg\ncategories: '笔记'\ntags:\n\t- js\n\t- ES6\n---\n\n>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n\n<!-- more -->\n\n### Promise 的含义\n\n>所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。`Promise` 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\nPromise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 `resolved`（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的`resolved`统一只指`fulfilled`状态，不包含`rejected`状态。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n`Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 [`Stream`](https://nodejs.org/api/stream.html) 模式是比部署 `Promise` 更好的选择。\n\n---\n\n### 基本用法\n\n>ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n下面代码创造了一个`Promise`实例。\n\n``` js\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n`resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n>`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n``` js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n`then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。\n\n下面是一个`Promise`对象的简单例子。\n\n``` js\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n```\n\n上面代码中，`timeout`方法返回一个`Promise`实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，`Promise`实例的状态变为`resolved`，就会触发`then`方法绑定的回调函数。\n\n`Promise` 新建后就会立即执行。\n\n``` js\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// resolved\n```\n上面代码中，`Promise` 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。\n\n下面是异步加载图片的例子。\n\n``` js\nfunction loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url));\n    };\n\n    image.src = url;\n  });\n}\n```\n\n上面代码中，使用`Promise`包装了一个图片加载的异步操作。如果加载成功，就调用`resolve`方法，否则就调用`reject`方法。\n\n下面是一个用`Promise`对象实现的 `Ajax` 操作的例子。\n\n``` js\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n---\n\n#### Promise.prototype.then()\n\n>`Promise` 实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 `Promise` 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。\n\n`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n``` js\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n上面的代码使用`then`方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。\n\n``` js\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"resolved: \", comments);\n}, function funcB(err){\n  console.log(\"rejected: \", err);\n});\n```\n\n上面代码中，第一个`then`方法指定的回调函数，返回的是另一个`Promise`对象。这时，第二个`then`方法指定的回调函数，就会等待这个新的`Promise`对象状态发生变化。如果变为`resolved`，就调用`funcA`，如果状态变为`rejected`，就调用`funcB`。\n\n如果采用箭头函数，上面的代码可以写得更简洁。\n\n``` js\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"resolved: \", comments),\n  err => console.log(\"rejected: \", err)\n);\n```\n\n---\n\n#### Promise.prototype.catch()\n\n>`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。\n\n``` js\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n上面代码中，`getJSON`方法返回一个 `Promise` 对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，`then`方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n`Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。\n\n``` js\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n```\n\n上面代码中，一共有三个 `Promise` 对象：一个由`getJSON`产生，两个由`then`产生。它们之中任何一个抛出的错误，都会被最后一个`catch`捕获。\n\n一般来说，不要在`then`方法里面定义 `Reject` 状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。\n\n``` js\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也更接近同步的写法`（try/catch）`。因此，建议总是使用`catch`方法，而不使用`then`方法的第二个参数。\n\n---\n\n#### Promise.prototype.finally()\n\n>`finally`方法用于指定不管 `Promise` 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\n``` js\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n上面代码中，不管`promise`最后的状态，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。\n\n---\n\n#### Promise.all() \n\n>`Promise.all`方法用于将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，`Promise.all`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是 `Promise` 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。（`Promise.all`方法的参数可以不是数组，但必须具有 `Iterator` 接口，且返回的每个成员都是 `Promise` 实例。）\n\n`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。\n\n（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。\n\n（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。\n\n下面是一个具体的例子。\n\n``` js\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n上面代码中，`promises`是包含 6 个 `Promise` 实例的数组，只有这 6 个实例的状态都变成`fulfilled`，或者其中有一个变为`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n---\n\n#### Promise.race()\n\n>`Promise.race`方法同样是将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。\n\n``` js\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 `Promise` 实例的返回值，就传递给`p`的回调函数。\n\n`Promise.race`方法的参数与`Promise.all`方法一样，如果不是 `Promise` 实例，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 `Promise` 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 `Promise` 的状态变为`reject`，否则变为`resolve`。\n\n``` js\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n\n上面代码中，如果 5 秒之内`fetch`方法无法返回结果，变量`p`的状态就会变为`rejected`，从而触发`catch`方法指定的回调函数。\n\n---\n\n#### Promise.resolve()\n\n>有时需要将现有对象转为 `Promise` 对象，`Promise.resolve`方法就起到这个作用。\n\n``` js\nconst jsPromise = Promise.resolve($.ajax('/whatever.json'));\n```\n\n上面代码将 jQuery 生成的`deferred`对象，转为一个新的 `Promise` 对象。\n\n`Promise.resolve`等价于下面的写法。\n\n``` js\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n#### Promise.reject()\n\n>`Promise.reject(reason)`方法也会返回一个新的 `Promise` 实例，该实例的状态为`rejected`。\n\n``` js\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n上面代码生成一个 `Promise` 对象的实例p，状态为`rejected`，回调函数会立即执行。\n\n**注意**，`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。这一点与`Promise.resolve`方法不一致。\n\n``` js\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n```\n\n上面代码中，`Promise.reject`方法的参数是一个`thenable`对象，执行以后，后面`catch`方法的参数不是`reject`抛出的“出错了”这个字符串，而是`thenable`对象。\n\n#### Promise.try()\n\n>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。\n\n>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\n>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。\n\n``` js\nPromise.try(database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n```\n","slug":"Promise","published":1,"updated":"2018-10-09T08:48:03.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn1lab5y0002ccujg0oo26ve","content":"<blockquote>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Promise-的含义\"><a href=\"#Promise-的含义\" class=\"headerlink\" title=\"Promise 的含义\"></a>Promise 的含义</h3><blockquote>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n</blockquote>\n<p>Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 <a href=\"https://nodejs.org/api/stream.html\" target=\"_blank\" rel=\"noopener\"><code>Stream</code></a> 模式是比部署 <code>Promise</code> 更好的选择。</p>\n<hr>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><blockquote>\n<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n</blockquote>\n<p>下面代码创造了一个<code>Promise</code>实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<blockquote>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>\n<p>下面是一个<code>Promise</code>对象的简单例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms, <span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">timeout(<span class=\"number\">100</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>\n<p><code>Promise</code> 新建后就会立即执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise</span></span><br><span class=\"line\"><span class=\"comment\">// Hi!</span></span><br><span class=\"line\"><span class=\"comment\">// resolved</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<p>下面是异步加载图片的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImageAsync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(image);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Could not load image at '</span> + url));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>\n<p>下面是一个用<code>Promise</code>对象实现的 <code>Ajax</code> 操作的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    client.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">    client.onreadystatechange = handler;</span><br><span class=\"line\">    client.responseType = <span class=\"string\">\"json\"</span>;</span><br><span class=\"line\">    client.setRequestHeader(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">    client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Contents: '</span> + json);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'出错了'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h4><blockquote>\n<p><code>Promise</code> 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用<code>funcA</code>，如果状态变为<code>rejected</code>，就调用<code>funcB</code>。</p>\n<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(</span><br><span class=\"line\">  post =&gt; getJSON(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  comments =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments),</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h4><blockquote>\n<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>getJSON</code>方法返回一个 <code>Promise</code> 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>\n<p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/post/1.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，一共有三个 <code>Promise</code> 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p>\n<p>一般来说，不要在<code>then</code>方法里面定义 <code>Reject</code> 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法<code>（try/catch）</code>。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p>\n<hr>\n<h4 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h4><blockquote>\n<p><code>finally</code>方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><blockquote>\n<p><code>Promise.all</code>方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 <code>Promise</code> 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 <code>Iterator</code> 接口，且返回的每个成员都是 <code>Promise</code> 实例。）</p>\n<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>\n<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>\n<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>\n<p>下面是一个具体的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成一个Promise对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(<span class=\"string\">'/post/'</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>promises</code>是包含 6 个 <code>Promise</code> 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<hr>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><blockquote>\n<p><code>Promise.race</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。</p>\n<p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 <code>Promise</code> 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">  fetch(<span class=\"string\">'/resource-that-may-take-a-while'</span>),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request timeout'</span>)), <span class=\"number\">5000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">.catch(<span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><blockquote>\n<p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve</code>方法就起到这个作用。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> jsPromise = <span class=\"built_in\">Promise</span>.resolve($.ajax(<span class=\"string\">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>\n<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 <code>Promise</code> 对象。</p>\n<p><code>Promise.resolve</code>等价于下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(<span class=\"string\">'foo'</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><blockquote>\n<p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n<p>上面代码生成一个 <code>Promise</code> 对象的实例p，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><strong>注意</strong>，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thenable = &#123;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(thenable)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e === thenable)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p>\n<h4 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h4><blockquote>\n<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。</p>\n</blockquote>\n<blockquote>\n<p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p>\n</blockquote>\n<blockquote>\n<p>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.try(database.users.get(&#123;<span class=\"attr\">id</span>: userId&#125;))</span><br><span class=\"line\">  .then(...)</span><br><span class=\"line\">  .catch(...)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>\n</blockquote>","more":"<h3 id=\"Promise-的含义\"><a href=\"#Promise-的含义\" class=\"headerlink\" title=\"Promise 的含义\"></a>Promise 的含义</h3><blockquote>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n</blockquote>\n<p>Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 <a href=\"https://nodejs.org/api/stream.html\" target=\"_blank\" rel=\"noopener\"><code>Stream</code></a> 模式是比部署 <code>Promise</code> 更好的选择。</p>\n<hr>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><blockquote>\n<p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n</blockquote>\n<p>下面代码创造了一个<code>Promise</code>实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<blockquote>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>\n<p>下面是一个<code>Promise</code>对象的简单例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(resolve, ms, <span class=\"string\">'done'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">timeout(<span class=\"number\">100</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>\n<p><code>Promise</code> 新建后就会立即执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise</span></span><br><span class=\"line\"><span class=\"comment\">// Hi!</span></span><br><span class=\"line\"><span class=\"comment\">// resolved</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<p>下面是异步加载图片的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImageAsync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(image);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Could not load image at '</span> + url));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>\n<p>下面是一个用<code>Promise</code>对象实现的 <code>Ajax</code> 操作的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    client.open(<span class=\"string\">\"GET\"</span>, url);</span><br><span class=\"line\">    client.onreadystatechange = handler;</span><br><span class=\"line\">    client.responseType = <span class=\"string\">\"json\"</span>;</span><br><span class=\"line\">    client.setRequestHeader(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"application/json\"</span>);</span><br><span class=\"line\">    client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Contents: '</span> + json);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'出错了'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h4><blockquote>\n<p><code>Promise</code> 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>\n</blockquote>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用<code>funcA</code>，如果状态变为<code>rejected</code>，就调用<code>funcB</code>。</p>\n<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(</span><br><span class=\"line\">  post =&gt; getJSON(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  comments =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"resolved: \"</span>, comments),</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"rejected: \"</span>, err)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h4><blockquote>\n<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>getJSON</code>方法返回一个 <code>Promise</code> 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>\n<p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/post/1.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，一共有三个 <code>Promise</code> 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p>\n<p>一般来说，不要在<code>then</code>方法里面定义 <code>Reject</code> 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法<code>（try/catch）</code>。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p>\n<hr>\n<h4 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h4><blockquote>\n<p><code>finally</code>方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><blockquote>\n<p><code>Promise.all</code>方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 <code>Promise</code> 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 <code>Iterator</code> 接口，且返回的每个成员都是 <code>Promise</code> 实例。）</p>\n<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>\n<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>\n<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>\n<p>下面是一个具体的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成一个Promise对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(<span class=\"string\">'/post/'</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>promises</code>是包含 6 个 <code>Promise</code> 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<hr>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><blockquote>\n<p><code>Promise.race</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。</p>\n<p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 <code>Promise</code> 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">  fetch(<span class=\"string\">'/resource-that-may-take-a-while'</span>),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request timeout'</span>)), <span class=\"number\">5000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">.catch(<span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><blockquote>\n<p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve</code>方法就起到这个作用。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> jsPromise = <span class=\"built_in\">Promise</span>.resolve($.ajax(<span class=\"string\">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>\n<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 <code>Promise</code> 对象。</p>\n<p><code>Promise.resolve</code>等价于下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(<span class=\"string\">'foo'</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><blockquote>\n<p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure>\n<p>上面代码生成一个 <code>Promise</code> 对象的实例p，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><strong>注意</strong>，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thenable = &#123;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(thenable)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e === thenable)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p>\n<h4 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h4><blockquote>\n<p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。</p>\n</blockquote>\n<blockquote>\n<p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p>\n</blockquote>\n<blockquote>\n<p>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.try(database.users.get(&#123;<span class=\"attr\">id</span>: userId&#125;))</span><br><span class=\"line\">  .then(...)</span><br><span class=\"line\">  .catch(...)</span><br></pre></td></tr></table></figure>"},{"title":"hexo常用指令","comments":1,"toc":true,"banner":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538053636652&di=0db3bc68fbdb79830a01281e006c9200&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3996696336%2C4120219149%26fm%3D214%26gp%3D0.jpg","description":"生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。","_content":"\nWelcome to [Hexo](https://hexo.io/)! \n<!--more-->\n\n## 开始使用 Install\n\n``` bash\n$ npm install hexo -g     # 安装  \n$ npm update hexo -g      # 升级  \n$ hexo init             # 初始化 \n```\n\n## 快速开始 Quick Start\n\n### 启动本地服务（查看效果）\n\n``` bash\n$ hexo server / $ hexo s\n```\n#### 服务器设置\n``` bash\n$ hexo server                        #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n$ hexo server -s                     #静态模式\n$ hexo server -p 5000                #更改端口\n$ hexo server -i 192.168.1.1         #自定义 IP\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate / $ hexo g           #使用 Hexo 生成静态文件快速而且简单\n$ hexo generate --watch              #监视文件变动\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 文章发布\nhexo 支持在github等平台上一键发布\n\n``` bash\n$ hexo deploy / $ hexo d\n```\n\n### 清空缓存及静态文件\n\n``` bash\n$ hexo clean\n```\n\n### 完成后部署\n\n``` bash\n$ hexo generate --deploy / hexo g --d\n$ hexo deploy --generate / hexo d --g\n```\n\n\n### 创建模板\n|   参数   |            描述            |\n|----------|----------------------------|\n| layout   | 布局                       |\n| data     | 创建时间                   |\n| title    | 标题                       |\n\n\n| layout：参数 |     描述     |     存储路径    |             说明            |\n|--------------|--------------|-----------------|-----------------------------|\n| post         | 文章（默认） | source/\\_posts   | 可以直接发布                |\n| draft        | 草稿         | source          | 在source下新建一个文件夹    |\n| page         | 页面         | source/\\_drafts | 新建文件将保存到 \\_drafts中 |\n\n\n``` bash\n$ hexo new [layout] <title>\n```\n#### 创建文章\n``` bash\n$ hexo new <title>\n$ hexo new \"postName\" #新建文章\n```\n#### 创建页面\n``` bash\n$ hexo new page <pageName>\n$ hexo new page \"pageName\" #新建页面\n```\n### 创建/发布草稿\n\n#### 创建草稿\n*会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。*\n\n``` bash\n$ hexo new draft \"new draft\"\n```\n\n*如果你希望强行预览草稿，更改配置文件 (_config.yml)：*\n\n``` bash\nrender_drafts: true\n```\n*或者，如下方式启动 server：*\n``` bash\n$ hexo server --drafts\n```\n\n#### 发布草稿\n\n``` bash\n$ hexo pushlish [layout] <title>\n$ hexo publish / $ hexo p\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### 指令组合执行 &\n\n通常开发测试要依次执行 hexo clean => hexo generate => hexo server, 我们可以通过指令组合执行来完成\n\n``` bash\nhexo clean & hexo g & hexo s\n```\n\n\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hexo常用指令.md","raw":"---\ntitle: hexo常用指令\ncomments: true\ntoc: true\ncategories: \"工具\"\nbanner: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538053636652&di=0db3bc68fbdb79830a01281e006c9200&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3996696336%2C4120219149%26fm%3D214%26gp%3D0.jpg\ntags:\n    - hexo\ndescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。\n---\n\nWelcome to [Hexo](https://hexo.io/)! \n<!--more-->\n\n## 开始使用 Install\n\n``` bash\n$ npm install hexo -g     # 安装  \n$ npm update hexo -g      # 升级  \n$ hexo init             # 初始化 \n```\n\n## 快速开始 Quick Start\n\n### 启动本地服务（查看效果）\n\n``` bash\n$ hexo server / $ hexo s\n```\n#### 服务器设置\n``` bash\n$ hexo server                        #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n$ hexo server -s                     #静态模式\n$ hexo server -p 5000                #更改端口\n$ hexo server -i 192.168.1.1         #自定义 IP\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### 生成静态文件\n\n``` bash\n$ hexo generate / $ hexo g           #使用 Hexo 生成静态文件快速而且简单\n$ hexo generate --watch              #监视文件变动\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 文章发布\nhexo 支持在github等平台上一键发布\n\n``` bash\n$ hexo deploy / $ hexo d\n```\n\n### 清空缓存及静态文件\n\n``` bash\n$ hexo clean\n```\n\n### 完成后部署\n\n``` bash\n$ hexo generate --deploy / hexo g --d\n$ hexo deploy --generate / hexo d --g\n```\n\n\n### 创建模板\n|   参数   |            描述            |\n|----------|----------------------------|\n| layout   | 布局                       |\n| data     | 创建时间                   |\n| title    | 标题                       |\n\n\n| layout：参数 |     描述     |     存储路径    |             说明            |\n|--------------|--------------|-----------------|-----------------------------|\n| post         | 文章（默认） | source/\\_posts   | 可以直接发布                |\n| draft        | 草稿         | source          | 在source下新建一个文件夹    |\n| page         | 页面         | source/\\_drafts | 新建文件将保存到 \\_drafts中 |\n\n\n``` bash\n$ hexo new [layout] <title>\n```\n#### 创建文章\n``` bash\n$ hexo new <title>\n$ hexo new \"postName\" #新建文章\n```\n#### 创建页面\n``` bash\n$ hexo new page <pageName>\n$ hexo new page \"pageName\" #新建页面\n```\n### 创建/发布草稿\n\n#### 创建草稿\n*会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。*\n\n``` bash\n$ hexo new draft \"new draft\"\n```\n\n*如果你希望强行预览草稿，更改配置文件 (_config.yml)：*\n\n``` bash\nrender_drafts: true\n```\n*或者，如下方式启动 server：*\n``` bash\n$ hexo server --drafts\n```\n\n#### 发布草稿\n\n``` bash\n$ hexo pushlish [layout] <title>\n$ hexo publish / $ hexo p\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### 指令组合执行 &\n\n通常开发测试要依次执行 hexo clean => hexo generate => hexo server, 我们可以通过指令组合执行来完成\n\n``` bash\nhexo clean & hexo g & hexo s\n```\n\n\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hexo常用指令","published":1,"date":"2018-09-25T07:22:27.762Z","updated":"2018-09-29T03:22:32.833Z","layout":"post","photos":[],"link":"","_id":"cjn1lab660006ccujxapkz60h","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>!<br><a id=\"more\"></a></p>\n<h2 id=\"开始使用-Install\"><a href=\"#开始使用-Install\" class=\"headerlink\" title=\"开始使用 Install\"></a>开始使用 Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo -g     <span class=\"comment\"># 安装  </span></span><br><span class=\"line\">$ npm update hexo -g      <span class=\"comment\"># 升级  </span></span><br><span class=\"line\">$ hexo init             <span class=\"comment\"># 初始化</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"快速开始-Quick-Start\"><a href=\"#快速开始-Quick-Start\" class=\"headerlink\" title=\"快速开始 Quick Start\"></a>快速开始 Quick Start</h2><h3 id=\"启动本地服务（查看效果）\"><a href=\"#启动本地服务（查看效果）\" class=\"headerlink\" title=\"启动本地服务（查看效果）\"></a>启动本地服务（查看效果）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server / $ hexo s</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务器设置\"><a href=\"#服务器设置\" class=\"headerlink\" title=\"服务器设置\"></a>服务器设置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server                        <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">$ hexo server -s                     <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">$ hexo server -p 5000                <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">$ hexo server -i 192.168.1.1         <span class=\"comment\">#自定义 IP</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate / $ hexo g           <span class=\"comment\">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class=\"line\">$ hexo generate --watch              <span class=\"comment\">#监视文件变动</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"文章发布\"><a href=\"#文章发布\" class=\"headerlink\" title=\"文章发布\"></a>文章发布</h3><p>hexo 支持在github等平台上一键发布</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy / $ hexo d</span><br></pre></td></tr></table></figure>\n<h3 id=\"清空缓存及静态文件\"><a href=\"#清空缓存及静态文件\" class=\"headerlink\" title=\"清空缓存及静态文件\"></a>清空缓存及静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate --deploy / hexo g --d</span><br><span class=\"line\">$ hexo deploy --generate / hexo d --g</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建模板\"><a href=\"#创建模板\" class=\"headerlink\" title=\"创建模板\"></a>创建模板</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>data</td>\n<td>创建时间</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>layout：参数</th>\n<th>描述</th>\n<th>存储路径</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>post</td>\n<td>文章（默认）</td>\n<td>source/_posts</td>\n<td>可以直接发布</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>草稿</td>\n<td>source</td>\n<td>在source下新建一个文件夹</td>\n</tr>\n<tr>\n<td>page</td>\n<td>页面</td>\n<td>source/_drafts</td>\n<td>新建文件将保存到 _drafts中</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &lt;title&gt;</span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建页面\"><a href=\"#创建页面\" class=\"headerlink\" title=\"创建页面\"></a>创建页面</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &lt;pageName&gt;</span><br><span class=\"line\">$ hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-发布草稿\"><a href=\"#创建-发布草稿\" class=\"headerlink\" title=\"创建/发布草稿\"></a>创建/发布草稿</h3><h4 id=\"创建草稿\"><a href=\"#创建草稿\" class=\"headerlink\" title=\"创建草稿\"></a>创建草稿</h4><p><em>会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new draft <span class=\"string\">\"new draft\"</span></span><br></pre></td></tr></table></figure>\n<p><em>如果你希望强行预览草稿，更改配置文件 (_config.yml)：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render_drafts: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><em>或者，如下方式启动 server：</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server --drafts</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"发布草稿\"></a>发布草稿</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo pushlish [layout] &lt;title&gt;</span><br><span class=\"line\">$ hexo publish / $ hexo p</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"指令组合执行-amp\"><a href=\"#指令组合执行-amp\" class=\"headerlink\" title=\"指令组合执行 &amp;\"></a>指令组合执行 &amp;</h3><p>通常开发测试要依次执行 hexo clean =&gt; hexo generate =&gt; hexo server, 我们可以通过指令组合执行来完成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>!<br></p>","more":"<p></p>\n<h2 id=\"开始使用-Install\"><a href=\"#开始使用-Install\" class=\"headerlink\" title=\"开始使用 Install\"></a>开始使用 Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo -g     <span class=\"comment\"># 安装  </span></span><br><span class=\"line\">$ npm update hexo -g      <span class=\"comment\"># 升级  </span></span><br><span class=\"line\">$ hexo init             <span class=\"comment\"># 初始化</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"快速开始-Quick-Start\"><a href=\"#快速开始-Quick-Start\" class=\"headerlink\" title=\"快速开始 Quick Start\"></a>快速开始 Quick Start</h2><h3 id=\"启动本地服务（查看效果）\"><a href=\"#启动本地服务（查看效果）\" class=\"headerlink\" title=\"启动本地服务（查看效果）\"></a>启动本地服务（查看效果）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server / $ hexo s</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务器设置\"><a href=\"#服务器设置\" class=\"headerlink\" title=\"服务器设置\"></a>服务器设置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server                        <span class=\"comment\">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class=\"line\">$ hexo server -s                     <span class=\"comment\">#静态模式</span></span><br><span class=\"line\">$ hexo server -p 5000                <span class=\"comment\">#更改端口</span></span><br><span class=\"line\">$ hexo server -i 192.168.1.1         <span class=\"comment\">#自定义 IP</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate / $ hexo g           <span class=\"comment\">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class=\"line\">$ hexo generate --watch              <span class=\"comment\">#监视文件变动</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"文章发布\"><a href=\"#文章发布\" class=\"headerlink\" title=\"文章发布\"></a>文章发布</h3><p>hexo 支持在github等平台上一键发布</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy / $ hexo d</span><br></pre></td></tr></table></figure>\n<h3 id=\"清空缓存及静态文件\"><a href=\"#清空缓存及静态文件\" class=\"headerlink\" title=\"清空缓存及静态文件\"></a>清空缓存及静态文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h3 id=\"完成后部署\"><a href=\"#完成后部署\" class=\"headerlink\" title=\"完成后部署\"></a>完成后部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate --deploy / hexo g --d</span><br><span class=\"line\">$ hexo deploy --generate / hexo d --g</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建模板\"><a href=\"#创建模板\" class=\"headerlink\" title=\"创建模板\"></a>创建模板</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n</tr>\n<tr>\n<td>data</td>\n<td>创建时间</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>layout：参数</th>\n<th>描述</th>\n<th>存储路径</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>post</td>\n<td>文章（默认）</td>\n<td>source/_posts</td>\n<td>可以直接发布</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>草稿</td>\n<td>source</td>\n<td>在source下新建一个文件夹</td>\n</tr>\n<tr>\n<td>page</td>\n<td>页面</td>\n<td>source/_drafts</td>\n<td>新建文件将保存到 _drafts中</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &lt;title&gt;</span><br><span class=\"line\">$ hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建页面\"><a href=\"#创建页面\" class=\"headerlink\" title=\"创建页面\"></a>创建页面</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &lt;pageName&gt;</span><br><span class=\"line\">$ hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-发布草稿\"><a href=\"#创建-发布草稿\" class=\"headerlink\" title=\"创建/发布草稿\"></a>创建/发布草稿</h3><h4 id=\"创建草稿\"><a href=\"#创建草稿\" class=\"headerlink\" title=\"创建草稿\"></a>创建草稿</h4><p><em>会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new draft <span class=\"string\">\"new draft\"</span></span><br></pre></td></tr></table></figure>\n<p><em>如果你希望强行预览草稿，更改配置文件 (_config.yml)：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render_drafts: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><em>或者，如下方式启动 server：</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server --drafts</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"发布草稿\"></a>发布草稿</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo pushlish [layout] &lt;title&gt;</span><br><span class=\"line\">$ hexo publish / $ hexo p</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"指令组合执行-amp\"><a href=\"#指令组合执行-amp\" class=\"headerlink\" title=\"指令组合执行 &amp;\"></a>指令组合执行 &amp;</h3><p>通常开发测试要依次执行 hexo clean =&gt; hexo generate =&gt; hexo server, 我们可以通过指令组合执行来完成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"hexo 创建文章 & 文章缩略图及banner & MarkDown","date":"2018-09-27T06:29:09.000Z","comments":1,"toc":true,"thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538137142415&di=6ea66fbfbb708b7280625217af646afb&imgtype=0&src=http%3A%2F%2Fi1.hdslb.com%2Fvideo%2F08%2F086510262d86a381a52a3651174dbd4d.jpg","<!-- banner":"/bolg/2018/09/27/hexo-创建文章/banner.jpg -->","_content":"\nhexo 文章的创建及markdown语法\n<!--more-->\n\n## hexo 创建文章\n命令行输入：\n``` bash\n$ hexo new \"new article\"\n```\n\n之后在source/_posts目录下面，多了一个new-article.md的文件。\n打开后：\n``` bash\n---\ntitle: new article\ndate: 2018-09-28 20:10:33\ntags:\n---\n\n```\n文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。\n**新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。**\n\n\n***\n\n### 属性\n\t文章可以拥有如下属性：\n\n|  Setting   |        Description        |    Default     |\n|------------|---------------------------|----------------|\n| layout     | layout                    | post或page     |\n| title      | 文章标题                  | 文件名         |\n| date       | 创建日期                  | 文件的创建日期 |\n| updated    | 修改日期                  | 文件的修改日期 |\n| comments   | 是否开启评论              | true           |\n| tags       | 标签                      | NULL           |\n| categories | 分类                      | NULL           |\n| permalink  | url中的名字               | 文件名         |\n| thumbnail  | 文章缩略图                | NULL           |\n| banner     | 文章缩略图&文章首部banner | NULL           |\n\n***\n\n### 分类和标签\n\n\t分类只有一个，但标签可以有多个且有两种写法如下：\n\n``` bash\n---\n...\ncategories: \"工具\"\ntags:\n    - hexo\n    - markdown\n    - 前端\n# 或者\n# tags: [hexo, markdown, 前端]\n---\n```\n***\n\n## 文章缩略图和banner\n**注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考**\n当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；\n当只设置 thumbnail 时， 文章只有缩略图，无banner\n当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；\n\n\t设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n![文件目录](hexo-创建文章/wenjian.jpg)\n\t或者修改配置文件\\_config.yml\n``` bash\npost_asset_folder: true # 创建时生成静态资源文件夹\n```\n此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner\n\n### 文章缩略图设置：\n![文章缩略图](hexo-创建文章/suoluetu.png)\n``` bash\n---\n...\nthumbnail: https://...        # 此处为图片地址\n---\n```\n\n***\n\n### 文章banner设置：\n![文章banner](hexo-创建文章/banner.jpg)\n``` bash\n---\n...\nbanner: https://...           # 此处为图片地址\n---\n```\n***注： 若引用本地图片时，需要加上路径前缀，如下图：***\n![路径](hexo-创建文章/lujing.jpg)\n![目录](hexo-创建文章/lujing2.jpg)\n\t\n\t则引用路径为：\n``` bash\nbanner: /bolg/2018/09/27/hexo-创建文章/banner.jpg\n```\n\n***\n\n## MarkDown 语法\n\n### 斜体和粗体\n``` bash\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n```\n\n\t效果\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n\n***\n\n### 分级标题\n``` bash\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n<!-- \t效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n\n***\n\n### 超链接\n``` bash\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://kevinpu.github.io/\n[2]:http://www.jianshu.com/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n```\n\t\n\t效果\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://zhangjichengcc.github.io/bolg/\n[2]:https://zhangjichengcc.github.io/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n\n\n***\n\n### 列表\n#### 无序列表：\n``` bash\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n```\n\n\t效果\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n\n#### 有序列表\n``` bash\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n```\n\n\t效果\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n\n***\n\n### 插入图片\n``` bash\n![文字说明](/images/...)\n```\n\n***\n\n### 表格\n``` bash\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n```\n\n\t效果\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n\n***\n\n### code\n``` bash\n``` bash\n...code 主体\n```\n\n\t效果\n``` bash\n...code 主体\n```\n\n### 引用\n``` bash\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用\n```\n\t效果\n\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用","source":"_posts/hexo-创建文章.md","raw":"---\ntitle: hexo 创建文章 & 文章缩略图及banner & MarkDown\ndate: 2018-09-27 14:29:09\ncomments: true\ntoc: true\ncategories: \"工具\"\nthumbnail: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538137142415&di=6ea66fbfbb708b7280625217af646afb&imgtype=0&src=http%3A%2F%2Fi1.hdslb.com%2Fvideo%2F08%2F086510262d86a381a52a3651174dbd4d.jpg\n<!-- banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg -->\n\ntags: [hexo, markdown, 前端]\n---\n\nhexo 文章的创建及markdown语法\n<!--more-->\n\n## hexo 创建文章\n命令行输入：\n``` bash\n$ hexo new \"new article\"\n```\n\n之后在source/_posts目录下面，多了一个new-article.md的文件。\n打开后：\n``` bash\n---\ntitle: new article\ndate: 2018-09-28 20:10:33\ntags:\n---\n\n```\n文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。\n**新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。**\n\n\n***\n\n### 属性\n\t文章可以拥有如下属性：\n\n|  Setting   |        Description        |    Default     |\n|------------|---------------------------|----------------|\n| layout     | layout                    | post或page     |\n| title      | 文章标题                  | 文件名         |\n| date       | 创建日期                  | 文件的创建日期 |\n| updated    | 修改日期                  | 文件的修改日期 |\n| comments   | 是否开启评论              | true           |\n| tags       | 标签                      | NULL           |\n| categories | 分类                      | NULL           |\n| permalink  | url中的名字               | 文件名         |\n| thumbnail  | 文章缩略图                | NULL           |\n| banner     | 文章缩略图&文章首部banner | NULL           |\n\n***\n\n### 分类和标签\n\n\t分类只有一个，但标签可以有多个且有两种写法如下：\n\n``` bash\n---\n...\ncategories: \"工具\"\ntags:\n    - hexo\n    - markdown\n    - 前端\n# 或者\n# tags: [hexo, markdown, 前端]\n---\n```\n***\n\n## 文章缩略图和banner\n**注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考**\n当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；\n当只设置 thumbnail 时， 文章只有缩略图，无banner\n当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；\n\n\t设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n![文件目录](hexo-创建文章/wenjian.jpg)\n\t或者修改配置文件\\_config.yml\n``` bash\npost_asset_folder: true # 创建时生成静态资源文件夹\n```\n此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner\n\n### 文章缩略图设置：\n![文章缩略图](hexo-创建文章/suoluetu.png)\n``` bash\n---\n...\nthumbnail: https://...        # 此处为图片地址\n---\n```\n\n***\n\n### 文章banner设置：\n![文章banner](hexo-创建文章/banner.jpg)\n``` bash\n---\n...\nbanner: https://...           # 此处为图片地址\n---\n```\n***注： 若引用本地图片时，需要加上路径前缀，如下图：***\n![路径](hexo-创建文章/lujing.jpg)\n![目录](hexo-创建文章/lujing2.jpg)\n\t\n\t则引用路径为：\n``` bash\nbanner: /bolg/2018/09/27/hexo-创建文章/banner.jpg\n```\n\n***\n\n## MarkDown 语法\n\n### 斜体和粗体\n``` bash\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n```\n\n\t效果\n*这是斜体* 或 _这也是斜体_ \n**这是粗体**\n***这是加粗斜体***\n~~这是删除线~~\n\n***\n\n### 分级标题\n``` bash\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n<!-- \t效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n\n***\n\n### 超链接\n``` bash\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://kevinpu.github.io/\n[2]:http://www.jianshu.com/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n```\n\t\n\t效果\n行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)\n参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]\n[1]:https://zhangjichengcc.github.io/bolg/\n[2]:https://zhangjichengcc.github.io/\n自动链接：我的博客地址<https://zhangjichengcc.github.io/bolg/>\n\n\n***\n\n### 列表\n#### 无序列表：\n``` bash\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n```\n\n\t效果\n* 无序列表项1\n+ 无序列表项2\n- 无序列表项3\n\n#### 有序列表\n``` bash\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n```\n\n\t效果\n1.有序列表项1\n2.有序列表项2\n3.有序列表项3\n\n***\n\n### 插入图片\n``` bash\n![文字说明](/images/...)\n```\n\n***\n\n### 表格\n``` bash\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n```\n\n\t效果\n| 表头1|表头2|表头3|表头4\n|-| :- | :-: | -: |\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n|默认左对齐|左对齐|居中对齐|右对齐|\n\n***\n\n### code\n``` bash\n``` bash\n...code 主体\n```\n\n\t效果\n``` bash\n...code 主体\n```\n\n### 引用\n``` bash\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用\n```\n\t效果\n\n>这是引用\n这是引用\n这是引用\n>>不！我才是引用","slug":"hexo-创建文章","published":1,"updated":"2018-10-08T02:53:53.485Z","layout":"post","photos":[],"link":"","_id":"cjn1lab6d0007ccuje6ddj0pw","content":"<p>hexo 文章的创建及markdown语法<br><a id=\"more\"></a></p>\n<h2 id=\"hexo-创建文章\"><a href=\"#hexo-创建文章\" class=\"headerlink\" title=\"hexo 创建文章\"></a>hexo 创建文章</h2><p>命令行输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"new article\"</span></span><br></pre></td></tr></table></figure></p>\n<p>之后在source/_posts目录下面，多了一个new-article.md的文件。<br>打开后：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: new article</span><br><span class=\"line\">date: 2018-09-28 20:10:33</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。<br><strong>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。</strong></p>\n<hr>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><pre><code>文章可以拥有如下属性：\n</code></pre><table>\n<thead>\n<tr>\n<th>Setting</th>\n<th>Description</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>layout</td>\n<td>post或page</td>\n</tr>\n<tr>\n<td>title</td>\n<td>文章标题</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>date</td>\n<td>创建日期</td>\n<td>文件的创建日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>修改日期</td>\n<td>文件的修改日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>是否开启评论</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>url中的名字</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>thumbnail</td>\n<td>文章缩略图</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>banner</td>\n<td>文章缩略图&amp;文章首部banner</td>\n<td>NULL</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h3><pre><code>分类只有一个，但标签可以有多个且有两种写法如下：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">categories: <span class=\"string\">\"工具\"</span></span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">    - markdown</span><br><span class=\"line\">    - 前端</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"comment\"># tags: [hexo, markdown, 前端]</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"文章缩略图和banner\"><a href=\"#文章缩略图和banner\" class=\"headerlink\" title=\"文章缩略图和banner\"></a>文章缩略图和banner</h2><p><strong>注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考</strong><br>当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；<br>当只设置 thumbnail 时， 文章只有缩略图，无banner<br>当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；</p>\n<pre><code>设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n</code></pre><p><img src=\"/bolg/2018/09/27/hexo-创建文章/wenjian.jpg\" alt=\"文件目录\"><br>    或者修改配置文件_config.yml<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: <span class=\"literal\">true</span> <span class=\"comment\"># 创建时生成静态资源文件夹</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner</p>\n<h3 id=\"文章缩略图设置：\"><a href=\"#文章缩略图设置：\" class=\"headerlink\" title=\"文章缩略图设置：\"></a>文章缩略图设置：</h3><p><img src=\"/bolg/2018/09/27/hexo-创建文章/suoluetu.png\" alt=\"文章缩略图\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">thumbnail: https://...        <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"文章banner设置：\"><a href=\"#文章banner设置：\" class=\"headerlink\" title=\"文章banner设置：\"></a>文章banner设置：</h3><p><img src=\"/bolg/2018/09/27/hexo-创建文章/banner.jpg\" alt=\"文章banner\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">banner: https://...           <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>注： 若引用本地图片时，需要加上路径前缀，如下图：</em></strong><br><img src=\"/bolg/2018/09/27/hexo-创建文章/lujing.jpg\" alt=\"路径\"><br><img src=\"/bolg/2018/09/27/hexo-创建文章/lujing2.jpg\" alt=\"目录\"></p>\n<pre><code>则引用路径为：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"MarkDown-语法\"><a href=\"#MarkDown-语法\" class=\"headerlink\" title=\"MarkDown 语法\"></a>MarkDown 语法</h2><h3 id=\"斜体和粗体\"><a href=\"#斜体和粗体\" class=\"headerlink\" title=\"斜体和粗体\"></a>斜体和粗体</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*这是斜体* 或 _这也是斜体_ </span><br><span class=\"line\">**这是粗体**</span><br><span class=\"line\">***这是加粗斜体***</span><br><span class=\"line\">~~这是删除线~~</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del></p>\n<hr>\n<h3 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一级标题</span></span><br><span class=\"line\"><span class=\"comment\">## 二级标题</span></span><br><span class=\"line\"><span class=\"comment\">### 三级标题</span></span><br><span class=\"line\"><span class=\"comment\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"comment\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"comment\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<!--     效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n<hr>\n<h3 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)</span><br><span class=\"line\">参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]</span><br><span class=\"line\">[1]:https://kevinpu.github.io/</span><br><span class=\"line\">[2]:http://www.jianshu.com/</span><br><span class=\"line\">自动链接：我的博客地址&lt;https://zhangjichengcc.github.io/bolg/&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>行内形式：<a href=\"https://zhangjichengcc.github.io/bolg/\">我的博客</a><br>参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]<br>[1]:<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a><br>[2]:<a href=\"https://zhangjichengcc.github.io/\">https://zhangjichengcc.github.io/</a><br>自动链接：我的博客地址<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a></p>\n<hr>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"无序列表：\"><a href=\"#无序列表：\" class=\"headerlink\" title=\"无序列表：\"></a>无序列表：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 无序列表项1</span><br><span class=\"line\">+ 无序列表项2</span><br><span class=\"line\">- 无序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><ul>\n<li>无序列表项1</li>\n</ul>\n<ul>\n<li>无序列表项2</li>\n</ul>\n<ul>\n<li>无序列表项3</li>\n</ul>\n<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.有序列表项1</span><br><span class=\"line\">2.有序列表项2</span><br><span class=\"line\">3.有序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p>\n<hr>\n<h3 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![文字说明](/images/...)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 表头1|表头2|表头3|表头4</span><br><span class=\"line\">|-| :- | :-: | -: |</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th style=\"text-align:left\">表头2</th>\n<th style=\"text-align:center\">表头3</th>\n<th style=\"text-align:right\">表头4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">``` bash</span><br><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">&gt;&gt;不！我才是引用</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><blockquote>\n<p>这是引用<br>这是引用<br>这是引用</p>\n<blockquote>\n<p>不！我才是引用</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>hexo 文章的创建及markdown语法<br></p>","more":"<p></p>\n<h2 id=\"hexo-创建文章\"><a href=\"#hexo-创建文章\" class=\"headerlink\" title=\"hexo 创建文章\"></a>hexo 创建文章</h2><p>命令行输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"new article\"</span></span><br></pre></td></tr></table></figure></p>\n<p>之后在source/_posts目录下面，多了一个new-article.md的文件。<br>打开后：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: new article</span><br><span class=\"line\">date: 2018-09-28 20:10:33</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。<br><strong>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。</strong></p>\n<hr>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><pre><code>文章可以拥有如下属性：\n</code></pre><table>\n<thead>\n<tr>\n<th>Setting</th>\n<th>Description</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>layout</td>\n<td>post或page</td>\n</tr>\n<tr>\n<td>title</td>\n<td>文章标题</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>date</td>\n<td>创建日期</td>\n<td>文件的创建日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>修改日期</td>\n<td>文件的修改日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>是否开启评论</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>url中的名字</td>\n<td>文件名</td>\n</tr>\n<tr>\n<td>thumbnail</td>\n<td>文章缩略图</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>banner</td>\n<td>文章缩略图&amp;文章首部banner</td>\n<td>NULL</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"分类和标签\"><a href=\"#分类和标签\" class=\"headerlink\" title=\"分类和标签\"></a>分类和标签</h3><pre><code>分类只有一个，但标签可以有多个且有两种写法如下：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">categories: <span class=\"string\">\"工具\"</span></span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">    - markdown</span><br><span class=\"line\">    - 前端</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\"><span class=\"comment\"># tags: [hexo, markdown, 前端]</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"文章缩略图和banner\"><a href=\"#文章缩略图和banner\" class=\"headerlink\" title=\"文章缩略图和banner\"></a>文章缩略图和banner</h2><p><strong>注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考</strong><br>当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；<br>当只设置 thumbnail 时， 文章只有缩略图，无banner<br>当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效；</p>\n<pre><code>设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图；\n</code></pre><p><img src=\"/bolg/2018/09/27/hexo-创建文章/wenjian.jpg\" alt=\"文件目录\"><br>    或者修改配置文件_config.yml<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: <span class=\"literal\">true</span> <span class=\"comment\"># 创建时生成静态资源文件夹</span></span><br></pre></td></tr></table></figure></p>\n<p>此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner</p>\n<h3 id=\"文章缩略图设置：\"><a href=\"#文章缩略图设置：\" class=\"headerlink\" title=\"文章缩略图设置：\"></a>文章缩略图设置：</h3><p><img src=\"/bolg/2018/09/27/hexo-创建文章/suoluetu.png\" alt=\"文章缩略图\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">thumbnail: https://...        <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"文章banner设置：\"><a href=\"#文章banner设置：\" class=\"headerlink\" title=\"文章banner设置：\"></a>文章banner设置：</h3><p><img src=\"/bolg/2018/09/27/hexo-创建文章/banner.jpg\" alt=\"文章banner\"><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">...</span><br><span class=\"line\">banner: https://...           <span class=\"comment\"># 此处为图片地址</span></span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>注： 若引用本地图片时，需要加上路径前缀，如下图：</em></strong><br><img src=\"/bolg/2018/09/27/hexo-创建文章/lujing.jpg\" alt=\"路径\"><br><img src=\"/bolg/2018/09/27/hexo-创建文章/lujing2.jpg\" alt=\"目录\"></p>\n<pre><code>则引用路径为：\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"MarkDown-语法\"><a href=\"#MarkDown-语法\" class=\"headerlink\" title=\"MarkDown 语法\"></a>MarkDown 语法</h2><h3 id=\"斜体和粗体\"><a href=\"#斜体和粗体\" class=\"headerlink\" title=\"斜体和粗体\"></a>斜体和粗体</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*这是斜体* 或 _这也是斜体_ </span><br><span class=\"line\">**这是粗体**</span><br><span class=\"line\">***这是加粗斜体***</span><br><span class=\"line\">~~这是删除线~~</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del></p>\n<hr>\n<h3 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一级标题</span></span><br><span class=\"line\"><span class=\"comment\">## 二级标题</span></span><br><span class=\"line\"><span class=\"comment\">### 三级标题</span></span><br><span class=\"line\"><span class=\"comment\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"comment\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"comment\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<!--     效果\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 -->\n<hr>\n<h3 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)</span><br><span class=\"line\">参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]</span><br><span class=\"line\">[1]:https://kevinpu.github.io/</span><br><span class=\"line\">[2]:http://www.jianshu.com/</span><br><span class=\"line\">自动链接：我的博客地址&lt;https://zhangjichengcc.github.io/bolg/&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>行内形式：<a href=\"https://zhangjichengcc.github.io/bolg/\">我的博客</a><br>参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2]<br>[1]:<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a><br>[2]:<a href=\"https://zhangjichengcc.github.io/\">https://zhangjichengcc.github.io/</a><br>自动链接：我的博客地址<a href=\"https://zhangjichengcc.github.io/bolg/\">https://zhangjichengcc.github.io/bolg/</a></p>\n<hr>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"无序列表：\"><a href=\"#无序列表：\" class=\"headerlink\" title=\"无序列表：\"></a>无序列表：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 无序列表项1</span><br><span class=\"line\">+ 无序列表项2</span><br><span class=\"line\">- 无序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><ul>\n<li>无序列表项1</li>\n</ul>\n<ul>\n<li>无序列表项2</li>\n</ul>\n<ul>\n<li>无序列表项3</li>\n</ul>\n<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.有序列表项1</span><br><span class=\"line\">2.有序列表项2</span><br><span class=\"line\">3.有序列表项3</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><p>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p>\n<hr>\n<h3 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![文字说明](/images/...)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 表头1|表头2|表头3|表头4</span><br><span class=\"line\">|-| :- | :-: | -: |</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br><span class=\"line\">|默认左对齐|左对齐|居中对齐|右对齐|</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><table>\n<thead>\n<tr>\n<th>表头1</th>\n<th style=\"text-align:left\">表头2</th>\n<th style=\"text-align:center\">表头3</th>\n<th style=\"text-align:right\">表头4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n<tr>\n<td>默认左对齐</td>\n<td style=\"text-align:left\">左对齐</td>\n<td style=\"text-align:center\">居中对齐</td>\n<td style=\"text-align:right\">右对齐</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">``` bash</span><br><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...code 主体</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">这是引用</span><br><span class=\"line\">&gt;&gt;不！我才是引用</span><br></pre></td></tr></table></figure>\n<pre><code>效果\n</code></pre><blockquote>\n<p>这是引用<br>这是引用<br>这是引用</p>\n<blockquote>\n<p>不！我才是引用</p>\n</blockquote>\n</blockquote>"},{"title":"js构造函数","date":"2018-10-09T08:53:48.000Z","toc":true,"banner":"/bolg/2018/10/09/js构造函数/banner.jpg","_content":"\n\n前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法[js构造函数][1]，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~\n\n<!-- more -->\n\n### 原型\n首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文\n\n``` js\nfunction Persion(name){\n  this.name = name;                         // 属性\n  this.setName = function(nameName){        // 实例方法\n    this.name = newName;\n  }\n}\nPersion.prototype.sex = 'man';              // 向 Persion 原型中追加属性（原型方法）\n\nvar persion = new Persion('zhang');         // 此时我们实例化一个persion对象，看一下name和sex有什么区别\n```\n\n通过 prototype 添加的属性将出现在实例对象的原型链中，\n\n>每个对象都会有一个内置 __proto__ 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）\n\n我们再来看下面的例子\n\n>**注意**：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。\n\n``` js\nfunction Animal(n) {                      // 声明一个构造函数\n  this.name = n;             \t\t\t\t\t    // 实例属性\n  this.arr = [];                          // 实例属性（引用类型）\n  this.say = function(){                  // 实例方法\n    return 'hello world';\n  }\n}\n  Animal.prototype.sing = function() {    // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];               // 追加原型属性（引用类型）\n```\n\n接下来我们看一下实例属性/方法 和 原型属性/方法的区别\n\n>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。\n\n\n``` js\nvar cat = new Animal('cat');               // 实例化cat对象\nvar dog = new Animal('dog');\t             // 实例化狗子对象\n\ncat.say === dog.say                        // false 不同的实例拥有不同的实例属性/方法\ncat.sing === dog.sing                      // true 不同的实例共享相同的原型属性/方法\n\ncat.arr.push('zz');                        // 向cat实例对象的arr中追加元素；（私有）\ncat.pArr.push('xx');                       // 向cat原型对象的pArr中追加元素；（共享）\nconsole.log(dog.arr);                      // 打印出 []，因为cat只改变了其私有的arr\nconsole.log(dog.pArr);                             // 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr\n```\n\n当然，原型属性为基本数据类型，则不会被共享\n在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：\n1、将属性封装在构造函数中\n2、将方法定义在原型对象上\n\n### ES5继承方式\n\n首先，我们定义一个Animal父类\n\n``` js\nfunction Animal(n) {          \t\t\t\t\t\n  this.name = n;                            // 实例属性\n  this.arr = [];                            // 实例属性（引用类型）\n  this.say = function(){                    // 实例方法\n    return 'hello world';\n  }\n}\nAnimal.prototype.sing = function() {        // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];                 // 追加原型属性（引用类型）\n```\n\n#### 原型链继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;\n}\nCat.prototype = new Animal();                // 父类的实例作为子类的原型对象\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；\n```\n\n优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；\n缺点: 子类实例共享了父类构造函数的引用数据类型属性。\n\n#### 借用构造函数\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);             // 核心，把父类的实例方法属性指向子类\n}\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                  // undefind 无法继承父类的原型属性及方法；\n```\n\n优点: \n1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；\n2、 创建子类实例，可以向父类构造函数传参数；\n缺点: 子类实例不能继承父类的构造属性和方法；\n\n#### 组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);              // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = new Parent()                  // 核心, 父类的实例作为子类的原型对象\nCat.prototype.constructor = Cat;              // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                       // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                   // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；\n3、不共享父类的构造方法及属性；\n缺点: 调用了2次父类的构造方法\n\n#### 寄生组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                       // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = Parent.prototype;                      // 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）\nCat.prototype.constructor = Cat;                       // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                            // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\ntom.pArr.push('publish');                              // 修改继承于父类原型属性值 pArr;\nconsole.log(black.pArr);                               // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，\n// 至此简直是完美呀~~~ 然鹅！\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                      // 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、子类的实例不共享父类的构造方法及属性；\n3、只调用了1次父类的构造方法；\n缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；\n\n#### 寄生组合继承（简直完美）\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                        // 核心，把父类的实例方法属性指向子类；\n}\nvar F = function(){};                                   // 核心，利用空对象作为中介；\nF.prototype = Parent.prototype;                         // 核心，将父类的原型赋值给空对象F；\nCat.prototype = new F();                                // 核心，将F的实例赋值给子类；\nCat.prototype.constructor = Cat;                        // 修复子类Cat的构造器指向，防止原型链的混乱；\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                 // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                             // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；\ntom.pArr.push('publish');                               // 修改继承于父类原型属性值 pArr；\nconsole.log(black.pArr);                                // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                       // undefind  父类实例化的对象不拥有子类的原型属性/方法；\n```\n\n优点: 完美实现继承；\n缺点:实现相对复杂\n\n\n#### 附YUI库实现继承\n\n``` js\nfunction extend(Child, Parent) {\n  var F = function(){};\n  F.prototype = Parent.prototype;\n  hild.prototype = new F();\n  Child.prototype.constructor = Child;\n  Child.uber = Parent.prototype;                          \n}\n// 使用\nextend(Cat,Animal);\n```\n\n>`Child.uber = Parent.prototype;` 的意思是为子对象设一个uber属性，这个属性直接指向父对象的`prototype`属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n\n### ES6继承方式\n\n``` js\nclass Animal{                             // 父类\n  constructor(name){                      // 构造函数\n    this.name=name;\n  }\n  eat(){                                  // 实例方法\n    return 'hello world';\n  }\n}\nclass Cat extends Animal{                 // 子类\n  constructor(name){\n    super(name);                          // 调用实现父类的构造函数\n    this.pName = name;            \n  }\n  sing(){\n \t return '吹呀吹呀，我的骄傲放纵~~';\n  }\n}\n```\n\n[1]: https://segmentfault.com/a/1190000015343232\n","source":"_posts/js构造函数.md","raw":"---\ntitle: 'js构造函数'\ndate: 2018-10-09 16:53:48\ncategories: '笔记'\ntoc: true\nbanner: /bolg/2018/10/09/js构造函数/banner.jpg\ntags:\n\t- js\n---\n\n\n前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法[js构造函数][1]，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~\n\n<!-- more -->\n\n### 原型\n首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文\n\n``` js\nfunction Persion(name){\n  this.name = name;                         // 属性\n  this.setName = function(nameName){        // 实例方法\n    this.name = newName;\n  }\n}\nPersion.prototype.sex = 'man';              // 向 Persion 原型中追加属性（原型方法）\n\nvar persion = new Persion('zhang');         // 此时我们实例化一个persion对象，看一下name和sex有什么区别\n```\n\n通过 prototype 添加的属性将出现在实例对象的原型链中，\n\n>每个对象都会有一个内置 __proto__ 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）\n\n我们再来看下面的例子\n\n>**注意**：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。\n\n``` js\nfunction Animal(n) {                      // 声明一个构造函数\n  this.name = n;             \t\t\t\t\t    // 实例属性\n  this.arr = [];                          // 实例属性（引用类型）\n  this.say = function(){                  // 实例方法\n    return 'hello world';\n  }\n}\n  Animal.prototype.sing = function() {    // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];               // 追加原型属性（引用类型）\n```\n\n接下来我们看一下实例属性/方法 和 原型属性/方法的区别\n\n>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。\n\n\n``` js\nvar cat = new Animal('cat');               // 实例化cat对象\nvar dog = new Animal('dog');\t             // 实例化狗子对象\n\ncat.say === dog.say                        // false 不同的实例拥有不同的实例属性/方法\ncat.sing === dog.sing                      // true 不同的实例共享相同的原型属性/方法\n\ncat.arr.push('zz');                        // 向cat实例对象的arr中追加元素；（私有）\ncat.pArr.push('xx');                       // 向cat原型对象的pArr中追加元素；（共享）\nconsole.log(dog.arr);                      // 打印出 []，因为cat只改变了其私有的arr\nconsole.log(dog.pArr);                             // 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr\n```\n\n当然，原型属性为基本数据类型，则不会被共享\n在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：\n1、将属性封装在构造函数中\n2、将方法定义在原型对象上\n\n### ES5继承方式\n\n首先，我们定义一个Animal父类\n\n``` js\nfunction Animal(n) {          \t\t\t\t\t\n  this.name = n;                            // 实例属性\n  this.arr = [];                            // 实例属性（引用类型）\n  this.say = function(){                    // 实例方法\n    return 'hello world';\n  }\n}\nAnimal.prototype.sing = function() {        // 追加原型方法  \n  return '吹呀吹呀，我的骄傲放纵~~';\n}\nAnimal.prototype.pArr = [];                 // 追加原型属性（引用类型）\n```\n\n#### 原型链继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;\n}\nCat.prototype = new Animal();                // 父类的实例作为子类的原型对象\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；\n```\n\n优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；\n缺点: 子类实例共享了父类构造函数的引用数据类型属性。\n\n#### 借用构造函数\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);             // 核心，把父类的实例方法属性指向子类\n}\n\nvar tom = new Cat('tom');                    // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承\nvar black = new Cat('black');\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                      // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                  // undefind 无法继承父类的原型属性及方法；\n```\n\n优点: \n1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；\n2、 创建子类实例，可以向父类构造函数传参数；\n缺点: 子类实例不能继承父类的构造属性和方法；\n\n#### 组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);              // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = new Parent()                  // 核心, 父类的实例作为子类的原型对象\nCat.prototype.constructor = Cat;              // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                       // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                   // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；\n3、不共享父类的构造方法及属性；\n缺点: 调用了2次父类的构造方法\n\n#### 寄生组合继承\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                       // 核心，把父类的实例方法属性指向子类\n}\nCat.prototype = Parent.prototype;                      // 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）\nCat.prototype.constructor = Cat;                       // 修复子类Cat的构造器指向，防止原型链的混乱\n\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                            // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性\ntom.pArr.push('publish');                              // 修改继承于父类原型属性值 pArr;\nconsole.log(black.pArr);                               // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，\n// 至此简直是完美呀~~~ 然鹅！\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                      // 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型\n```\n\n优点: \n1、创建子类实例，可以向父类构造函数传参数；\n2、子类的实例不共享父类的构造方法及属性；\n3、只调用了1次父类的构造方法；\n缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；\n\n#### 寄生组合继承（简直完美）\n\n``` js\nfunction Cat(n) {\n  this.cName = n;                     \n  Animal.call(this, this.cName);                        // 核心，把父类的实例方法属性指向子类；\n}\nvar F = function(){};                                   // 核心，利用空对象作为中介；\nF.prototype = Parent.prototype;                         // 核心，将父类的原型赋值给空对象F；\nCat.prototype = new F();                                // 核心，将F的实例赋值给子类；\nCat.prototype.constructor = Cat;                        // 修复子类Cat的构造器指向，防止原型链的混乱；\ntom.arr.push('Im tom');\nconsole.log(black.arr);                                 // 打印出 [], 其方法和属性是每个子类实例所私有的；\ntom.sing();                                             // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；\ntom.pArr.push('publish');                               // 修改继承于父类原型属性值 pArr；\nconsole.log(black.pArr);                                // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；\nCat.prototype.childrenProp = '我是子类的原型属性！';\nvar parent = new Animal('父类');\nconsole.log(parent.childrenProp);                       // undefind  父类实例化的对象不拥有子类的原型属性/方法；\n```\n\n优点: 完美实现继承；\n缺点:实现相对复杂\n\n\n#### 附YUI库实现继承\n\n``` js\nfunction extend(Child, Parent) {\n  var F = function(){};\n  F.prototype = Parent.prototype;\n  hild.prototype = new F();\n  Child.prototype.constructor = Child;\n  Child.uber = Parent.prototype;                          \n}\n// 使用\nextend(Cat,Animal);\n```\n\n>`Child.uber = Parent.prototype;` 的意思是为子对象设一个uber属性，这个属性直接指向父对象的`prototype`属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n\n### ES6继承方式\n\n``` js\nclass Animal{                             // 父类\n  constructor(name){                      // 构造函数\n    this.name=name;\n  }\n  eat(){                                  // 实例方法\n    return 'hello world';\n  }\n}\nclass Cat extends Animal{                 // 子类\n  constructor(name){\n    super(name);                          // 调用实现父类的构造函数\n    this.pName = name;            \n  }\n  sing(){\n \t return '吹呀吹呀，我的骄傲放纵~~';\n  }\n}\n```\n\n[1]: https://segmentfault.com/a/1190000015343232\n","slug":"js构造函数","published":1,"updated":"2018-10-09T09:20:11.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn1lab6l0008ccuj8uvmy823","content":"<p>前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法<a href=\"https://segmentfault.com/a/1190000015343232\" target=\"_blank\" rel=\"noopener\">js构造函数</a>，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~</p>\n<a id=\"more\"></a>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Persion</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;                         <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nameName</span>)</span>&#123;        <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = newName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Persion.prototype.sex = <span class=\"string\">'man'</span>;              <span class=\"comment\">// 向 Persion 原型中追加属性（原型方法）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> persion = <span class=\"keyword\">new</span> Persion(<span class=\"string\">'zhang'</span>);         <span class=\"comment\">// 此时我们实例化一个persion对象，看一下name和sex有什么区别</span></span><br></pre></td></tr></table></figure>\n<p>通过 prototype 添加的属性将出现在实例对象的原型链中，</p>\n<blockquote>\n<p>每个对象都会有一个内置 <strong>proto</strong> 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）</p>\n</blockquote>\n<p>我们再来看下面的例子</p>\n<blockquote>\n<p><strong>注意</strong>：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;                      <span class=\"comment\">// 声明一个构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;             \t\t\t\t\t    <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                          <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];               <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们看一下实例属性/方法 和 原型属性/方法的区别</p>\n<blockquote>\n<p>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);               <span class=\"comment\">// 实例化cat对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);\t             <span class=\"comment\">// 实例化狗子对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.say === dog.say                        <span class=\"comment\">// false 不同的实例拥有不同的实例属性/方法</span></span><br><span class=\"line\">cat.sing === dog.sing                      <span class=\"comment\">// true 不同的实例共享相同的原型属性/方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.arr.push(<span class=\"string\">'zz'</span>);                        <span class=\"comment\">// 向cat实例对象的arr中追加元素；（私有）</span></span><br><span class=\"line\">cat.pArr.push(<span class=\"string\">'xx'</span>);                       <span class=\"comment\">// 向cat原型对象的pArr中追加元素；（共享）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.arr);                      <span class=\"comment\">// 打印出 []，因为cat只改变了其私有的arr</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.pArr);                             <span class=\"comment\">// 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr</span></span><br></pre></td></tr></table></figure>\n<p>当然，原型属性为基本数据类型，则不会被共享<br>在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：<br>1、将属性封装在构造函数中<br>2、将方法定义在原型对象上</p>\n<h3 id=\"ES5继承方式\"><a href=\"#ES5继承方式\" class=\"headerlink\" title=\"ES5继承方式\"></a>ES5继承方式</h3><p>首先，我们定义一个Animal父类</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;          \t\t\t\t\t</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;                            <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                            <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                    <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;        <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];                 <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();                <span class=\"comment\">// 父类的实例作为子类的原型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；<br>缺点: 子类实例共享了父类构造函数的引用数据类型属性。</p>\n<h4 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);             <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                  <span class=\"comment\">// undefind 无法继承父类的原型属性及方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；<br>2、 创建子类实例，可以向父类构造函数传参数；<br>缺点: 子类实例不能继承父类的构造属性和方法；</p>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);              <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Parent()                  <span class=\"comment\">// 核心, 父类的实例作为子类的原型对象</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;              <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                       <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                   <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；<br>3、不共享父类的构造方法及属性；<br>缺点: 调用了2次父类的构造方法</p>\n<h4 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                       <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = Parent.prototype;                      <span class=\"comment\">// 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                       <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                            <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                              <span class=\"comment\">// 修改继承于父类原型属性值 pArr;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                               <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，</span></span><br><span class=\"line\"><span class=\"comment\">// 至此简直是完美呀~~~ 然鹅！</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                      <span class=\"comment\">// 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、子类的实例不共享父类的构造方法及属性；<br>3、只调用了1次父类的构造方法；<br>缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；</p>\n<h4 id=\"寄生组合继承（简直完美）\"><a href=\"#寄生组合继承（简直完美）\" class=\"headerlink\" title=\"寄生组合继承（简直完美）\"></a>寄生组合继承（简直完美）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                        <span class=\"comment\">// 核心，把父类的实例方法属性指向子类；</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;                                   <span class=\"comment\">// 核心，利用空对象作为中介；</span></span><br><span class=\"line\">F.prototype = Parent.prototype;                         <span class=\"comment\">// 核心，将父类的原型赋值给空对象F；</span></span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();                                <span class=\"comment\">// 核心，将F的实例赋值给子类；</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                        <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱；</span></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                 <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                             <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                               <span class=\"comment\">// 修改继承于父类原型属性值 pArr；</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                                <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                       <span class=\"comment\">// undefind  父类实例化的对象不拥有子类的原型属性/方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 完美实现继承；<br>缺点:实现相对复杂</p>\n<h4 id=\"附YUI库实现继承\"><a href=\"#附YUI库实现继承\" class=\"headerlink\" title=\"附YUI库实现继承\"></a>附YUI库实现继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">Child, Parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  F.prototype = Parent.prototype;</span><br><span class=\"line\">  hild.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  Child.prototype.constructor = Child;</span><br><span class=\"line\">  Child.uber = Parent.prototype;                          </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">extend(Cat,Animal);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Child.uber = Parent.prototype;</code> 的意思是为子对象设一个uber属性，这个属性直接指向父对象的<code>prototype</code>属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>\n</blockquote>\n<h3 id=\"ES6继承方式\"><a href=\"#ES6继承方式\" class=\"headerlink\" title=\"ES6继承方式\"></a>ES6继承方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;                             <span class=\"comment\">// 父类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;                      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  eat()&#123;                                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;                 <span class=\"comment\">// 子类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);                          <span class=\"comment\">// 调用实现父类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pName = name;            </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sing()&#123;</span><br><span class=\"line\"> \t <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法<a href=\"https://segmentfault.com/a/1190000015343232\" target=\"_blank\" rel=\"noopener\">js构造函数</a>，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~</p>","more":"<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Persion</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;                         <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nameName</span>)</span>&#123;        <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = newName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Persion.prototype.sex = <span class=\"string\">'man'</span>;              <span class=\"comment\">// 向 Persion 原型中追加属性（原型方法）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> persion = <span class=\"keyword\">new</span> Persion(<span class=\"string\">'zhang'</span>);         <span class=\"comment\">// 此时我们实例化一个persion对象，看一下name和sex有什么区别</span></span><br></pre></td></tr></table></figure>\n<p>通过 prototype 添加的属性将出现在实例对象的原型链中，</p>\n<blockquote>\n<p>每个对象都会有一个内置 <strong>proto</strong> 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链）</p>\n</blockquote>\n<p>我们再来看下面的例子</p>\n<blockquote>\n<p><strong>注意</strong>：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;                      <span class=\"comment\">// 声明一个构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;             \t\t\t\t\t    <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                          <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];               <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们看一下实例属性/方法 和 原型属性/方法的区别</p>\n<blockquote>\n<p>原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'cat'</span>);               <span class=\"comment\">// 实例化cat对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'dog'</span>);\t             <span class=\"comment\">// 实例化狗子对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.say === dog.say                        <span class=\"comment\">// false 不同的实例拥有不同的实例属性/方法</span></span><br><span class=\"line\">cat.sing === dog.sing                      <span class=\"comment\">// true 不同的实例共享相同的原型属性/方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat.arr.push(<span class=\"string\">'zz'</span>);                        <span class=\"comment\">// 向cat实例对象的arr中追加元素；（私有）</span></span><br><span class=\"line\">cat.pArr.push(<span class=\"string\">'xx'</span>);                       <span class=\"comment\">// 向cat原型对象的pArr中追加元素；（共享）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.arr);                      <span class=\"comment\">// 打印出 []，因为cat只改变了其私有的arr</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.pArr);                             <span class=\"comment\">// 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr</span></span><br></pre></td></tr></table></figure>\n<p>当然，原型属性为基本数据类型，则不会被共享<br>在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：<br>1、将属性封装在构造函数中<br>2、将方法定义在原型对象上</p>\n<h3 id=\"ES5继承方式\"><a href=\"#ES5继承方式\" class=\"headerlink\" title=\"ES5继承方式\"></a>ES5继承方式</h3><p>首先，我们定义一个Animal父类</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">n</span>) </span>&#123;          \t\t\t\t\t</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = n;                            <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [];                            <span class=\"comment\">// 实例属性（引用类型）</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;                    <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;        <span class=\"comment\">// 追加原型方法  </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.pArr = [];                 <span class=\"comment\">// 追加原型属性（引用类型）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();                <span class=\"comment\">// 父类的实例作为子类的原型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；<br>缺点: 子类实例共享了父类构造函数的引用数据类型属性。</p>\n<h4 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);             <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'tom'</span>);                    <span class=\"comment\">// 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> black = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'black'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                      <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                  <span class=\"comment\">// undefind 无法继承父类的原型属性及方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；<br>2、 创建子类实例，可以向父类构造函数传参数；<br>缺点: 子类实例不能继承父类的构造属性和方法；</p>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);              <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Parent()                  <span class=\"comment\">// 核心, 父类的实例作为子类的原型对象</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;              <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                       <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                   <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；<br>3、不共享父类的构造方法及属性；<br>缺点: 调用了2次父类的构造方法</p>\n<h4 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                       <span class=\"comment\">// 核心，把父类的实例方法属性指向子类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = Parent.prototype;                      <span class=\"comment\">// 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                       <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱</span></span><br><span class=\"line\"></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                            <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                              <span class=\"comment\">// 修改继承于父类原型属性值 pArr;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                               <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，</span></span><br><span class=\"line\"><span class=\"comment\">// 至此简直是完美呀~~~ 然鹅！</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                      <span class=\"comment\">// 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型</span></span><br></pre></td></tr></table></figure>\n<p>优点:<br>1、创建子类实例，可以向父类构造函数传参数；<br>2、子类的实例不共享父类的构造方法及属性；<br>3、只调用了1次父类的构造方法；<br>缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类；</p>\n<h4 id=\"寄生组合继承（简直完美）\"><a href=\"#寄生组合继承（简直完美）\" class=\"headerlink\" title=\"寄生组合继承（简直完美）\"></a>寄生组合继承（简直完美）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cName = n;                     </span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.cName);                        <span class=\"comment\">// 核心，把父类的实例方法属性指向子类；</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;                                   <span class=\"comment\">// 核心，利用空对象作为中介；</span></span><br><span class=\"line\">F.prototype = Parent.prototype;                         <span class=\"comment\">// 核心，将父类的原型赋值给空对象F；</span></span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> F();                                <span class=\"comment\">// 核心，将F的实例赋值给子类；</span></span><br><span class=\"line\">Cat.prototype.constructor = Cat;                        <span class=\"comment\">// 修复子类Cat的构造器指向，防止原型链的混乱；</span></span><br><span class=\"line\">tom.arr.push(<span class=\"string\">'Im tom'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.arr);                                 <span class=\"comment\">// 打印出 [], 其方法和属性是每个子类实例所私有的；</span></span><br><span class=\"line\">tom.sing();                                             <span class=\"comment\">// 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；</span></span><br><span class=\"line\">tom.pArr.push(<span class=\"string\">'publish'</span>);                               <span class=\"comment\">// 修改继承于父类原型属性值 pArr；</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(black.pArr);                                <span class=\"comment\">// 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；</span></span><br><span class=\"line\">Cat.prototype.childrenProp = <span class=\"string\">'我是子类的原型属性！'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'父类'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.childrenProp);                       <span class=\"comment\">// undefind  父类实例化的对象不拥有子类的原型属性/方法；</span></span><br></pre></td></tr></table></figure>\n<p>优点: 完美实现继承；<br>缺点:实现相对复杂</p>\n<h4 id=\"附YUI库实现继承\"><a href=\"#附YUI库实现继承\" class=\"headerlink\" title=\"附YUI库实现继承\"></a>附YUI库实现继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">Child, Parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  F.prototype = Parent.prototype;</span><br><span class=\"line\">  hild.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  Child.prototype.constructor = Child;</span><br><span class=\"line\">  Child.uber = Parent.prototype;                          </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">extend(Cat,Animal);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Child.uber = Parent.prototype;</code> 的意思是为子对象设一个uber属性，这个属性直接指向父对象的<code>prototype</code>属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>\n</blockquote>\n<h3 id=\"ES6继承方式\"><a href=\"#ES6继承方式\" class=\"headerlink\" title=\"ES6继承方式\"></a>ES6继承方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;                             <span class=\"comment\">// 父类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;                      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  eat()&#123;                                  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;                 <span class=\"comment\">// 子类</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name);                          <span class=\"comment\">// 调用实现父类的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pName = name;            </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sing()&#123;</span><br><span class=\"line\"> \t <span class=\"keyword\">return</span> <span class=\"string\">'吹呀吹呀，我的骄傲放纵~~'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"给Hexo博客添加访问统计","date":"2018-09-27T08:35:58.000Z","thumbnail":"/bolg/2018/09/27/给Hexo博客添加访问统计/bsz.jpg","_content":"导语： 引入不蒜子为你的博客添加访问量\n<!--more-->\n### 引入不蒜子\n``` bash\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里\n\n### 添加站点访问量\n通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：\n``` bash\n<span id=\"busuanzi_container_site_uv\"> \n  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n</span>\n```\n计算访问量的方法有两种：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n我用的是uv的方式，大家自行选择即可。\n\n### 添加文章访问量\n文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：\n``` bash\n<span id=\"busuanzi_container_page_pv\">\n   本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n</span>\n```\n\n参考 : [不蒜子](http://busuanzi.ibruce.info/)\n","source":"_posts/给Hexo博客添加访问统计.md","raw":"---\ntitle: 给Hexo博客添加访问统计\ndate: 2018-09-27 16:35:58\ncategories: 工具\ntags: hexo\nthumbnail: /bolg/2018/09/27/给Hexo博客添加访问统计/bsz.jpg\n---\n导语： 引入不蒜子为你的博客添加访问量\n<!--more-->\n### 引入不蒜子\n``` bash\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里\n\n### 添加站点访问量\n通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：\n``` bash\n<span id=\"busuanzi_container_site_uv\"> \n  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n</span>\n```\n计算访问量的方法有两种：\n算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。\n算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。\n我用的是uv的方式，大家自行选择即可。\n\n### 添加文章访问量\n文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：\n``` bash\n<span id=\"busuanzi_container_page_pv\">\n   本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n</span>\n```\n\n参考 : [不蒜子](http://busuanzi.ibruce.info/)\n","slug":"给Hexo博客添加访问统计","published":1,"updated":"2018-10-09T03:07:49.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn1lab6t000bccuj10un1ks8","content":"<p>导语： 引入不蒜子为你的博客添加访问量<br><a id=\"more\"></a></p>\n<h3 id=\"引入不蒜子\"><a href=\"#引入不蒜子\" class=\"headerlink\" title=\"引入不蒜子\"></a>引入不蒜子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=<span class=\"string\">\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里</p>\n<h3 id=\"添加站点访问量\"><a href=\"#添加站点访问量\" class=\"headerlink\" title=\"添加站点访问量\"></a>添加站点访问量</h3><p>通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_site_uv\"</span>&gt; </span><br><span class=\"line\">  本站访客数&lt;span id=<span class=\"string\">\"busuanzi_value_site_uv\"</span>&gt;&lt;/span&gt;人次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>计算访问量的方法有两种：<br>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。<br>我用的是uv的方式，大家自行选择即可。</p>\n<h3 id=\"添加文章访问量\"><a href=\"#添加文章访问量\" class=\"headerlink\" title=\"添加文章访问量\"></a>添加文章访问量</h3><p>文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_page_pv\"</span>&gt;</span><br><span class=\"line\">   本文总阅读量&lt;span id=<span class=\"string\">\"busuanzi_value_page_pv\"</span>&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参考 : <a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子</a></p>\n","site":{"data":{}},"excerpt":"<p>导语： 引入不蒜子为你的博客添加访问量<br></p>","more":"<p></p>\n<h3 id=\"引入不蒜子\"><a href=\"#引入不蒜子\" class=\"headerlink\" title=\"引入不蒜子\"></a>引入不蒜子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=<span class=\"string\">\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里</p>\n<h3 id=\"添加站点访问量\"><a href=\"#添加站点访问量\" class=\"headerlink\" title=\"添加站点访问量\"></a>添加站点访问量</h3><p>通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_site_uv\"</span>&gt; </span><br><span class=\"line\">  本站访客数&lt;span id=<span class=\"string\">\"busuanzi_value_site_uv\"</span>&gt;&lt;/span&gt;人次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>计算访问量的方法有两种：<br>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。<br>我用的是uv的方式，大家自行选择即可。</p>\n<h3 id=\"添加文章访问量\"><a href=\"#添加文章访问量\" class=\"headerlink\" title=\"添加文章访问量\"></a>添加文章访问量</h3><p>文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id=<span class=\"string\">\"busuanzi_container_page_pv\"</span>&gt;</span><br><span class=\"line\">   本文总阅读量&lt;span id=<span class=\"string\">\"busuanzi_value_page_pv\"</span>&gt;&lt;/span&gt;次</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参考 : <a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">不蒜子</a></p>"},{"title":"递归树结构解析","date":"2018-10-08T03:40:07.000Z","banner":"/bolg/2018/10/08/递归树结构解析/banner.jpg","_content":"\n用递归的方式将树结构从根到叶子节点解析成数组\n<!-- more -->\n\n从后台获取树结构的 json 数据，渲染成树图结构\n由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组\n算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看\n\n``` bash\n数据结构如下：                  目标数组如下：         \n     a                       \n    / \\                      1) [a, b, c]\n   b   e         ==>>        2) [a, b, d]\n  / \\   \\                    3) [a, e, f]\n c   d   f     \n```\n\n``` bash\nconst obj = {\n  val: 'a',\n  children: [\n    { val: 'b', children: [\n        { val: 'c', children: [] },\n        { val: 'd', children: [] },\n      ],\n    },\n    { val: 'e', children: [\n        { val: 'f', }\n      ],\n    },\n  ],\n};\n```\n\n废话不多说，直接上代码\n``` bash\n// 法一\nconst initArr = (obj) => {\n  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果\n  (function travel(item, arr){                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组\n    if (item.children && item.children.length) {            // 判断是否存在子元素，存在则遍历子元素递归调用\n      for (let i = 0; i < item.children.length; i += 1) {\n        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度\n      }\n    } else {                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中\n      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中\n    }\n  }(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空\n  return newArr;\n}\n```\n\n``` bash\n// 法二\nconst initArr = (obj) => {\n  const newArr = [];\n  (function travel(item, arr){\n    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染\n    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可\n    if (item.children && item.children.length) {\n      for (let i in item.children) {\n        travel(data.children[i], itemArr);\n      }\n    } else {\n      newArr.push(itemArr);\n    }\n  })(obj, [])\n  return newArr;\n}\n```\n\n`\n结果如下图\n`\n![递归解析树结构](递归树结构解析/result.jpg)\n\n","source":"_posts/递归树结构解析.md","raw":"---\ntitle: '递归树结构解析'\ndate: 2018-10-08 11:40:07\ncategories: \"笔记\"\ntags: [js, 算法, 前端]\nbanner: /bolg/2018/10/08/递归树结构解析/banner.jpg\n---\n\n用递归的方式将树结构从根到叶子节点解析成数组\n<!-- more -->\n\n从后台获取树结构的 json 数据，渲染成树图结构\n由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组\n算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看\n\n``` bash\n数据结构如下：                  目标数组如下：         \n     a                       \n    / \\                      1) [a, b, c]\n   b   e         ==>>        2) [a, b, d]\n  / \\   \\                    3) [a, e, f]\n c   d   f     \n```\n\n``` bash\nconst obj = {\n  val: 'a',\n  children: [\n    { val: 'b', children: [\n        { val: 'c', children: [] },\n        { val: 'd', children: [] },\n      ],\n    },\n    { val: 'e', children: [\n        { val: 'f', }\n      ],\n    },\n  ],\n};\n```\n\n废话不多说，直接上代码\n``` bash\n// 法一\nconst initArr = (obj) => {\n  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果\n  (function travel(item, arr){                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组\n    if (item.children && item.children.length) {            // 判断是否存在子元素，存在则遍历子元素递归调用\n      for (let i = 0; i < item.children.length; i += 1) {\n        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度\n      }\n    } else {                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中\n      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中\n    }\n  }(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空\n  return newArr;\n}\n```\n\n``` bash\n// 法二\nconst initArr = (obj) => {\n  const newArr = [];\n  (function travel(item, arr){\n    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染\n    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可\n    if (item.children && item.children.length) {\n      for (let i in item.children) {\n        travel(data.children[i], itemArr);\n      }\n    } else {\n      newArr.push(itemArr);\n    }\n  })(obj, [])\n  return newArr;\n}\n```\n\n`\n结果如下图\n`\n![递归解析树结构](递归树结构解析/result.jpg)\n\n","slug":"递归树结构解析","published":1,"updated":"2018-10-09T06:39:38.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn1lab6w000cccujlq93cv1q","content":"<p>用递归的方式将树结构从根到叶子节点解析成数组<br><a id=\"more\"></a></p>\n<p>从后台获取树结构的 json 数据，渲染成树图结构<br>由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组<br>算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据结构如下：                  目标数组如下：         </span><br><span class=\"line\">     a                       </span><br><span class=\"line\">    / \\                      1) [a, b, c]</span><br><span class=\"line\">   b   e         ==&gt;&gt;        2) [a, b, d]</span><br><span class=\"line\">  / \\   \\                    3) [a, e, f]</span><br><span class=\"line\"> c   d   f</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">  val: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  children: [</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'b'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'c'</span>, children: [] &#125;,</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'d'</span>, children: [] &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'e'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'f'</span>, &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>废话不多说，直接上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法一</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;            // 判断是否存在子元素，存在则遍历子元素递归调用</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 0; i &lt; item.children.length; i += 1) &#123;</span><br><span class=\"line\">        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中</span><br><span class=\"line\">      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法二</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;</span><br><span class=\"line\">    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染</span><br><span class=\"line\">    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i <span class=\"keyword\">in</span> item.children) &#123;</span><br><span class=\"line\">        travel(data.children[i], itemArr);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newArr.push(itemArr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(obj, [])</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>结果如下图</code><br><img src=\"/bolg/2018/10/08/递归树结构解析/result.jpg\" alt=\"递归解析树结构\"></p>\n","site":{"data":{}},"excerpt":"<p>用递归的方式将树结构从根到叶子节点解析成数组<br></p>","more":"<p></p>\n<p>从后台获取树结构的 json 数据，渲染成树图结构<br>由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组<br>算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据结构如下：                  目标数组如下：         </span><br><span class=\"line\">     a                       </span><br><span class=\"line\">    / \\                      1) [a, b, c]</span><br><span class=\"line\">   b   e         ==&gt;&gt;        2) [a, b, d]</span><br><span class=\"line\">  / \\   \\                    3) [a, e, f]</span><br><span class=\"line\"> c   d   f</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">  val: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  children: [</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'b'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'c'</span>, children: [] &#125;,</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'d'</span>, children: [] &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; val: <span class=\"string\">'e'</span>, children: [</span><br><span class=\"line\">        &#123; val: <span class=\"string\">'f'</span>, &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>废话不多说，直接上代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法一</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];                                        // 定义空数组，用于每次遍历结束后存储结果</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;                              // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;            // 判断是否存在子元素，存在则遍历子元素递归调用</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 0; i &lt; item.children.length; i += 1) &#123;</span><br><span class=\"line\">        travel(item.children[i], arr.concat(item));         // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                                                // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中</span><br><span class=\"line\">      newArr.push(arr.concat(item));                        // 注意此处要记得将本次递归的 item 添加到arr中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;(obj, []));                                              // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 法二</span><br><span class=\"line\">const initArr = (obj) =&gt; &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> travel(item, arr)&#123;</span><br><span class=\"line\">    const itemArr = [...arr];                      // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染</span><br><span class=\"line\">    itemArr.push(item);                            // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.children &amp;&amp; item.children.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i <span class=\"keyword\">in</span> item.children) &#123;</span><br><span class=\"line\">        travel(data.children[i], itemArr);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newArr.push(itemArr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(obj, [])</span><br><span class=\"line\">  <span class=\"built_in\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>结果如下图</code><br><img src=\"/bolg/2018/10/08/递归树结构解析/result.jpg\" alt=\"递归解析树结构\"></p>"},{"title":"递归尾调用优化","date":"2018-10-08T09:19:48.000Z","banner":"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg","_content":"\n>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误...\n\n<!-- more -->\n\n### 什么是尾调用？\n\n>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n\n``` bash\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数`f`的最后一步是调用函数`g`，这就叫尾调用。\n以下三种情况，都不属于尾调用。\n\n``` bash\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n上面代码中\n情况一: 是调用函数`g`之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;\n情况二: 属于调用后还有操作，即使写在一行内;\n情况三: 等同于下面的代码;\n\n``` bash\nfunction f(x){\n  g(x);\n  return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n``` bash\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数`m`和`n`都属于尾调用，因为它们都是函数`f`的最后一步操作。\n\n### 尾调用优化\n\n>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n``` bash\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数g不是尾调用，函数`f`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息。但由于调用`g`之后，函数`f`就结束了，所以执行到最后一步，完全可以删除`f(x)`的调用帧，只保留`g(3)`的调用帧。\n\n>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n``` bash\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n```\n\n上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。\n\n\n### 尾递归\n\n>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n``` bash\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n```\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n``` bash\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n```\n\n还有一个比较著名的例子，就是计算 `Fibonacci` 数列，也能充分说明尾递归优化的重要性。\n非尾递归的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10)  // 89\nFibonacci(100) // 堆栈溢出\nFibonacci(500) // 堆栈溢出\n```\n\n尾递归优化过的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100)   // 573147844013817200000\nFibonacci2(1000)  // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n附： 循环版\n\n``` bash\nfunction Fibonacci3(n){\n    if (n===1 || n===2) {\n        return 1;\n    }\n    let ac1 = 1, ac2 = 1;\n    for (let i = 2; i < n; i++){\n        [ac1, ac2] = [ac2, ac1 + ac2];\n    }\n    return ac2;\n}\n```\n\n>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n参考文献：[ECMAScript 6 入门 - 阮一峰][1]\n[1]:http://es6.ruanyifeng.com/\n","source":"_posts/递归尾调用优化.md","raw":"---\ntitle: '递归尾调用优化'\ndate: 2018-10-08 17:19:48\nbanner: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=26&gp=0.jpg\ncategories: '笔记'\ntags:\n\t- js\n\t- 算法\n\t- ES6\n---\n\n>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误...\n\n<!-- more -->\n\n### 什么是尾调用？\n\n>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n\n``` bash\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数`f`的最后一步是调用函数`g`，这就叫尾调用。\n以下三种情况，都不属于尾调用。\n\n``` bash\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n上面代码中\n情况一: 是调用函数`g`之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;\n情况二: 属于调用后还有操作，即使写在一行内;\n情况三: 等同于下面的代码;\n\n``` bash\nfunction f(x){\n  g(x);\n  return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n``` bash\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数`m`和`n`都属于尾调用，因为它们都是函数`f`的最后一步操作。\n\n### 尾调用优化\n\n>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n``` bash\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数g不是尾调用，函数`f`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息。但由于调用`g`之后，函数`f`就结束了，所以执行到最后一步，完全可以删除`f(x)`的调用帧，只保留`g(3)`的调用帧。\n\n>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n``` bash\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n```\n\n上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。\n\n\n### 尾递归\n\n>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n``` bash\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n```\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n``` bash\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n```\n\n还有一个比较著名的例子，就是计算 `Fibonacci` 数列，也能充分说明尾递归优化的重要性。\n非尾递归的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10)  // 89\nFibonacci(100) // 堆栈溢出\nFibonacci(500) // 堆栈溢出\n```\n\n尾递归优化过的 `Fibonacci` 数列实现如下。\n\n``` bash\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100)   // 573147844013817200000\nFibonacci2(1000)  // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n附： 循环版\n\n``` bash\nfunction Fibonacci3(n){\n    if (n===1 || n===2) {\n        return 1;\n    }\n    let ac1 = 1, ac2 = 1;\n    for (let i = 2; i < n; i++){\n        [ac1, ac2] = [ac2, ac1 + ac2];\n    }\n    return ac2;\n}\n```\n\n>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n参考文献：[ECMAScript 6 入门 - 阮一峰][1]\n[1]:http://es6.ruanyifeng.com/\n","slug":"递归尾调用优化","published":1,"updated":"2018-10-09T06:31:34.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn1lab71000gccuj93ynp682","content":"<blockquote>\n<p>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误…</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h3><blockquote>\n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。<br>以下三种情况，都不属于尾调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 情况一</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况二</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x) + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况三</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中<br>情况一: 是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;<br>情况二: 属于调用后还有操作，即使写在一行内;<br>情况三: 等同于下面的代码;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; 0) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>\n<h3 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><blockquote>\n<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n</blockquote>\n<blockquote>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> m = 1;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> n = 2;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">g(3);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果函数g不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>\n<blockquote>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n</blockquote>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addOne(a)&#123;</span><br><span class=\"line\">  var one = 1;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> inner(b)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> b + one;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> inner(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><blockquote>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n</blockquote>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n * factorial(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5) // 120</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n, total) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> total;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> factorial(n - 1, n * total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure>\n<p>还有一个比较著名的例子，就是计算 <code>Fibonacci</code> 数列，也能充分说明尾递归优化的重要性。<br>非尾递归的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci (n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> 1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci(10)  // 89</span><br><span class=\"line\">Fibonacci(100) // 堆栈溢出</span><br><span class=\"line\">Fibonacci(500) // 堆栈溢出</span><br></pre></td></tr></table></figure>\n<p>尾递归优化过的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> ac2&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci2(100)   // 573147844013817200000</span><br><span class=\"line\">Fibonacci2(1000)  // 7.0330367711422765e+208</span><br><span class=\"line\">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure>\n<p>附： 循环版</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci3(n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n===1 || n===2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> ac1 = 1, ac2 = 1;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 2; i &lt; n; i++)&#123;</span><br><span class=\"line\">        [ac1, ac2] = [ac2, ac1 + ac2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> ac2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n</blockquote>\n<p>参考文献：[ECMAScript 6 入门 - 阮一峰][1]<br>[1]:<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误…</p>\n</blockquote>","more":"<h3 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h3><blockquote>\n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。<br>以下三种情况，都不属于尾调用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 情况一</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况二</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(x) + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 情况三</span><br><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中<br>情况一: 是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;<br>情况二: 属于调用后还有操作，即使写在一行内;<br>情况三: 等同于下面的代码;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x)&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">  <span class=\"built_in\">return</span> undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(x) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; 0) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>\n<h3 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><blockquote>\n<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n</blockquote>\n<blockquote>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> m = 1;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> n = 2;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> g(3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">g(3);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果函数g不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>\n<blockquote>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n</blockquote>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addOne(a)&#123;</span><br><span class=\"line\">  var one = 1;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> inner(b)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> b + one;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> inner(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><blockquote>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n</blockquote>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> n * factorial(n - 1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5) // 120</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> factorial(n, total) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === 1) <span class=\"built_in\">return</span> total;</span><br><span class=\"line\">  <span class=\"built_in\">return</span> factorial(n - 1, n * total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure>\n<p>还有一个比较著名的例子，就是计算 <code>Fibonacci</code> 数列，也能充分说明尾递归优化的重要性。<br>非尾递归的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci (n) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> 1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci(10)  // 89</span><br><span class=\"line\">Fibonacci(100) // 堆栈溢出</span><br><span class=\"line\">Fibonacci(500) // 堆栈溢出</span><br></pre></td></tr></table></figure>\n<p>尾递归优化过的 <code>Fibonacci</code> 数列实现如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( n &lt;= 1 ) &#123;<span class=\"built_in\">return</span> ac2&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci2(100)   // 573147844013817200000</span><br><span class=\"line\">Fibonacci2(1000)  // 7.0330367711422765e+208</span><br><span class=\"line\">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure>\n<p>附： 循环版</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> Fibonacci3(n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n===1 || n===2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> ac1 = 1, ac2 = 1;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> i = 2; i &lt; n; i++)&#123;</span><br><span class=\"line\">        [ac1, ac2] = [ac2, ac1 + ac2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> ac2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n</blockquote>\n<p>参考文献：[ECMAScript 6 入门 - 阮一峰][1]<br>[1]:<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a></p>"}],"PostAsset":[{"_id":"source/_posts/hexo-创建文章/suoluetu.png","slug":"suoluetu.png","post":"cjn1lab6d0007ccuje6ddj0pw","modified":1,"renderable":0},{"_id":"source/_posts/js构造函数/slt.jpg","slug":"slt.jpg","post":"cjn1lab6l0008ccuj8uvmy823","modified":1,"renderable":0},{"_id":"source/_posts/RISE/banner.jpg","post":"cjn1lab5o0000ccuj0zz10xqp","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/js构造函数/banner.jpg","post":"cjn1lab6l0008ccuj8uvmy823","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/给Hexo博客添加访问统计/bsz.jpg","post":"cjn1lab6t000bccuj10un1ks8","slug":"bsz.jpg","modified":1,"renderable":1},{"_id":"source/_posts/给Hexo博客添加访问统计/timg.jpg","post":"cjn1lab6t000bccuj10un1ks8","slug":"timg.jpg","modified":1,"renderable":1},{"_id":"source/_posts/递归树结构解析/banner.jpg","post":"cjn1lab6w000cccujlq93cv1q","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/递归树结构解析/result.jpg","post":"cjn1lab6w000cccujlq93cv1q","slug":"result.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/banner.jpg","post":"cjn1lab6d0007ccuje6ddj0pw","slug":"banner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/lujing.jpg","post":"cjn1lab6d0007ccuje6ddj0pw","slug":"lujing.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/lujing2.jpg","post":"cjn1lab6d0007ccuje6ddj0pw","slug":"lujing2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo-创建文章/wenjian.jpg","post":"cjn1lab6d0007ccuje6ddj0pw","slug":"wenjian.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjn1lab5o0000ccuj0zz10xqp","category_id":"cjn1lab630004ccuj91c1rsdb","_id":"cjn1lab6y000dccujuszcz27q"},{"post_id":"cjn1lab5y0002ccujg0oo26ve","category_id":"cjn1lab6n0009ccuj74chpiau","_id":"cjn1lab75000jccujq3jhc16c"},{"post_id":"cjn1lab6w000cccujlq93cv1q","category_id":"cjn1lab6n0009ccuj74chpiau","_id":"cjn1lab78000mccujyyes1nph"},{"post_id":"cjn1lab71000gccuj93ynp682","category_id":"cjn1lab6n0009ccuj74chpiau","_id":"cjn1lab79000nccujfr18rs9d"},{"post_id":"cjn1lab660006ccujxapkz60h","category_id":"cjn1lab6y000eccuj4n07abem","_id":"cjn1lab7c000qccujtwuj4th8"},{"post_id":"cjn1lab6d0007ccuje6ddj0pw","category_id":"cjn1lab6y000eccuj4n07abem","_id":"cjn1lab7e000tccujm7ohke07"},{"post_id":"cjn1lab6l0008ccuj8uvmy823","category_id":"cjn1lab6n0009ccuj74chpiau","_id":"cjn1lab7g000xccujjreulwoo"},{"post_id":"cjn1lab6t000bccuj10un1ks8","category_id":"cjn1lab6y000eccuj4n07abem","_id":"cjn1lab7h000zccujrbrj0gb8"}],"PostTag":[{"post_id":"cjn1lab5o0000ccuj0zz10xqp","tag_id":"cjn1lab650005ccujqufm1ftg","_id":"cjn1lab73000hccujihaa1nym"},{"post_id":"cjn1lab5o0000ccuj0zz10xqp","tag_id":"cjn1lab6o000accuj1xhzc7gv","_id":"cjn1lab74000iccuj798zxd4k"},{"post_id":"cjn1lab5y0002ccujg0oo26ve","tag_id":"cjn1lab6z000fccujf4pd8iih","_id":"cjn1lab7d000rccujkd516jds"},{"post_id":"cjn1lab5y0002ccujg0oo26ve","tag_id":"cjn1lab76000lccujxdkmyzkh","_id":"cjn1lab7e000uccujwqwzfrv4"},{"post_id":"cjn1lab660006ccujxapkz60h","tag_id":"cjn1lab7b000pccuj2nxgy2jk","_id":"cjn1lab7g000wccujtg51e2c8"},{"post_id":"cjn1lab6d0007ccuje6ddj0pw","tag_id":"cjn1lab7b000pccuj2nxgy2jk","_id":"cjn1lab7k0012ccuje8hpuhgv"},{"post_id":"cjn1lab6d0007ccuje6ddj0pw","tag_id":"cjn1lab7g000yccujqh1wmqgt","_id":"cjn1lab7l0013ccuja6rtob5b"},{"post_id":"cjn1lab6d0007ccuje6ddj0pw","tag_id":"cjn1lab7i0010ccujrb8284fh","_id":"cjn1lab7m0015ccuj1ff2o5v3"},{"post_id":"cjn1lab6l0008ccuj8uvmy823","tag_id":"cjn1lab6z000fccujf4pd8iih","_id":"cjn1lab7m0016ccujogcb2w17"},{"post_id":"cjn1lab6t000bccuj10un1ks8","tag_id":"cjn1lab7b000pccuj2nxgy2jk","_id":"cjn1lab7o0018ccuj2hyb1idk"},{"post_id":"cjn1lab6w000cccujlq93cv1q","tag_id":"cjn1lab6z000fccujf4pd8iih","_id":"cjn1lab7r001cccujehcnopfl"},{"post_id":"cjn1lab6w000cccujlq93cv1q","tag_id":"cjn1lab7p0019ccuj8pqog97s","_id":"cjn1lab7r001dccujwlqhz2wr"},{"post_id":"cjn1lab6w000cccujlq93cv1q","tag_id":"cjn1lab7i0010ccujrb8284fh","_id":"cjn1lab7s001fccuje848wwwd"},{"post_id":"cjn1lab71000gccuj93ynp682","tag_id":"cjn1lab6z000fccujf4pd8iih","_id":"cjn1lab7s001gccujn47ade7z"},{"post_id":"cjn1lab71000gccuj93ynp682","tag_id":"cjn1lab7p0019ccuj8pqog97s","_id":"cjn1lab7t001hccujnnk5i4y8"},{"post_id":"cjn1lab71000gccuj93ynp682","tag_id":"cjn1lab76000lccujxdkmyzkh","_id":"cjn1lab7t001iccujcqej0mdg"}],"Tag":[{"name":"LOL","_id":"cjn1lab650005ccujqufm1ftg"},{"name":"video","_id":"cjn1lab6o000accuj1xhzc7gv"},{"name":"js","_id":"cjn1lab6z000fccujf4pd8iih"},{"name":"ES6","_id":"cjn1lab76000lccujxdkmyzkh"},{"name":"hexo","_id":"cjn1lab7b000pccuj2nxgy2jk"},{"name":"markdown","_id":"cjn1lab7g000yccujqh1wmqgt"},{"name":"前端","_id":"cjn1lab7i0010ccujrb8284fh"},{"name":"算法","_id":"cjn1lab7p0019ccuj8pqog97s"}]}}